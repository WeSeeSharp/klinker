{"version":3,"sources":["ReactNativeRenderer-dev.js"],"names":["__DEV__","require","invariant","warning","ReactNativeViewConfigRegistry","UIManager","RCTEventEmitter","React","emptyObject","deepFreezeAndThrowOnMutationInDev","deepDiffer","flattenStyle","TextInputState","checkPropTypes","ExceptionsManager","invokeGuardedCallback","name","func","context","a","b","c","d","e","f","_hasCaughtError","_caughtError","funcArgs","Array","prototype","slice","call","arguments","apply","error","window","dispatchEvent","document","createEvent","fakeNode","createElement","invokeGuardedCallbackDev","evt","didError","callCallback","removeEventListener","evtType","didSetError","isCrossOriginError","onError","event","colno","lineno","addEventListener","initEvent","Error","invokeGuardedCallback$1","ReactErrorUtils","_rethrowError","_hasRethrowError","invokeGuardedCallbackAndCatchFirstError","hasCaughtError","clearCaughtError","rethrowCaughtError","eventPluginOrder","namesToPlugins","recomputePluginOrdering","pluginName","pluginModule","pluginIndex","indexOf","plugins","extractEvents","publishedEvents","eventTypes","eventName","publishEventForPlugin","dispatchConfig","eventNameDispatchConfigs","hasOwnProperty","phasedRegistrationNames","phaseName","phasedRegistrationName","publishRegistrationName","registrationName","registrationNameModules","registrationNameDependencies","dependencies","lowerCasedName","toLowerCase","injectEventPluginOrder","injectedEventPluginOrder","injectEventPluginsByName","injectedNamesToPlugins","isOrderingDirty","getFiberCurrentPropsFromNode","getInstanceFromNode","getNodeFromInstance","injection$1","injectComponentTree","Injected","validateEventDispatches","dispatchListeners","_dispatchListeners","dispatchInstances","_dispatchInstances","listenersIsArr","isArray","listenersLen","length","instancesIsArr","instancesLen","executeDispatch","simulated","listener","inst","type","currentTarget","undefined","executeDispatchesInOrder","i","isPropagationStopped","executeDispatchesInOrderStopAtTrueImpl","executeDispatchesInOrderStopAtTrue","ret","executeDirectDispatch","dispatchListener","dispatchInstance","res","hasDispatches","accumulateInto","current","next","push","concat","forEachAccumulated","arr","cb","scope","forEach","eventQueue","executeDispatchesAndRelease","isPersistent","constructor","release","executeDispatchesAndReleaseSimulated","executeDispatchesAndReleaseTopLevel","isInteractive","tag","shouldPreventMouseEvent","props","disabled","injection","getListener","stateNode","topLevelType","targetInst","nativeEvent","nativeEventTarget","events","possiblePlugin","extractedEvents","runEventsInBatch","processingEventQueue","runExtractedEventsInBatch","IndeterminateComponent","FunctionalComponent","ClassComponent","HostRoot","HostPortal","HostComponent","HostText","Fragment","Mode","ContextConsumer","ContextProvider","ForwardRef","Profiler","TimeoutComponent","getParent","return","getLowestCommonAncestor","instA","instB","depthA","tempA","depthB","tempB","depth","alternate","isAncestor","getParentInstance","traverseTwoPhase","fn","arg","path","listenerAtPhase","propagationPhase","accumulateDirectionalDispatches","phase","accumulateTwoPhaseDispatchesSingle","_targetInst","accumulateTwoPhaseDispatchesSingleSkipTarget","parentInst","accumulateDispatches","ignoredDirection","accumulateDirectDispatchesSingle","accumulateTwoPhaseDispatches","accumulateTwoPhaseDispatchesSkipTarget","accumulateDirectDispatches","didWarnForAddedNewProperty","EVENT_POOL_SIZE","shouldBeReleasedProperties","EventInterface","target","eventPhase","bubbles","cancelable","timeStamp","Date","now","defaultPrevented","isTrusted","functionThatReturnsTrue","functionThatReturnsFalse","SyntheticEvent","preventDefault","stopPropagation","Interface","propName","normalize","returnValue","isDefaultPrevented","cancelBubble","persist","destructor","Object","defineProperty","getPooledWarningPropertyDefinition","extend","Super","E","Class","addEventPoolingTo","isProxySupported","Proxy","isSealed","construct","args","create","that","set","prop","value","getVal","isFunction","configurable","get","get$$1","val","action","warn","result","warningCondition","getPooledEvent","nativeInst","EventConstructor","eventPool","instance","pop","releasePooledEvent","getPooled","SyntheticEvent$1","ResponderSyntheticEvent","touchHistory","TOP_TOUCH_START","TOP_TOUCH_MOVE","TOP_TOUCH_END","TOP_TOUCH_CANCEL","TOP_SCROLL","TOP_SELECTION_CHANGE","isStartish","isMoveish","isEndish","startDependencies","moveDependencies","endDependencies","MAX_TOUCH_BANK","touchBank","numberActiveTouches","indexOfSingleActiveTouch","mostRecentTimeStamp","timestampForTouch","touch","timestamp","createTouchRecord","touchActive","startPageX","pageX","startPageY","pageY","startTimeStamp","currentPageX","currentPageY","currentTimeStamp","previousPageX","previousPageY","previousTimeStamp","resetTouchRecord","touchRecord","getTouchIdentifier","_ref","identifier","recordTouchStart","recordTouchMove","console","printTouch","printTouchBank","recordTouchEnd","JSON","stringify","printed","ResponderTouchHistoryStore","recordTouchTrack","changedTouches","touches","touchTrackToCheck","activeRecord","accumulate","responderInst","trackedTouchCount","changeResponder","nextResponderInst","blockHostResponder","oldResponderInst","ResponderEventPlugin","GlobalResponderHandler","onChange","eventTypes$1","startShouldSetResponder","bubbled","captured","scrollShouldSetResponder","selectionChangeShouldSetResponder","moveShouldSetResponder","responderStart","responderMove","responderEnd","responderRelease","responderTerminationRequest","responderGrant","responderReject","responderTerminate","setResponderAndExtractTransfer","shouldSetEventType","bubbleShouldSetFrom","skipOverBubbleShouldSetFrom","shouldSetEvent","wantsResponderInst","extracted","grantEvent","terminationRequestEvent","shouldSwitch","terminateEvent","rejectEvent","canTriggerTransfer","topLevelInst","responderIgnoreScroll","noResponderTouches","activeTouch","_getResponder","isResponderTouchStart","isResponderTouchMove","isResponderTouchEnd","incrementalTouch","gesture","isResponderTerminate","isResponderRelease","finalTouch","finalEvent","injectGlobalResponderHandler","customBubblingEventTypes$1","customBubblingEventTypes","customDirectEventTypes$1","customDirectEventTypes","eventTypes$2","ReactNativeBridgeEventPlugin","bubbleDispatchConfig","directDispatchConfig","ReactNativeEventPluginOrder","instanceCache","instanceProps","precacheFiberNode","hostInst","uncacheFiberNode","getInstanceFromTag","getTagFromInstance","_nativeTag","canonical","getFiberCurrentPropsFromNode$1","updateFiberProps","ReactNativeComponentTree","freeze","getClosestInstanceFromNode","fiberHostComponent","restoreTarget","restoreQueue","restoreStateOfTarget","internalInstance","restoreControlledState","needsStateRestore","restoreStateIfNeeded","queuedTargets","_batchedUpdates","bookkeeping","_interactiveUpdates","_flushInteractiveUpdates","isBatching","batchedUpdates","controlledComponentsHavePendingUpdates","injection$2","injectRenderer","renderer","interactiveUpdates","flushInteractiveUpdates","EMPTY_NATIVE_EVENT","touchSubsequence","indices","removeTouchesAtIndices","rippedOut","temp","index","fillAt","j","cur","_receiveRootNodeIDEvent","rootNodeID","nativeEventParam","receiveEvent","receiveTouches","eventTopLevelType","changedIndices","jj","ReactNativeEventEmitter","registrationNames","ReactNativeGlobalResponderHandler","from","to","blockNativeResponder","setJSResponder","clearJSResponder","register","get$1","key","_reactInternalFiber","ReactInternals","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentOwner","ReactDebugCurrentFrame","hasSymbol","Symbol","for","REACT_ELEMENT_TYPE","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","REACT_STRICT_MODE_TYPE","REACT_PROFILER_TYPE","REACT_PROVIDER_TYPE","REACT_CONTEXT_TYPE","REACT_ASYNC_MODE_TYPE","REACT_FORWARD_REF_TYPE","REACT_TIMEOUT_TYPE","MAYBE_ITERATOR_SYMBOL","iterator","FAUX_ITERATOR_SYMBOL","getIteratorFn","maybeIterable","maybeIterator","getComponentName","fiber","displayName","pendingProps","id","$$typeof","functionName","render","NoEffect","PerformedWork","Placement","Update","PlacementAndUpdate","Deletion","ContentReset","Callback","DidCapture","Ref","Snapshot","HostEffectMask","Incomplete","ShouldCapture","MOUNTING","MOUNTED","UNMOUNTED","isFiberMountedImpl","node","effectTag","isFiberMounted","isMounted","component","owner","ownerFiber","_warnedAboutRefsInRender","assertIsMounted","findCurrentFiberUsingSlowPath","state","parentA","parentB","child","sibling","didFindChild","_child","findCurrentHostFiber","parent","currentParent","findCurrentHostFiberWithNoPortals","emptyObject$1","removedKeys","removedKeyCount","defaultDiffer","prevProp","nextProp","restoreDeletedValuesInNestedArray","updatePayload","validAttributes","obj","propKey","_nextProp","attributeConfig","diff","process","nextValue","diffNestedArrayProperty","prevArray","nextArray","minLength","diffNestedProperty","clearNestedProperty","addNestedProperty","diffProperties","addProperties","clearProperties","prevProps","nextProps","shouldUpdate","_nextValue","_propKey","mountSafeCallback","callback","__isMounted","throwOnStylesProp","styles","_owner","msg","warnForStyleProps","style","_classCallCheck","Constructor","TypeError","ReactNativeFiberHostComponent","viewConfig","_children","blur","blurTextInput","focus","focusTextInput","measure","measureInWindow","measureLayout","relativeToNativeNode","onSuccess","onFail","setNativeProps","nativeProps","updateView","uiViewClassName","hasNativePerformanceNow","performance","now$1","scheduledCallback","frameDeadline","frameDeadlineObject","timeRemaining","didTimeout","setTimeoutCallback","scheduleDeferredCallback$1","options","timeoutId","setTimeout","cancelDeferredCallback$1","callbackID","clearTimeout","shim","supportsPersistence","cloneInstance","createContainerChildSet","appendChildToContainerChildSet","finalizeContainerChildren","replaceContainerChildren","shim$1","supportsHydration","canHydrateInstance","canHydrateTextInstance","getNextHydratableSibling","getFirstHydratableChild","hydrateInstance","hydrateTextInstance","didNotMatchHydratedContainerTextInstance","didNotMatchHydratedTextInstance","didNotHydrateContainerInstance","didNotHydrateInstance","didNotFindHydratableContainerInstance","didNotFindHydratableContainerTextInstance","didNotFindHydratableInstance","didNotFindHydratableTextInstance","nextReactTag","allocateTag","recursivelyUncacheFiberNode","appendInitialChild","parentInstance","createInstance","rootContainerInstance","hostContext","internalInstanceHandle","isInAParentText","createView","createTextInstance","text","finalizeInitialChildren","nativeTags","map","setChildren","getRootHostContext","getChildHostContext","parentHostContext","prevIsInAParentText","getPublicInstance","prepareForCommit","containerInfo","prepareUpdate","oldProps","newProps","resetAfterCommit","isPrimaryRenderer","scheduleDeferredCallback","cancelDeferredCallback","shouldDeprioritizeSubtree","shouldSetTextContent","supportsMutation","appendChild","childTag","children","splice","manageChildren","appendChildToContainer","commitTextUpdate","textInstance","oldText","newText","commitUpdate","updatePayloadTODO","insertBefore","beforeChild","beforeChildIndex","_beforeChildIndex","insertInContainerBefore","removeChild","removeChildFromContainer","resetTextContent","describeComponentFrame","source","ownerName","fileName","replace","lineNumber","describeFiber","_debugOwner","_debugSource","getStackAddendumByWorkInProgressFiber","workInProgress","info","getCurrentFiberOwnerName","ReactDebugCurrentFiber","getCurrentFiberStackAddendum","resetCurrentFiber","getCurrentStack","setCurrentFiber","setCurrentPhase","debugRenderPhaseSideEffects","debugRenderPhaseSideEffectsForStrictMode","enableGetDerivedStateFromCatch","enableSuspense","enableUserTimingAPI","replayFailedUnitOfWorkWithInvokeGuardedCallback","warnAboutDeprecatedLifecycles","warnAboutLegacyContextAPI","enableProfilerTimer","reactEmoji","warningEmoji","supportsUserTiming","mark","clearMarks","clearMeasures","currentFiber","currentPhase","currentPhaseFiber","isCommitting","hasScheduledUpdateInCurrentCommit","hasScheduledUpdateInCurrentPhase","commitCountInCurrentWorkLoop","effectCountInCurrentCommit","isWaitingForCallback","labelsInCurrentCommit","Set","formatMarkName","markName","formatLabel","label","warning$$1","prefix","suffix","beginMark","clearMark","endMark","formattedMarkName","formattedLabel","err","getFiberMarkName","debugID","getFiberLabel","componentName","beginFiberMark","_debugID","has","add","clearFiberMark","endFiberMark","shouldIgnoreFiber","clearPendingPhaseMeasurement","pauseTimers","_debugIsCurrentlyTiming","resumeTimersRecursively","resumeTimers","recordEffect","recordScheduleUpdate","startRequestCallbackTimer","stopRequestCallbackTimer","didExpire","expirationTime","startWorkTimer","cancelWorkTimer","stopWorkTimer","stopFailedWorkTimer","startPhaseTimer","stopPhaseTimer","startWorkLoopTimer","nextUnitOfWork","stopWorkLoopTimer","interruptedBy","didCompleteRoot","startCommitTimer","clear","stopCommitTimer","startCommitSnapshotEffectsTimer","stopCommitSnapshotEffectsTimer","count","startCommitHostEffectsTimer","stopCommitHostEffectsTimer","startCommitLifeCyclesTimer","stopCommitLifeCyclesTimer","valueStack","fiberStack","createCursor","defaultValue","cursor","checkThatStackIsEmpty","resetStackAfterFatalErrorInDev","warnedAboutMissingGetChildContext","contextStackCursor","didPerformWorkStackCursor","previousContext","getUnmaskedContext","hasOwnContext","isContextProvider","cacheContext","unmaskedContext","maskedContext","__reactInternalMemoizedUnmaskedChildContext","__reactInternalMemoizedMaskedChildContext","getMaskedContext","contextTypes","hasContextChanged","isContextConsumer","childContextTypes","popContextProvider","popTopLevelContextObject","pushTopLevelContextObject","didChange","processChildContext","parentContext","getChildContext","childContext","contextKey","pushContextProvider","memoizedMergedChildContext","__reactInternalMemoizedMergedChildContext","invalidateContextProvider","mergedContext","findCurrentUnmaskedContext","MAX_SIGNED_31_BIT_INT","NoWork","Sync","Never","UNIT_SIZE","MAGIC_NUMBER_OFFSET","msToExpirationTime","ms","expirationTimeToMs","ceiling","num","precision","computeExpirationBucket","currentTime","expirationInMs","bucketSizeMs","NoContext","AsyncMode","StrictMode","ProfileMode","hasBadMapPolyfill","nonExtensibleObject","preventExtensions","testMap","Map","testSet","debugCounter","FiberNode","mode","ref","memoizedProps","updateQueue","memoizedState","nextEffect","firstEffect","lastEffect","actualDuration","actualStartTime","selfBaseTime","treeBaseTime","createFiber","shouldConstruct","Component","isReactComponent","createWorkInProgress","createHostRootFiber","isAsync","createFiberFromElement","element","fiberTag","createFiberFromFragment","createFiberFromProfiler","getFiberTagFromObjectType","_source","keys","elements","onRender","createFiberFromText","content","createFiberFromHostInstanceForDeletion","createFiberFromPortal","portal","pendingChildren","implementation","assignFiberPropertiesInDEV","createFiberRoot","hydrate","uninitializedFiber","root","earliestPendingTime","latestPendingTime","earliestSuspendedTime","latestSuspendedTime","latestPingedTime","pendingCommitExpirationTime","finishedWork","pendingContext","nextExpirationTimeToWorkOn","firstBatch","nextScheduledRoot","onCommitFiberRoot","onCommitFiberUnmount","hasLoggedError","catchErrors","injectInternals","internals","__REACT_DEVTOOLS_GLOBAL_HOOK__","hook","isDisabled","supportsFiber","rendererID","inject","onCommitRoot","onCommitUnmount","lowPriorityWarning","printWarning","format","_len","_key","argIndex","message","x","condition","_len2","_key2","lowPriorityWarning$1","ReactStrictModeWarnings","discardPendingWarnings","flushPendingDeprecationWarnings","flushPendingUnsafeLifecycleWarnings","recordDeprecationWarnings","recordUnsafeLifecycleWarnings","recordLegacyContextWarning","flushLegacyContextWarning","LIFECYCLE_SUGGESTIONS","UNSAFE_componentWillMount","UNSAFE_componentWillReceiveProps","UNSAFE_componentWillUpdate","pendingComponentWillMountWarnings","pendingComponentWillReceivePropsWarnings","pendingComponentWillUpdateWarnings","pendingUnsafeLifecycleWarnings","pendingLegacyContextWarning","didWarnAboutDeprecatedLifecycles","didWarnAboutUnsafeLifecycles","didWarnAboutLegacyContext","setToSortedString","array","sort","join","lifecycleWarningsMap","strictRoot","lifecyclesWarningMesages","lifecycle","lifecycleWarnings","componentNames","formatted","suggestion","sortedComponentNames","strictRootComponentStack","findStrictRoot","maybeStrictRoot","uniqueNames","sortedNames","_uniqueNames","_sortedNames","_uniqueNames2","_sortedNames2","componentWillMount","__suppressDeprecationWarning","componentWillReceiveProps","componentWillUpdate","warningsForRoot","unsafeLifecycles","fiberArray","ReactFiberInstrumentation","debugTool","ReactFiberInstrumentation_1","markPendingPriorityLevel","findNextPendingPriorityLevel","markCommittedPriorityLevels","earliestRemainingTime","hasLowerPriorityWork","renderExpirationTime","markSuspendedPriorityLevel","suspendedTime","markPingedPriorityLevel","pingedTime","UpdateState","ReplaceState","ForceUpdate","CaptureUpdate","hasForceUpdate","didWarnUpdateInsideUpdate","currentlyProcessingQueue","resetCurrentlyProcessingQueue","createUpdateQueue","baseState","queue","firstUpdate","lastUpdate","firstCapturedUpdate","lastCapturedUpdate","firstCapturedEffect","lastCapturedEffect","cloneUpdateQueue","currentQueue","createUpdate","payload","appendUpdateToQueue","update","enqueueUpdate","queue1","queue2","enqueueCapturedUpdate","workInProgressQueue","ensureWorkInProgressQueueIsAClone","getStateFromUpdate","prevState","_payload","_payload2","partialState","processUpdateQueue","newBaseState","newFirstUpdate","newExpirationTime","resultState","updateExpirationTime","_callback","newFirstCapturedUpdate","_updateExpirationTime","_callback2","resetHasForceUpdateBeforeProcessing","checkHasForceUpdateAfterProcessing","commitUpdateQueue","finishedQueue","effect","_callback3","_callback4","createCapturedValue","stack","providerCursor","valueCursor","changedBitsCursor","rendererSigil","pushProvider","providerFiber","_context","_changedBits","_currentValue","_currentRenderer","_changedBits2","_currentValue2","_currentRenderer2","popProvider","changedBits","currentValue","getContextCurrentValue","getContextChangedBits","NO_CONTEXT","contextStackCursor$1","contextFiberStackCursor","rootInstanceStackCursor","requiredContext","getRootHostContainer","rootInstance","pushHostContainer","nextRootInstance","nextRootContext","popHostContainer","getHostContext","pushHostContext","nextContext","popHostContext","commitTime","getCommitTime","recordCommitTime","fiberStack$1","timerPausedAt","totalElapsedPauseTime","checkActualRenderTimeStackEmpty","markActualRenderTimeStarted","pauseActualRenderTimerIfRunning","recordElapsedActualRenderTime","resetActualRenderTimer","resumeActualRenderTimerIfPaused","baseStartTime","recordElapsedBaseRenderTimeIfRunning","startBaseRenderTimer","stopBaseRenderTimerIfRunning","is","y","shallowEqual","objA","objB","keysA","keysB","fakeInternalInstance","didWarnAboutStateAssignmentForComponent","didWarnAboutUninitializedState","didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate","didWarnAboutLegacyLifecyclesAndDerivedState","didWarnAboutUndefinedDerivedState","warnOnUndefinedDerivedState","warnOnInvalidCallback","didWarnOnInvalidCallback","callerName","enumerable","applyDerivedStateFromProps","getDerivedStateFromProps","classComponentUpdater","enqueueSetState","recalculateCurrentTime","computeExpirationForFiber","scheduleWork","enqueueReplaceState","enqueueForceUpdate","checkShouldComponentUpdate","oldState","newState","newContext","ctor","shouldComponentUpdate","isPureReactComponent","checkClassInstance","renderPresent","noGetInitialStateOnES6","getInitialState","isReactClassApproved","noGetDefaultPropsOnES6","getDefaultProps","noInstancePropTypes","propTypes","noInstanceContextTypes","noComponentShouldUpdate","componentShouldUpdate","noComponentDidUnmount","componentDidUnmount","noComponentDidReceiveProps","componentDidReceiveProps","noComponentWillRecieveProps","componentWillRecieveProps","noUnsafeComponentWillRecieveProps","UNSAFE_componentWillRecieveProps","hasMutatedProps","noInstanceDefaultProps","defaultProps","getSnapshotBeforeUpdate","componentDidUpdate","noInstanceGetDerivedStateFromProps","noInstanceGetDerivedStateFromCatch","getDerivedStateFromCatch","noStaticGetSnapshotBeforeUpdate","_state","adoptClassInstance","updater","_reactInternalInstance","constructClassInstance","needsContext","foundWillMountName","foundWillReceivePropsName","foundWillUpdateName","_componentName","newApiName","callComponentWillMount","callComponentWillReceiveProps","mountClassInstance","refs","componentDidMount","resumeMountClassInstance","oldContext","newUnmaskedContext","hasNewLifecycles","updateClassInstance","getCurrentFiberStackAddendum$2","didWarnAboutMaps","didWarnAboutStringRefInStrictMode","ownerHasKeyUseWarning","ownerHasFunctionTypeWarning","warnForMissingKey","_store","validated","currentComponentErrorInfo","isArray$1","coerceRef","returnFiber","mixedRef","stringRef","_stringRef","throwOnInvalidObjectType","newChild","addendum","toString","warnOnFunctionType","ChildReconciler","shouldTrackSideEffects","deleteChild","childToDelete","last","deleteRemainingChildren","currentFirstChild","mapRemainingChildren","existingChildren","existingChild","useFiber","clone","placeChild","newFiber","lastPlacedIndex","newIndex","oldIndex","placeSingleChild","updateTextNode","textContent","created","existing","updateElement","updatePortal","updateFragment","fragment","createChild","_created","_created2","_created3","updateSlot","oldFiber","updateFromMap","newIdx","matchedFiber","_matchedFiber","_matchedFiber2","_matchedFiber3","warnOnInvalidKey","knownKeys","reconcileChildrenArray","newChildren","resultingFirstChild","previousNewFiber","nextOldFiber","_newFiber","_newFiber2","delete","reconcileChildrenIterator","newChildrenIterable","iteratorFn","entries","_newChildren","_step","done","step","_newFiber3","_newFiber4","reconcileSingleTextNode","reconcileSingleElement","_created4","reconcileSinglePortal","reconcileChildFibers","isUnkeyedTopLevelFragment","isObject","_isMockFunction","mountChildFibers","cloneChildFibers","currentChild","hydrationParentFiber","nextHydratableInstance","isHydrating","enterHydrationState","deleteHydratableInstance","insertNonHydratedInstance","parentContainer","parentType","parentProps","_type","_props","_text","tryHydrate","nextInstance","tryToClaimNextHydratableInstance","firstAttemptedInstance","prepareToHydrateHostInstance","prepareToHydrateHostTextInstance","popToNextHostParent","popHydrationState","resetHydrationState","getCurrentFiberStackAddendum$1","didWarnAboutBadClass","didWarnAboutGetDerivedStateOnFunctionalComponent","didWarnAboutStatelessRefs","reconcileChildren","nextChildren","reconcileChildrenAtExpirationTime","updateForwardRef","currentRef","bailoutOnAlreadyFinishedWork","memoizeProps","updateMode","updateProfiler","markRef","updateFunctionalComponent","updateClassComponent","hasContext","finishClassComponent","didCaptureError","memoizeState","pushHostRootContext","updateHostRoot","prevChildren","nextState","updateHostComponent","isHidden","isDirectTextChild","updateHostText","mountIndeterminateComponent","_Component","warningKey","debugSource","updateTimeoutComponent","prevDidTimeout","alreadyCaptured","nextDidTimeout","updatePortalComponent","propagateContextChange","nextFiber","observedBits","updateContextProvider","providerType","canBailOnProps","newValue","providerPropTypes","oldValue","_calculateChangedBits","updateContextConsumer","unstable_observedBits","bailoutOnLowPriority","beginWork","markUpdate","markRef$1","appendAllChildren","updateHostContainer","updateHostComponent$1","updateHostText$1","currentHostContext","appendAllChildrenToContainer","containerChildSet","portalOrRoot","childrenUnchanged","container","newChildSet","currentInstance","recyclableInstance","newInstance","completeWork","fiberRoot","_currentHostContext","wasHydrated","_instance","_rootContainerInstance","_currentHostContext2","_wasHydrated","showErrorDialog","capturedError","componentStack","errorToHandle","summary","handleException","logCapturedError","logError","suppressLogging","suppressReactErrorLogging","errorBoundaryName","errorBoundaryFound","willRetry","componentNameMessage","errorBoundaryMessage","combinedMessage","invokeGuardedCallback$3","hasCaughtError$1","clearCaughtError$1","didWarnAboutUndefinedSnapshotBeforeUpdate","boundary","errorInfo","errorBoundary","callComponentWillUnmountWithTimer","componentWillUnmount","safelyCallComponentWillUnmount","unmountError","captureCommitPhaseError","safelyDetachRef","refError","commitBeforeMutationLifeCycles","snapshot","didWarnSet","__reactInternalSnapshotBeforeUpdate","commitLifeCycles","finishedRoot","committedExpirationTime","_updateQueue","_instance2","commitAttachRef","instanceToUse","commitDetachRef","commitUnmount","unmountHostComponents","emptyPortalContainer","commitNestedUnmounts","detachFiber","emptyChildSet","commitContainer","_pendingChildren","getHostParentFiber","isHostParent","getHostSibling","siblings","commitPlacement","parentFiber","isContainer","before","currentParentIsValid","currentParentIsContainer","findParent","commitDeletion","commitWork","commitResetTextContent","createRootErrorUpdate","onUncaughtError","createClassErrorUpdate","componentDidCatch","markLegacyErrorBoundaryAsFailed","schedulePing","recoveryUpdate","throwException","sourceFiber","currentTimeMs","then","thenable","expirationTimeMs","startTimeMs","elapsedMs","remainingTimeMs","_workInProgress","earliestTimeoutMs","searchForEarliestTimeout","timeoutPropMs","msUntilTimeout","markTimeout","onResolveOrReject","retrySuspendedRoot","_onResolveOrReject","bind","markError","_errorInfo","isAlreadyFailedLegacyErrorBoundary","_update","unwindWork","_effectTag","_effectTag2","unwindInterruptedWork","interruptedWork","invokeGuardedCallback$2","didWarnAboutStateTransition","didWarnSetStateChildContext","warnAboutUpdateOnUnmounted","warnAboutInvalidUpdates","didWarnStateUpdateForUnmountedComponent","originalStartTimeMs","mostRecentCurrentTime","mostRecentCurrentTimeMs","lastUniqueAsyncExpiration","expirationContext","isWorking","nextRoot","nextRenderExpirationTime","nextLatestTimeoutMs","nextRenderDidError","isCommitting$1","legacyErrorBoundariesThatAlreadyFailed","stashedWorkInProgressProperties","replayUnitOfWork","isReplayingFailedUnitOfWork","originalReplayError","rethrowOriginalError","failedUnitOfWork","thrownValue","isYieldy","workLoop","resetStack","commitAllHostEffects","primaryEffectTag","_current","_current2","commitBeforeMutationLifecycles","commitAllLifeCycles","commitRoot","_didError","_error","_didError2","_error2","onCommitWork","onCommit","resetExpirationTime","renderTime","completeUnitOfWork","siblingFiber","onCompleteWork","_next","performUnitOfWork","onBeginWork","shouldYield","renderRoot","didFatal","onFatal","rootWorkInProgress","_didCompleteRoot","onComplete","_didCompleteRoot2","suspendedExpirationTime","onSuspend","_didCompleteRoot3","onYield","dispatch","rootFiber","_errorInfo2","_update2","computeAsyncExpiration","expirationMs","computeInteractiveExpiration","computeUniqueAsyncExpiration","isBatchingInteractiveUpdates","lowestPendingInteractiveExpirationTime","timeoutMs","retryTime","requestWork","rootExpirationTime","nestedUpdateCount","NESTED_UPDATE_LIMIT","deferredUpdates","previousExpirationContext","syncUpdates","firstScheduledRoot","lastScheduledRoot","callbackExpirationTime","isRendering","nextFlushedRoot","nextFlushedExpirationTime","deadlineDidExpire","hasUnhandledError","unhandledError","deadline","isBatchingUpdates","isUnbatchingUpdates","completedBatches","timeHeuristicForUnitOfWork","scheduleCallbackWithExpirationTime","currentMs","timeout","performAsyncWork","suspendedRoot","addRootToSchedule","performWorkOnRoot","performSyncWork","remainingExpirationTime","findHighestPriorityRoot","highestPriorityWork","highestPriorityRoot","previousScheduledRoot","previousFlushedRoot","dl","performWork","minExpirationTime","finishRendering","flushRoot","batches","batch","_onComplete","completeRoot","_finishedWork","_expirationTime","_defer","batchedUpdates$1","previousIsBatchingUpdates","unbatchedUpdates","flushSync","interactiveUpdates$1","previousIsBatchingInteractiveUpdates","flushInteractiveUpdates$1","flushControlled","didWarnAboutNestedUpdates","getContextForSubtree","parentComponent","scheduleRootUpdate","updateContainerAtExpirationTime","onMountContainer","onUnmountContainer","onUpdateContainer","findHostInstance$1","hostFiber","createContainer","updateContainer","getPublicRootInstance","containerFiber","findHostInstanceWithNoPortals","injectIntoDevTools","devToolsConfig","findFiberByHostInstance","findHostInstanceByFiber","ReactNativeFiberRenderer","findHostInstance","createPortal","ReactVersion","NativeMethodsMixin","findNodeHandle","maybeInstance","NativeMethodsMixin_DEV","_classCallCheck$1","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","writable","setPrototypeOf","__proto__","ReactNativeComponent","_React$Component","getInspectorDataForViewTag","traverseOwnerTreeUp","hierarchy","unshift","getOwnerHierarchy","lastNonHostInstance","getHostProps","host","getHostNode","hostNode","createHierarchy","fiberHierarchy","getInspectorData","viewTag","closestInstance","selection","componentOrHandle","hostInstance","computeComponentStackForErrorReporting","reactTag","roots","ReactNativeRenderer","NativeComponent","containerTag","unmountComponentAtNode","unmountComponentAtNodeAndRemoveContainer","removeRootView","unstable_batchedUpdates","bundleType","version","rendererPackageName","ReactNativeRenderer$2","default","ReactNativeRenderer$3","reactNativeRenderer","module","exports"],"mappings":"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","file":"ReactNativeRenderer-dev.js","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @noflow\n * @providesModule ReactNativeRenderer-dev\n * @preventMunge\n * @generated\n */\n\n'use strict';\n\nif (__DEV__) {\n  (function() {\n\"use strict\";\n\nrequire(\"InitializeCore\");\nvar invariant = require(\"fbjs/lib/invariant\");\nvar warning = require(\"fbjs/lib/warning\");\nvar ReactNativeViewConfigRegistry = require(\"ReactNativeViewConfigRegistry\");\nvar UIManager = require(\"UIManager\");\nvar RCTEventEmitter = require(\"RCTEventEmitter\");\nvar React = require(\"react\");\nvar emptyObject = require(\"fbjs/lib/emptyObject\");\nvar deepFreezeAndThrowOnMutationInDev = require(\"deepFreezeAndThrowOnMutationInDev\");\nvar deepDiffer = require(\"deepDiffer\");\nvar flattenStyle = require(\"flattenStyle\");\nvar TextInputState = require(\"TextInputState\");\nvar checkPropTypes = require(\"prop-types/checkPropTypes\");\nvar ExceptionsManager = require(\"ExceptionsManager\");\n\nvar invokeGuardedCallback = function(name, func, context, a, b, c, d, e, f) {\n  this._hasCaughtError = false;\n  this._caughtError = null;\n  var funcArgs = Array.prototype.slice.call(arguments, 3);\n  try {\n    func.apply(context, funcArgs);\n  } catch (error) {\n    this._caughtError = error;\n    this._hasCaughtError = true;\n  }\n};\n\n{\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // untintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (\n    typeof window !== \"undefined\" &&\n    typeof window.dispatchEvent === \"function\" &&\n    typeof document !== \"undefined\" &&\n    typeof document.createEvent === \"function\"\n  ) {\n    var fakeNode = document.createElement(\"react\");\n\n    var invokeGuardedCallbackDev = function(\n      name,\n      func,\n      context,\n      a,\n      b,\n      c,\n      d,\n      e,\n      f\n    ) {\n      // If document doesn't exist we know for sure we will crash in this method\n      // when we call document.createEvent(). However this can cause confusing\n      // errors: https://github.com/facebookincubator/create-react-app/issues/3482\n      // So we preemptively throw with a better message instead.\n      invariant(\n        typeof document !== \"undefined\",\n        \"The `document` global was defined when React was initialized, but is not \" +\n          \"defined anymore. This can happen in a test environment if a component \" +\n          \"schedules an update from an asynchronous callback, but the test has already \" +\n          \"finished running. To solve this, you can either unmount the component at \" +\n          \"the end of your test (and ensure that any asynchronous operations get \" +\n          \"canceled in `componentWillUnmount`), or you can change the test itself \" +\n          \"to be asynchronous.\"\n      );\n      var evt = document.createEvent(\"Event\");\n\n      // Keeps track of whether the user-provided callback threw an error. We\n      // set this to true at the beginning, then set it to false right after\n      // calling the function. If the function errors, `didError` will never be\n      // set to false. This strategy works even if the browser is flaky and\n      // fails to call our global error handler, because it doesn't rely on\n      // the error event at all.\n      var didError = true;\n\n      // Create an event handler for our fake event. We will synchronously\n      // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n      // call the user-provided callback.\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n      function callCallback() {\n        // We immediately remove the callback from event listeners so that\n        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n        // nested call would trigger the fake event handlers of any call higher\n        // in the stack.\n        fakeNode.removeEventListener(evtType, callCallback, false);\n        func.apply(context, funcArgs);\n        didError = false;\n      }\n\n      // Create a global error event handler. We use this to capture the value\n      // that was thrown. It's possible that this error handler will fire more\n      // than once; for example, if non-React code also calls `dispatchEvent`\n      // and a handler for that event throws. We should be resilient to most of\n      // those cases. Even if our error event handler fires more than once, the\n      // last error event is always used. If the callback actually does error,\n      // we know that the last error event is the correct one, because it's not\n      // possible for anything else to have happened in between our callback\n      // erroring and the code that follows the `dispatchEvent` call below. If\n      // the callback doesn't error, but the error event was fired, we know to\n      // ignore it because `didError` will be false, as described above.\n      var error = void 0;\n      // Use this to track whether the error event is ever called.\n      var didSetError = false;\n      var isCrossOriginError = false;\n\n      function onError(event) {\n        error = event.error;\n        didSetError = true;\n        if (error === null && event.colno === 0 && event.lineno === 0) {\n          isCrossOriginError = true;\n        }\n      }\n\n      // Create a fake event type.\n      var evtType = \"react-\" + (name ? name : \"invokeguardedcallback\");\n\n      // Attach our event handlers\n      window.addEventListener(\"error\", onError);\n      fakeNode.addEventListener(evtType, callCallback, false);\n\n      // Synchronously dispatch our fake event. If the user-provided function\n      // errors, it will trigger our global error handler.\n      evt.initEvent(evtType, false, false);\n      fakeNode.dispatchEvent(evt);\n\n      if (didError) {\n        if (!didSetError) {\n          // The callback errored, but the error event never fired.\n          error = new Error(\n            \"An error was thrown inside one of your components, but React \" +\n              \"doesn't know what it was. This is likely due to browser \" +\n              'flakiness. React does its best to preserve the \"Pause on ' +\n              'exceptions\" behavior of the DevTools, which requires some ' +\n              \"DEV-mode only tricks. It's possible that these don't work in \" +\n              \"your browser. Try triggering the error in production mode, \" +\n              \"or switching to a modern browser. If you suspect that this is \" +\n              \"actually an issue with React, please file an issue.\"\n          );\n        } else if (isCrossOriginError) {\n          error = new Error(\n            \"A cross-origin error was thrown. React doesn't have access to \" +\n              \"the actual error object in development. \" +\n              \"See https://fb.me/react-crossorigin-error for more information.\"\n          );\n        }\n        this._hasCaughtError = true;\n        this._caughtError = error;\n      } else {\n        this._hasCaughtError = false;\n        this._caughtError = null;\n      }\n\n      // Remove our event listeners\n      window.removeEventListener(\"error\", onError);\n    };\n\n    invokeGuardedCallback = invokeGuardedCallbackDev;\n  }\n}\n\nvar invokeGuardedCallback$1 = invokeGuardedCallback;\n\nvar ReactErrorUtils = {\n  // Used by Fiber to simulate a try-catch.\n  _caughtError: null,\n  _hasCaughtError: false,\n\n  // Used by event system to capture/rethrow the first error.\n  _rethrowError: null,\n  _hasRethrowError: false,\n\n  /**\n   * Call a function while guarding against errors that happens within it.\n   * Returns an error if it throws, otherwise null.\n   *\n   * In production, this is implemented using a try-catch. The reason we don't\n   * use a try-catch directly is so that we can swap out a different\n   * implementation in DEV mode.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallback: function(name, func, context, a, b, c, d, e, f) {\n    invokeGuardedCallback$1.apply(ReactErrorUtils, arguments);\n  },\n\n  /**\n   * Same as invokeGuardedCallback, but instead of returning an error, it stores\n   * it in a global so it can be rethrown by `rethrowCaughtError` later.\n   * TODO: See if _caughtError and _rethrowError can be unified.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallbackAndCatchFirstError: function(\n    name,\n    func,\n    context,\n    a,\n    b,\n    c,\n    d,\n    e,\n    f\n  ) {\n    ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);\n    if (ReactErrorUtils.hasCaughtError()) {\n      var error = ReactErrorUtils.clearCaughtError();\n      if (!ReactErrorUtils._hasRethrowError) {\n        ReactErrorUtils._hasRethrowError = true;\n        ReactErrorUtils._rethrowError = error;\n      }\n    }\n  },\n\n  /**\n   * During execution of guarded functions we will capture the first error which\n   * we will rethrow to be handled by the top level error handler.\n   */\n  rethrowCaughtError: function() {\n    return rethrowCaughtError.apply(ReactErrorUtils, arguments);\n  },\n\n  hasCaughtError: function() {\n    return ReactErrorUtils._hasCaughtError;\n  },\n\n  clearCaughtError: function() {\n    if (ReactErrorUtils._hasCaughtError) {\n      var error = ReactErrorUtils._caughtError;\n      ReactErrorUtils._caughtError = null;\n      ReactErrorUtils._hasCaughtError = false;\n      return error;\n    } else {\n      invariant(\n        false,\n        \"clearCaughtError was called but no error was captured. This error \" +\n          \"is likely caused by a bug in React. Please file an issue.\"\n      );\n    }\n  }\n};\n\nvar rethrowCaughtError = function() {\n  if (ReactErrorUtils._hasRethrowError) {\n    var error = ReactErrorUtils._rethrowError;\n    ReactErrorUtils._rethrowError = null;\n    ReactErrorUtils._hasRethrowError = false;\n    throw error;\n  }\n};\n\n/**\n * Injectable ordering of event plugins.\n */\nvar eventPluginOrder = null;\n\n/**\n * Injectable mapping from names to event plugin modules.\n */\nvar namesToPlugins = {};\n\n/**\n * Recomputes the plugin list using the injected plugins and plugin ordering.\n *\n * @private\n */\nfunction recomputePluginOrdering() {\n  if (!eventPluginOrder) {\n    // Wait until an `eventPluginOrder` is injected.\n    return;\n  }\n  for (var pluginName in namesToPlugins) {\n    var pluginModule = namesToPlugins[pluginName];\n    var pluginIndex = eventPluginOrder.indexOf(pluginName);\n    invariant(\n      pluginIndex > -1,\n      \"EventPluginRegistry: Cannot inject event plugins that do not exist in \" +\n        \"the plugin ordering, `%s`.\",\n      pluginName\n    );\n    if (plugins[pluginIndex]) {\n      continue;\n    }\n    invariant(\n      pluginModule.extractEvents,\n      \"EventPluginRegistry: Event plugins must implement an `extractEvents` \" +\n        \"method, but `%s` does not.\",\n      pluginName\n    );\n    plugins[pluginIndex] = pluginModule;\n    var publishedEvents = pluginModule.eventTypes;\n    for (var eventName in publishedEvents) {\n      invariant(\n        publishEventForPlugin(\n          publishedEvents[eventName],\n          pluginModule,\n          eventName\n        ),\n        \"EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.\",\n        eventName,\n        pluginName\n      );\n    }\n  }\n}\n\n/**\n * Publishes an event so that it can be dispatched by the supplied plugin.\n *\n * @param {object} dispatchConfig Dispatch configuration for the event.\n * @param {object} PluginModule Plugin publishing the event.\n * @return {boolean} True if the event was successfully published.\n * @private\n */\nfunction publishEventForPlugin(dispatchConfig, pluginModule, eventName) {\n  invariant(\n    !eventNameDispatchConfigs.hasOwnProperty(eventName),\n    \"EventPluginHub: More than one plugin attempted to publish the same \" +\n      \"event name, `%s`.\",\n    eventName\n  );\n  eventNameDispatchConfigs[eventName] = dispatchConfig;\n\n  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n  if (phasedRegistrationNames) {\n    for (var phaseName in phasedRegistrationNames) {\n      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n        var phasedRegistrationName = phasedRegistrationNames[phaseName];\n        publishRegistrationName(\n          phasedRegistrationName,\n          pluginModule,\n          eventName\n        );\n      }\n    }\n    return true;\n  } else if (dispatchConfig.registrationName) {\n    publishRegistrationName(\n      dispatchConfig.registrationName,\n      pluginModule,\n      eventName\n    );\n    return true;\n  }\n  return false;\n}\n\n/**\n * Publishes a registration name that is used to identify dispatched events.\n *\n * @param {string} registrationName Registration name to add.\n * @param {object} PluginModule Plugin publishing the event.\n * @private\n */\nfunction publishRegistrationName(registrationName, pluginModule, eventName) {\n  invariant(\n    !registrationNameModules[registrationName],\n    \"EventPluginHub: More than one plugin attempted to publish the same \" +\n      \"registration name, `%s`.\",\n    registrationName\n  );\n  registrationNameModules[registrationName] = pluginModule;\n  registrationNameDependencies[registrationName] =\n    pluginModule.eventTypes[eventName].dependencies;\n\n  {\n    var lowerCasedName = registrationName.toLowerCase();\n  }\n}\n\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\n\n/**\n * Ordered list of injected plugins.\n */\nvar plugins = [];\n\n/**\n * Mapping from event name to dispatch config\n */\nvar eventNameDispatchConfigs = {};\n\n/**\n * Mapping from registration name to plugin module\n */\nvar registrationNameModules = {};\n\n/**\n * Mapping from registration name to event name\n */\nvar registrationNameDependencies = {};\n\n/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in true.\n * @type {Object}\n */\n\n// Trust the developer to only use possibleRegistrationNames in true\n\n/**\n * Injects an ordering of plugins (by plugin name). This allows the ordering\n * to be decoupled from injection of the actual plugins so that ordering is\n * always deterministic regardless of packaging, on-the-fly injection, etc.\n *\n * @param {array} InjectedEventPluginOrder\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginOrder}\n */\nfunction injectEventPluginOrder(injectedEventPluginOrder) {\n  invariant(\n    !eventPluginOrder,\n    \"EventPluginRegistry: Cannot inject event plugin ordering more than \" +\n      \"once. You are likely trying to load more than one copy of React.\"\n  );\n  // Clone the ordering so it cannot be dynamically mutated.\n  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);\n  recomputePluginOrdering();\n}\n\n/**\n * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n * in the ordering injected by `injectEventPluginOrder`.\n *\n * Plugins can be injected as part of page initialization or on-the-fly.\n *\n * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginsByName}\n */\nfunction injectEventPluginsByName(injectedNamesToPlugins) {\n  var isOrderingDirty = false;\n  for (var pluginName in injectedNamesToPlugins) {\n    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n      continue;\n    }\n    var pluginModule = injectedNamesToPlugins[pluginName];\n    if (\n      !namesToPlugins.hasOwnProperty(pluginName) ||\n      namesToPlugins[pluginName] !== pluginModule\n    ) {\n      invariant(\n        !namesToPlugins[pluginName],\n        \"EventPluginRegistry: Cannot inject two different event plugins \" +\n          \"using the same name, `%s`.\",\n        pluginName\n      );\n      namesToPlugins[pluginName] = pluginModule;\n      isOrderingDirty = true;\n    }\n  }\n  if (isOrderingDirty) {\n    recomputePluginOrdering();\n  }\n}\n\nvar getFiberCurrentPropsFromNode = null;\nvar getInstanceFromNode = null;\nvar getNodeFromInstance = null;\n\nvar injection$1 = {\n  injectComponentTree: function(Injected) {\n    getFiberCurrentPropsFromNode = Injected.getFiberCurrentPropsFromNode;\n    getInstanceFromNode = Injected.getInstanceFromNode;\n    getNodeFromInstance = Injected.getNodeFromInstance;\n\n    {\n      !(getNodeFromInstance && getInstanceFromNode)\n        ? warning(\n            false,\n            \"EventPluginUtils.injection.injectComponentTree(...): Injected \" +\n              \"module is missing getNodeFromInstance or getInstanceFromNode.\"\n          )\n        : void 0;\n    }\n  }\n};\n\nvar validateEventDispatches = void 0;\n{\n  validateEventDispatches = function(event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchInstances = event._dispatchInstances;\n\n    var listenersIsArr = Array.isArray(dispatchListeners);\n    var listenersLen = listenersIsArr\n      ? dispatchListeners.length\n      : dispatchListeners ? 1 : 0;\n\n    var instancesIsArr = Array.isArray(dispatchInstances);\n    var instancesLen = instancesIsArr\n      ? dispatchInstances.length\n      : dispatchInstances ? 1 : 0;\n\n    !(instancesIsArr === listenersIsArr && instancesLen === listenersLen)\n      ? warning(false, \"EventPluginUtils: Invalid `event`.\")\n      : void 0;\n  };\n}\n\n/**\n * Dispatch the event to the listener.\n * @param {SyntheticEvent} event SyntheticEvent to handle\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @param {function} listener Application-level callback\n * @param {*} inst Internal component instance\n */\nfunction executeDispatch(event, simulated, listener, inst) {\n  var type = event.type || \"unknown-event\";\n  event.currentTarget = getNodeFromInstance(inst);\n  ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(\n    type,\n    listener,\n    undefined,\n    event\n  );\n  event.currentTarget = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches.\n */\nfunction executeDispatchesInOrder(event, simulated) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n  {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      executeDispatch(\n        event,\n        simulated,\n        dispatchListeners[i],\n        dispatchInstances[i]\n      );\n    }\n  } else if (dispatchListeners) {\n    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);\n  }\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches, but stops\n * at the first dispatch execution returning true, and returns that id.\n *\n * @return {?string} id of the first dispatch execution who's listener returns\n * true, or null if no listener returned true.\n */\nfunction executeDispatchesInOrderStopAtTrueImpl(event) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n  {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      if (dispatchListeners[i](event, dispatchInstances[i])) {\n        return dispatchInstances[i];\n      }\n    }\n  } else if (dispatchListeners) {\n    if (dispatchListeners(event, dispatchInstances)) {\n      return dispatchInstances;\n    }\n  }\n  return null;\n}\n\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\nfunction executeDispatchesInOrderStopAtTrue(event) {\n  var ret = executeDispatchesInOrderStopAtTrueImpl(event);\n  event._dispatchInstances = null;\n  event._dispatchListeners = null;\n  return ret;\n}\n\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return {*} The return value of executing the single dispatch.\n */\nfunction executeDirectDispatch(event) {\n  {\n    validateEventDispatches(event);\n  }\n  var dispatchListener = event._dispatchListeners;\n  var dispatchInstance = event._dispatchInstances;\n  invariant(\n    !Array.isArray(dispatchListener),\n    \"executeDirectDispatch(...): Invalid `event`.\"\n  );\n  event.currentTarget = dispatchListener\n    ? getNodeFromInstance(dispatchInstance)\n    : null;\n  var res = dispatchListener ? dispatchListener(event) : null;\n  event.currentTarget = null;\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n  return res;\n}\n\n/**\n * @param {SyntheticEvent} event\n * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n */\nfunction hasDispatches(event) {\n  return !!event._dispatchListeners;\n}\n\n/**\n * Accumulates items that must not be null or undefined into the first one. This\n * is used to conserve memory by avoiding array allocations, and thus sacrifices\n * API cleanness. Since `current` can be null before being passed in and not\n * null after this function, make sure to assign it back to `current`:\n *\n * `a = accumulateInto(a, b);`\n *\n * This API should be sparingly used. Try `accumulate` for something cleaner.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulateInto(current, next) {\n  invariant(\n    next != null,\n    \"accumulateInto(...): Accumulated items must not be null or undefined.\"\n  );\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    if (Array.isArray(next)) {\n      current.push.apply(current, next);\n      return current;\n    }\n    current.push(next);\n    return current;\n  }\n\n  if (Array.isArray(next)) {\n    // A bit too dangerous to mutate `next`.\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * @param {array} arr an \"accumulation\" of items which is either an Array or\n * a single item. Useful when paired with the `accumulate` module. This is a\n * simple utility that allows us to reason about a collection of items, but\n * handling the case when there is exactly one item (and we do not need to\n * allocate an array).\n * @param {function} cb Callback invoked with each element or a collection.\n * @param {?} [scope] Scope used as `this` in a callback.\n */\nfunction forEachAccumulated(arr, cb, scope) {\n  if (Array.isArray(arr)) {\n    arr.forEach(cb, scope);\n  } else if (arr) {\n    cb.call(scope, arr);\n  }\n}\n\n/**\n * Internal queue of events that have accumulated their dispatches and are\n * waiting to have their dispatches executed.\n */\nvar eventQueue = null;\n\n/**\n * Dispatches an event and releases it back into the pool, unless persistent.\n *\n * @param {?object} event Synthetic event to be dispatched.\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @private\n */\nvar executeDispatchesAndRelease = function(event, simulated) {\n  if (event) {\n    executeDispatchesInOrder(event, simulated);\n\n    if (!event.isPersistent()) {\n      event.constructor.release(event);\n    }\n  }\n};\nvar executeDispatchesAndReleaseSimulated = function(e) {\n  return executeDispatchesAndRelease(e, true);\n};\nvar executeDispatchesAndReleaseTopLevel = function(e) {\n  return executeDispatchesAndRelease(e, false);\n};\n\nfunction isInteractive(tag) {\n  return (\n    tag === \"button\" ||\n    tag === \"input\" ||\n    tag === \"select\" ||\n    tag === \"textarea\"\n  );\n}\n\nfunction shouldPreventMouseEvent(name, type, props) {\n  switch (name) {\n    case \"onClick\":\n    case \"onClickCapture\":\n    case \"onDoubleClick\":\n    case \"onDoubleClickCapture\":\n    case \"onMouseDown\":\n    case \"onMouseDownCapture\":\n    case \"onMouseMove\":\n    case \"onMouseMoveCapture\":\n    case \"onMouseUp\":\n    case \"onMouseUpCapture\":\n      return !!(props.disabled && isInteractive(type));\n    default:\n      return false;\n  }\n}\n\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\n\n/**\n * Methods for injecting dependencies.\n */\nvar injection = {\n  /**\n   * @param {array} InjectedEventPluginOrder\n   * @public\n   */\n  injectEventPluginOrder: injectEventPluginOrder,\n\n  /**\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n   */\n  injectEventPluginsByName: injectEventPluginsByName\n};\n\n/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */\nfunction getListener(inst, registrationName) {\n  var listener = void 0;\n\n  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n  // live here; needs to be moved to a better place soon\n  var stateNode = inst.stateNode;\n  if (!stateNode) {\n    // Work in progress (ex: onload events in incremental mode).\n    return null;\n  }\n  var props = getFiberCurrentPropsFromNode(stateNode);\n  if (!props) {\n    // Work in progress.\n    return null;\n  }\n  listener = props[registrationName];\n  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n    return null;\n  }\n  invariant(\n    !listener || typeof listener === \"function\",\n    \"Expected `%s` listener to be a function, instead got a value of `%s` type.\",\n    registrationName,\n    typeof listener\n  );\n  return listener;\n}\n\n/**\n * Allows registered plugins an opportunity to extract events from top-level\n * native browser events.\n *\n * @return {*} An accumulation of synthetic events.\n * @internal\n */\nfunction extractEvents(\n  topLevelType,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  var events = null;\n  for (var i = 0; i < plugins.length; i++) {\n    // Not every plugin in the ordering may be loaded at runtime.\n    var possiblePlugin = plugins[i];\n    if (possiblePlugin) {\n      var extractedEvents = possiblePlugin.extractEvents(\n        topLevelType,\n        targetInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      if (extractedEvents) {\n        events = accumulateInto(events, extractedEvents);\n      }\n    }\n  }\n  return events;\n}\n\nfunction runEventsInBatch(events, simulated) {\n  if (events !== null) {\n    eventQueue = accumulateInto(eventQueue, events);\n  }\n\n  // Set `eventQueue` to null before processing it so that we can tell if more\n  // events get enqueued while processing.\n  var processingEventQueue = eventQueue;\n  eventQueue = null;\n\n  if (!processingEventQueue) {\n    return;\n  }\n\n  if (simulated) {\n    forEachAccumulated(\n      processingEventQueue,\n      executeDispatchesAndReleaseSimulated\n    );\n  } else {\n    forEachAccumulated(\n      processingEventQueue,\n      executeDispatchesAndReleaseTopLevel\n    );\n  }\n  invariant(\n    !eventQueue,\n    \"processEventQueue(): Additional events were enqueued while processing \" +\n      \"an event queue. Support for this has not yet been implemented.\"\n  );\n  // This would be a good time to rethrow if any of the event handlers threw.\n  ReactErrorUtils.rethrowCaughtError();\n}\n\nfunction runExtractedEventsInBatch(\n  topLevelType,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  var events = extractEvents(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget\n  );\n  runEventsInBatch(events, false);\n}\n\nvar IndeterminateComponent = 0; // Before we know whether it is functional or class\nvar FunctionalComponent = 1;\nvar ClassComponent = 2;\nvar HostRoot = 3; // Root of a host tree. Could be nested inside another node.\nvar HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\nvar HostComponent = 5;\nvar HostText = 6;\n\nvar Fragment = 10;\nvar Mode = 11;\nvar ContextConsumer = 12;\nvar ContextProvider = 13;\nvar ForwardRef = 14;\nvar Profiler = 15;\nvar TimeoutComponent = 16;\n\nfunction getParent(inst) {\n  do {\n    inst = inst.return;\n    // TODO: If this is a HostRoot we might want to bail out.\n    // That is depending on if we want nested subtrees (layers) to bubble\n    // events to their parent. We could also go through parentNode on the\n    // host node but that wouldn't work for React Native and doesn't let us\n    // do the portal feature.\n  } while (inst && inst.tag !== HostComponent);\n  if (inst) {\n    return inst;\n  }\n  return null;\n}\n\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\nfunction getLowestCommonAncestor(instA, instB) {\n  var depthA = 0;\n  for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n    depthA++;\n  }\n  var depthB = 0;\n  for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n    depthB++;\n  }\n\n  // If A is deeper, crawl up.\n  while (depthA - depthB > 0) {\n    instA = getParent(instA);\n    depthA--;\n  }\n\n  // If B is deeper, crawl up.\n  while (depthB - depthA > 0) {\n    instB = getParent(instB);\n    depthB--;\n  }\n\n  // Walk in lockstep until we find a match.\n  var depth = depthA;\n  while (depth--) {\n    if (instA === instB || instA === instB.alternate) {\n      return instA;\n    }\n    instA = getParent(instA);\n    instB = getParent(instB);\n  }\n  return null;\n}\n\n/**\n * Return if A is an ancestor of B.\n */\nfunction isAncestor(instA, instB) {\n  while (instB) {\n    if (instA === instB || instA === instB.alternate) {\n      return true;\n    }\n    instB = getParent(instB);\n  }\n  return false;\n}\n\n/**\n * Return the parent instance of the passed-in instance.\n */\nfunction getParentInstance(inst) {\n  return getParent(inst);\n}\n\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\nfunction traverseTwoPhase(inst, fn, arg) {\n  var path = [];\n  while (inst) {\n    path.push(inst);\n    inst = getParent(inst);\n  }\n  var i = void 0;\n  for (i = path.length; i-- > 0; ) {\n    fn(path[i], \"captured\", arg);\n  }\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], \"bubbled\", arg);\n  }\n}\n\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  var registrationName =\n    event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing even a\n * single one.\n */\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  {\n    !inst ? warning(false, \"Dispatching inst must not be null\") : void 0;\n  }\n  var listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(\n      event._dispatchListeners,\n      listener\n    );\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    var targetInst = event._targetInst;\n    var parentInst = targetInst ? getParentInstance(targetInst) : null;\n    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (inst && event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(\n        event._dispatchListeners,\n        listener\n      );\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\n/* eslint valid-typeof: 0 */\n\nvar didWarnForAddedNewProperty = false;\nvar EVENT_POOL_SIZE = 10;\n\nvar shouldBeReleasedProperties = [\n  \"dispatchConfig\",\n  \"_targetInst\",\n  \"nativeEvent\",\n  \"isDefaultPrevented\",\n  \"isPropagationStopped\",\n  \"_dispatchListeners\",\n  \"_dispatchInstances\"\n];\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar EventInterface = {\n  type: null,\n  target: null,\n  // currentTarget is set when dispatching; no use in copying it here\n  currentTarget: function() {\n    return null;\n  },\n  eventPhase: null,\n  bubbles: null,\n  cancelable: null,\n  timeStamp: function(event) {\n    return event.timeStamp || Date.now();\n  },\n  defaultPrevented: null,\n  isTrusted: null\n};\n\nfunction functionThatReturnsTrue() {\n  return true;\n}\n\nfunction functionThatReturnsFalse() {\n  return false;\n}\n\n/**\n * Synthetic events are dispatched by event plugins, typically in response to a\n * top-level event delegation handler.\n *\n * These systems should generally use pooling to reduce the frequency of garbage\n * collection. The system should check `isPersistent` to determine whether the\n * event should be released into the pool after being dispatched. Users that\n * need a persisted event should invoke `persist`.\n *\n * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n * normalizing browser quirks. Subclasses do not necessarily have to implement a\n * DOM interface; custom application-specific events can also subclass this.\n *\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {*} targetInst Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @param {DOMEventTarget} nativeEventTarget Target node.\n */\nfunction SyntheticEvent(\n  dispatchConfig,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  {\n    // these have a getter/setter for warnings\n    delete this.nativeEvent;\n    delete this.preventDefault;\n    delete this.stopPropagation;\n  }\n\n  this.dispatchConfig = dispatchConfig;\n  this._targetInst = targetInst;\n  this.nativeEvent = nativeEvent;\n\n  var Interface = this.constructor.Interface;\n  for (var propName in Interface) {\n    if (!Interface.hasOwnProperty(propName)) {\n      continue;\n    }\n    {\n      delete this[propName]; // this has a getter/setter for warnings\n    }\n    var normalize = Interface[propName];\n    if (normalize) {\n      this[propName] = normalize(nativeEvent);\n    } else {\n      if (propName === \"target\") {\n        this.target = nativeEventTarget;\n      } else {\n        this[propName] = nativeEvent[propName];\n      }\n    }\n  }\n\n  var defaultPrevented =\n    nativeEvent.defaultPrevented != null\n      ? nativeEvent.defaultPrevented\n      : nativeEvent.returnValue === false;\n  if (defaultPrevented) {\n    this.isDefaultPrevented = functionThatReturnsTrue;\n  } else {\n    this.isDefaultPrevented = functionThatReturnsFalse;\n  }\n  this.isPropagationStopped = functionThatReturnsFalse;\n  return this;\n}\n\nObject.assign(SyntheticEvent.prototype, {\n  preventDefault: function() {\n    this.defaultPrevented = true;\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else if (typeof event.returnValue !== \"unknown\") {\n      event.returnValue = false;\n    }\n    this.isDefaultPrevented = functionThatReturnsTrue;\n  },\n\n  stopPropagation: function() {\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else if (typeof event.cancelBubble !== \"unknown\") {\n      // The ChangeEventPlugin registers a \"propertychange\" event for\n      // IE. This event does not support bubbling or cancelling, and\n      // any references to cancelBubble throw \"Member not found\".  A\n      // typeof check of \"unknown\" circumvents this issue (and is also\n      // IE specific).\n      event.cancelBubble = true;\n    }\n\n    this.isPropagationStopped = functionThatReturnsTrue;\n  },\n\n  /**\n   * We release all dispatched `SyntheticEvent`s after each event loop, adding\n   * them back into the pool. This allows a way to hold onto a reference that\n   * won't be added back into the pool.\n   */\n  persist: function() {\n    this.isPersistent = functionThatReturnsTrue;\n  },\n\n  /**\n   * Checks if this event should be released back into the pool.\n   *\n   * @return {boolean} True if this should not be released, false otherwise.\n   */\n  isPersistent: functionThatReturnsFalse,\n\n  /**\n   * `PooledClass` looks for `destructor` on each instance it releases.\n   */\n  destructor: function() {\n    var Interface = this.constructor.Interface;\n    for (var propName in Interface) {\n      {\n        Object.defineProperty(\n          this,\n          propName,\n          getPooledWarningPropertyDefinition(propName, Interface[propName])\n        );\n      }\n    }\n    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {\n      this[shouldBeReleasedProperties[i]] = null;\n    }\n    {\n      Object.defineProperty(\n        this,\n        \"nativeEvent\",\n        getPooledWarningPropertyDefinition(\"nativeEvent\", null)\n      );\n      Object.defineProperty(\n        this,\n        \"preventDefault\",\n        getPooledWarningPropertyDefinition(\"preventDefault\", function() {})\n      );\n      Object.defineProperty(\n        this,\n        \"stopPropagation\",\n        getPooledWarningPropertyDefinition(\"stopPropagation\", function() {})\n      );\n    }\n  }\n});\n\nSyntheticEvent.Interface = EventInterface;\n\n/**\n * Helper to reduce boilerplate when creating subclasses.\n */\nSyntheticEvent.extend = function(Interface) {\n  var Super = this;\n\n  var E = function() {};\n  E.prototype = Super.prototype;\n  var prototype = new E();\n\n  function Class() {\n    return Super.apply(this, arguments);\n  }\n  Object.assign(prototype, Class.prototype);\n  Class.prototype = prototype;\n  Class.prototype.constructor = Class;\n\n  Class.Interface = Object.assign({}, Super.Interface, Interface);\n  Class.extend = Super.extend;\n  addEventPoolingTo(Class);\n\n  return Class;\n};\n\n/** Proxying after everything set on SyntheticEvent\n * to resolve Proxy issue on some WebKit browsers\n * in which some Event properties are set to undefined (GH#10010)\n */\n{\n  var isProxySupported =\n    typeof Proxy === \"function\" &&\n    // https://github.com/facebook/react/issues/12011\n    !Object.isSealed(new Proxy({}, {}));\n\n  if (isProxySupported) {\n    /*eslint-disable no-func-assign */\n    SyntheticEvent = new Proxy(SyntheticEvent, {\n      construct: function(target, args) {\n        return this.apply(target, Object.create(target.prototype), args);\n      },\n      apply: function(constructor, that, args) {\n        return new Proxy(constructor.apply(that, args), {\n          set: function(target, prop, value) {\n            if (\n              prop !== \"isPersistent\" &&\n              !target.constructor.Interface.hasOwnProperty(prop) &&\n              shouldBeReleasedProperties.indexOf(prop) === -1\n            ) {\n              !(didWarnForAddedNewProperty || target.isPersistent())\n                ? warning(\n                    false,\n                    \"This synthetic event is reused for performance reasons. If you're \" +\n                      \"seeing this, you're adding a new property in the synthetic event object. \" +\n                      \"The property is never released. See \" +\n                      \"https://fb.me/react-event-pooling for more information.\"\n                  )\n                : void 0;\n              didWarnForAddedNewProperty = true;\n            }\n            target[prop] = value;\n            return true;\n          }\n        });\n      }\n    });\n    /*eslint-enable no-func-assign */\n  }\n}\n\naddEventPoolingTo(SyntheticEvent);\n\n/**\n * Helper to nullify syntheticEvent instance properties when destructing\n *\n * @param {String} propName\n * @param {?object} getVal\n * @return {object} defineProperty object\n */\nfunction getPooledWarningPropertyDefinition(propName, getVal) {\n  var isFunction = typeof getVal === \"function\";\n  return {\n    configurable: true,\n    set: set,\n    get: get$$1\n  };\n\n  function set(val) {\n    var action = isFunction ? \"setting the method\" : \"setting the property\";\n    warn(action, \"This is effectively a no-op\");\n    return val;\n  }\n\n  function get$$1() {\n    var action = isFunction ? \"accessing the method\" : \"accessing the property\";\n    var result = isFunction\n      ? \"This is a no-op function\"\n      : \"This is set to null\";\n    warn(action, result);\n    return getVal;\n  }\n\n  function warn(action, result) {\n    var warningCondition = false;\n    !warningCondition\n      ? warning(\n          false,\n          \"This synthetic event is reused for performance reasons. If you're seeing this, \" +\n            \"you're %s `%s` on a released/nullified synthetic event. %s. \" +\n            \"If you must keep the original synthetic event around, use event.persist(). \" +\n            \"See https://fb.me/react-event-pooling for more information.\",\n          action,\n          propName,\n          result\n        )\n      : void 0;\n  }\n}\n\nfunction getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n  var EventConstructor = this;\n  if (EventConstructor.eventPool.length) {\n    var instance = EventConstructor.eventPool.pop();\n    EventConstructor.call(\n      instance,\n      dispatchConfig,\n      targetInst,\n      nativeEvent,\n      nativeInst\n    );\n    return instance;\n  }\n  return new EventConstructor(\n    dispatchConfig,\n    targetInst,\n    nativeEvent,\n    nativeInst\n  );\n}\n\nfunction releasePooledEvent(event) {\n  var EventConstructor = this;\n  invariant(\n    event instanceof EventConstructor,\n    \"Trying to release an event instance  into a pool of a different type.\"\n  );\n  event.destructor();\n  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n    EventConstructor.eventPool.push(event);\n  }\n}\n\nfunction addEventPoolingTo(EventConstructor) {\n  EventConstructor.eventPool = [];\n  EventConstructor.getPooled = getPooledEvent;\n  EventConstructor.release = releasePooledEvent;\n}\n\nvar SyntheticEvent$1 = SyntheticEvent;\n\n/**\n * `touchHistory` isn't actually on the native event, but putting it in the\n * interface will ensure that it is cleaned up when pooled/destroyed. The\n * `ResponderEventPlugin` will populate it appropriately.\n */\nvar ResponderSyntheticEvent = SyntheticEvent$1.extend({\n  touchHistory: function(nativeEvent) {\n    return null; // Actually doesn't even look at the native event.\n  }\n});\n\nvar TOP_TOUCH_START = \"topTouchStart\";\nvar TOP_TOUCH_MOVE = \"topTouchMove\";\nvar TOP_TOUCH_END = \"topTouchEnd\";\nvar TOP_TOUCH_CANCEL = \"topTouchCancel\";\nvar TOP_SCROLL = \"topScroll\";\nvar TOP_SELECTION_CHANGE = \"topSelectionChange\";\n\nfunction isStartish(topLevelType) {\n  return topLevelType === TOP_TOUCH_START;\n}\n\nfunction isMoveish(topLevelType) {\n  return topLevelType === TOP_TOUCH_MOVE;\n}\n\nfunction isEndish(topLevelType) {\n  return topLevelType === TOP_TOUCH_END || topLevelType === TOP_TOUCH_CANCEL;\n}\n\nvar startDependencies = [TOP_TOUCH_START];\nvar moveDependencies = [TOP_TOUCH_MOVE];\nvar endDependencies = [TOP_TOUCH_CANCEL, TOP_TOUCH_END];\n\n/**\n * Tracks the position and time of each active touch by `touch.identifier`. We\n * should typically only see IDs in the range of 1-20 because IDs get recycled\n * when touches end and start again.\n */\n\nvar MAX_TOUCH_BANK = 20;\nvar touchBank = [];\nvar touchHistory = {\n  touchBank: touchBank,\n  numberActiveTouches: 0,\n  // If there is only one active touch, we remember its location. This prevents\n  // us having to loop through all of the touches all the time in the most\n  // common case.\n  indexOfSingleActiveTouch: -1,\n  mostRecentTimeStamp: 0\n};\n\nfunction timestampForTouch(touch) {\n  // The legacy internal implementation provides \"timeStamp\", which has been\n  // renamed to \"timestamp\". Let both work for now while we iron it out\n  // TODO (evv): rename timeStamp to timestamp in internal code\n  return touch.timeStamp || touch.timestamp;\n}\n\n/**\n * TODO: Instead of making gestures recompute filtered velocity, we could\n * include a built in velocity computation that can be reused globally.\n */\nfunction createTouchRecord(touch) {\n  return {\n    touchActive: true,\n    startPageX: touch.pageX,\n    startPageY: touch.pageY,\n    startTimeStamp: timestampForTouch(touch),\n    currentPageX: touch.pageX,\n    currentPageY: touch.pageY,\n    currentTimeStamp: timestampForTouch(touch),\n    previousPageX: touch.pageX,\n    previousPageY: touch.pageY,\n    previousTimeStamp: timestampForTouch(touch)\n  };\n}\n\nfunction resetTouchRecord(touchRecord, touch) {\n  touchRecord.touchActive = true;\n  touchRecord.startPageX = touch.pageX;\n  touchRecord.startPageY = touch.pageY;\n  touchRecord.startTimeStamp = timestampForTouch(touch);\n  touchRecord.currentPageX = touch.pageX;\n  touchRecord.currentPageY = touch.pageY;\n  touchRecord.currentTimeStamp = timestampForTouch(touch);\n  touchRecord.previousPageX = touch.pageX;\n  touchRecord.previousPageY = touch.pageY;\n  touchRecord.previousTimeStamp = timestampForTouch(touch);\n}\n\nfunction getTouchIdentifier(_ref) {\n  var identifier = _ref.identifier;\n\n  invariant(identifier != null, \"Touch object is missing identifier.\");\n  {\n    !(identifier <= MAX_TOUCH_BANK)\n      ? warning(\n          false,\n          \"Touch identifier %s is greater than maximum supported %s which causes \" +\n            \"performance issues backfilling array locations for all of the indices.\",\n          identifier,\n          MAX_TOUCH_BANK\n        )\n      : void 0;\n  }\n  return identifier;\n}\n\nfunction recordTouchStart(touch) {\n  var identifier = getTouchIdentifier(touch);\n  var touchRecord = touchBank[identifier];\n  if (touchRecord) {\n    resetTouchRecord(touchRecord, touch);\n  } else {\n    touchBank[identifier] = createTouchRecord(touch);\n  }\n  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n}\n\nfunction recordTouchMove(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = true;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.error(\n      \"Cannot record touch move without a touch start.\\n\" + \"Touch Move: %s\\n\",\n      \"Touch Bank: %s\",\n      printTouch(touch),\n      printTouchBank()\n    );\n  }\n}\n\nfunction recordTouchEnd(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = false;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.error(\n      \"Cannot record touch end without a touch start.\\n\" + \"Touch End: %s\\n\",\n      \"Touch Bank: %s\",\n      printTouch(touch),\n      printTouchBank()\n    );\n  }\n}\n\nfunction printTouch(touch) {\n  return JSON.stringify({\n    identifier: touch.identifier,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    timestamp: timestampForTouch(touch)\n  });\n}\n\nfunction printTouchBank() {\n  var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n  if (touchBank.length > MAX_TOUCH_BANK) {\n    printed += \" (original size: \" + touchBank.length + \")\";\n  }\n  return printed;\n}\n\nvar ResponderTouchHistoryStore = {\n  recordTouchTrack: function(topLevelType, nativeEvent) {\n    if (isMoveish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchMove);\n    } else if (isStartish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchStart);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n      if (touchHistory.numberActiveTouches === 1) {\n        touchHistory.indexOfSingleActiveTouch =\n          nativeEvent.touches[0].identifier;\n      }\n    } else if (isEndish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchEnd);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n      if (touchHistory.numberActiveTouches === 1) {\n        for (var i = 0; i < touchBank.length; i++) {\n          var touchTrackToCheck = touchBank[i];\n          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n            touchHistory.indexOfSingleActiveTouch = i;\n            break;\n          }\n        }\n        {\n          var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n          !(activeRecord != null && activeRecord.touchActive)\n            ? warning(false, \"Cannot find single active touch.\")\n            : void 0;\n        }\n      }\n    }\n  },\n\n  touchHistory: touchHistory\n};\n\n/**\n * Accumulates items that must not be null or undefined.\n *\n * This is used to conserve memory by avoiding array allocations.\n *\n * @return {*|array<*>} An accumulation of items.\n */\nfunction accumulate(current, next) {\n  invariant(\n    next != null,\n    \"accumulate(...): Accumulated items must be not be null or undefined.\"\n  );\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    return current.concat(next);\n  }\n\n  if (Array.isArray(next)) {\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * Instance of element that should respond to touch/move types of interactions,\n * as indicated explicitly by relevant callbacks.\n */\nvar responderInst = null;\n\n/**\n * Count of current touches. A textInput should become responder iff the\n * selection changes while there is a touch on the screen.\n */\nvar trackedTouchCount = 0;\n\nvar changeResponder = function(nextResponderInst, blockHostResponder) {\n  var oldResponderInst = responderInst;\n  responderInst = nextResponderInst;\n  if (ResponderEventPlugin.GlobalResponderHandler !== null) {\n    ResponderEventPlugin.GlobalResponderHandler.onChange(\n      oldResponderInst,\n      nextResponderInst,\n      blockHostResponder\n    );\n  }\n};\n\nvar eventTypes$1 = {\n  /**\n   * On a `touchStart`/`mouseDown`, is it desired that this element become the\n   * responder?\n   */\n  startShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: \"onStartShouldSetResponder\",\n      captured: \"onStartShouldSetResponderCapture\"\n    },\n    dependencies: startDependencies\n  },\n\n  /**\n   * On a `scroll`, is it desired that this element become the responder? This\n   * is usually not needed, but should be used to retroactively infer that a\n   * `touchStart` had occurred during momentum scroll. During a momentum scroll,\n   * a touch start will be immediately followed by a scroll event if the view is\n   * currently scrolling.\n   *\n   * TODO: This shouldn't bubble.\n   */\n  scrollShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: \"onScrollShouldSetResponder\",\n      captured: \"onScrollShouldSetResponderCapture\"\n    },\n    dependencies: [TOP_SCROLL]\n  },\n\n  /**\n   * On text selection change, should this element become the responder? This\n   * is needed for text inputs or other views with native selection, so the\n   * JS view can claim the responder.\n   *\n   * TODO: This shouldn't bubble.\n   */\n  selectionChangeShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: \"onSelectionChangeShouldSetResponder\",\n      captured: \"onSelectionChangeShouldSetResponderCapture\"\n    },\n    dependencies: [TOP_SELECTION_CHANGE]\n  },\n\n  /**\n   * On a `touchMove`/`mouseMove`, is it desired that this element become the\n   * responder?\n   */\n  moveShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: \"onMoveShouldSetResponder\",\n      captured: \"onMoveShouldSetResponderCapture\"\n    },\n    dependencies: moveDependencies\n  },\n\n  /**\n   * Direct responder events dispatched directly to responder. Do not bubble.\n   */\n  responderStart: {\n    registrationName: \"onResponderStart\",\n    dependencies: startDependencies\n  },\n  responderMove: {\n    registrationName: \"onResponderMove\",\n    dependencies: moveDependencies\n  },\n  responderEnd: {\n    registrationName: \"onResponderEnd\",\n    dependencies: endDependencies\n  },\n  responderRelease: {\n    registrationName: \"onResponderRelease\",\n    dependencies: endDependencies\n  },\n  responderTerminationRequest: {\n    registrationName: \"onResponderTerminationRequest\",\n    dependencies: []\n  },\n  responderGrant: {\n    registrationName: \"onResponderGrant\",\n    dependencies: []\n  },\n  responderReject: {\n    registrationName: \"onResponderReject\",\n    dependencies: []\n  },\n  responderTerminate: {\n    registrationName: \"onResponderTerminate\",\n    dependencies: []\n  }\n};\n\n/**\n *\n * Responder System:\n * ----------------\n *\n * - A global, solitary \"interaction lock\" on a view.\n * - If a node becomes the responder, it should convey visual feedback\n *   immediately to indicate so, either by highlighting or moving accordingly.\n * - To be the responder means, that touches are exclusively important to that\n *   responder view, and no other view.\n * - While touches are still occurring, the responder lock can be transferred to\n *   a new view, but only to increasingly \"higher\" views (meaning ancestors of\n *   the current responder).\n *\n * Responder being granted:\n * ------------------------\n *\n * - Touch starts, moves, and scrolls can cause an ID to become the responder.\n * - We capture/bubble `startShouldSetResponder`/`moveShouldSetResponder` to\n *   the \"appropriate place\".\n * - If nothing is currently the responder, the \"appropriate place\" is the\n *   initiating event's `targetID`.\n * - If something *is* already the responder, the \"appropriate place\" is the\n *   first common ancestor of the event target and the current `responderInst`.\n * - Some negotiation happens: See the timing diagram below.\n * - Scrolled views automatically become responder. The reasoning is that a\n *   platform scroll view that isn't built on top of the responder system has\n *   began scrolling, and the active responder must now be notified that the\n *   interaction is no longer locked to it - the system has taken over.\n *\n * - Responder being released:\n *   As soon as no more touches that *started* inside of descendants of the\n *   *current* responderInst, an `onResponderRelease` event is dispatched to the\n *   current responder, and the responder lock is released.\n *\n * TODO:\n * - on \"end\", a callback hook for `onResponderEndShouldRemainResponder` that\n *   determines if the responder lock should remain.\n * - If a view shouldn't \"remain\" the responder, any active touches should by\n *   default be considered \"dead\" and do not influence future negotiations or\n *   bubble paths. It should be as if those touches do not exist.\n * -- For multitouch: Usually a translate-z will choose to \"remain\" responder\n *  after one out of many touches ended. For translate-y, usually the view\n *  doesn't wish to \"remain\" responder after one of many touches end.\n * - Consider building this on top of a `stopPropagation` model similar to\n *   `W3C` events.\n * - Ensure that `onResponderTerminate` is called on touch cancels, whether or\n *   not `onResponderTerminationRequest` returns `true` or `false`.\n *\n */\n\n/*                                             Negotiation Performed\n                                             +-----------------------+\n                                            /                         \\\nProcess low level events to    +     Current Responder      +   wantsResponderID\ndetermine who to perform negot-|   (if any exists at all)   |\niation/transition              | Otherwise just pass through|\n-------------------------------+----------------------------+------------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchStart|           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onStartShouldSetResponder|----->|onResponderStart (cur)  |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderStart|\n                               |                            | +----------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchMove |           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onMoveShouldSetResponder |----->|onResponderMove (cur)   |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderRejec|\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderMove |\n                               |                            | +----------------+\n                               |                            |\n                               |                            |\n      Some active touch started|                            |\n      inside current responder | +------------------------+ |\n      +------------------------->|      onResponderEnd    | |\n      |                        | +------------------------+ |\n  +---+---------+              |                            |\n  | onTouchEnd  |              |                            |\n  +---+---------+              |                            |\n      |                        | +------------------------+ |\n      +------------------------->|     onResponderEnd     | |\n      No active touches started| +-----------+------------+ |\n      inside current responder |             |              |\n                               |             v              |\n                               | +------------------------+ |\n                               | |    onResponderRelease  | |\n                               | +------------------------+ |\n                               |                            |\n                               +                            + */\n\n/**\n * A note about event ordering in the `EventPluginHub`.\n *\n * Suppose plugins are injected in the following order:\n *\n * `[R, S, C]`\n *\n * To help illustrate the example, assume `S` is `SimpleEventPlugin` (for\n * `onClick` etc) and `R` is `ResponderEventPlugin`.\n *\n * \"Deferred-Dispatched Events\":\n *\n * - The current event plugin system will traverse the list of injected plugins,\n *   in order, and extract events by collecting the plugin's return value of\n *   `extractEvents()`.\n * - These events that are returned from `extractEvents` are \"deferred\n *   dispatched events\".\n * - When returned from `extractEvents`, deferred-dispatched events contain an\n *   \"accumulation\" of deferred dispatches.\n * - These deferred dispatches are accumulated/collected before they are\n *   returned, but processed at a later time by the `EventPluginHub` (hence the\n *   name deferred).\n *\n * In the process of returning their deferred-dispatched events, event plugins\n * themselves can dispatch events on-demand without returning them from\n * `extractEvents`. Plugins might want to do this, so that they can use event\n * dispatching as a tool that helps them decide which events should be extracted\n * in the first place.\n *\n * \"On-Demand-Dispatched Events\":\n *\n * - On-demand-dispatched events are not returned from `extractEvents`.\n * - On-demand-dispatched events are dispatched during the process of returning\n *   the deferred-dispatched events.\n * - They should not have side effects.\n * - They should be avoided, and/or eventually be replaced with another\n *   abstraction that allows event plugins to perform multiple \"rounds\" of event\n *   extraction.\n *\n * Therefore, the sequence of event dispatches becomes:\n *\n * - `R`s on-demand events (if any)   (dispatched by `R` on-demand)\n * - `S`s on-demand events (if any)   (dispatched by `S` on-demand)\n * - `C`s on-demand events (if any)   (dispatched by `C` on-demand)\n * - `R`s extracted events (if any)   (dispatched by `EventPluginHub`)\n * - `S`s extracted events (if any)   (dispatched by `EventPluginHub`)\n * - `C`s extracted events (if any)   (dispatched by `EventPluginHub`)\n *\n * In the case of `ResponderEventPlugin`: If the `startShouldSetResponder`\n * on-demand dispatch returns `true` (and some other details are satisfied) the\n * `onResponderGrant` deferred dispatched event is returned from\n * `extractEvents`. The sequence of dispatch executions in this case\n * will appear as follows:\n *\n * - `startShouldSetResponder` (`ResponderEventPlugin` dispatches on-demand)\n * - `touchStartCapture`       (`EventPluginHub` dispatches as usual)\n * - `touchStart`              (`EventPluginHub` dispatches as usual)\n * - `responderGrant/Reject`   (`EventPluginHub` dispatches as usual)\n */\n\nfunction setResponderAndExtractTransfer(\n  topLevelType,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  var shouldSetEventType = isStartish(topLevelType)\n    ? eventTypes$1.startShouldSetResponder\n    : isMoveish(topLevelType)\n      ? eventTypes$1.moveShouldSetResponder\n      : topLevelType === TOP_SELECTION_CHANGE\n        ? eventTypes$1.selectionChangeShouldSetResponder\n        : eventTypes$1.scrollShouldSetResponder;\n\n  // TODO: stop one short of the current responder.\n  var bubbleShouldSetFrom = !responderInst\n    ? targetInst\n    : getLowestCommonAncestor(responderInst, targetInst);\n\n  // When capturing/bubbling the \"shouldSet\" event, we want to skip the target\n  // (deepest ID) if it happens to be the current responder. The reasoning:\n  // It's strange to get an `onMoveShouldSetResponder` when you're *already*\n  // the responder.\n  var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;\n  var shouldSetEvent = ResponderSyntheticEvent.getPooled(\n    shouldSetEventType,\n    bubbleShouldSetFrom,\n    nativeEvent,\n    nativeEventTarget\n  );\n  shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n  if (skipOverBubbleShouldSetFrom) {\n    accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);\n  } else {\n    accumulateTwoPhaseDispatches(shouldSetEvent);\n  }\n  var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);\n  if (!shouldSetEvent.isPersistent()) {\n    shouldSetEvent.constructor.release(shouldSetEvent);\n  }\n\n  if (!wantsResponderInst || wantsResponderInst === responderInst) {\n    return null;\n  }\n  var extracted = void 0;\n  var grantEvent = ResponderSyntheticEvent.getPooled(\n    eventTypes$1.responderGrant,\n    wantsResponderInst,\n    nativeEvent,\n    nativeEventTarget\n  );\n  grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n\n  accumulateDirectDispatches(grantEvent);\n  var blockHostResponder = executeDirectDispatch(grantEvent) === true;\n  if (responderInst) {\n    var terminationRequestEvent = ResponderSyntheticEvent.getPooled(\n      eventTypes$1.responderTerminationRequest,\n      responderInst,\n      nativeEvent,\n      nativeEventTarget\n    );\n    terminationRequestEvent.touchHistory =\n      ResponderTouchHistoryStore.touchHistory;\n    accumulateDirectDispatches(terminationRequestEvent);\n    var shouldSwitch =\n      !hasDispatches(terminationRequestEvent) ||\n      executeDirectDispatch(terminationRequestEvent);\n    if (!terminationRequestEvent.isPersistent()) {\n      terminationRequestEvent.constructor.release(terminationRequestEvent);\n    }\n\n    if (shouldSwitch) {\n      var terminateEvent = ResponderSyntheticEvent.getPooled(\n        eventTypes$1.responderTerminate,\n        responderInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(terminateEvent);\n      extracted = accumulate(extracted, [grantEvent, terminateEvent]);\n      changeResponder(wantsResponderInst, blockHostResponder);\n    } else {\n      var rejectEvent = ResponderSyntheticEvent.getPooled(\n        eventTypes$1.responderReject,\n        wantsResponderInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(rejectEvent);\n      extracted = accumulate(extracted, rejectEvent);\n    }\n  } else {\n    extracted = accumulate(extracted, grantEvent);\n    changeResponder(wantsResponderInst, blockHostResponder);\n  }\n  return extracted;\n}\n\n/**\n * A transfer is a negotiation between a currently set responder and the next\n * element to claim responder status. Any start event could trigger a transfer\n * of responderInst. Any move event could trigger a transfer.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @return {boolean} True if a transfer of responder could possibly occur.\n */\nfunction canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {\n  return (\n    topLevelInst &&\n    // responderIgnoreScroll: We are trying to migrate away from specifically\n    // tracking native scroll events here and responderIgnoreScroll indicates we\n    // will send topTouchCancel to handle canceling touch events instead\n    ((topLevelType === TOP_SCROLL && !nativeEvent.responderIgnoreScroll) ||\n      (trackedTouchCount > 0 && topLevelType === TOP_SELECTION_CHANGE) ||\n      isStartish(topLevelType) ||\n      isMoveish(topLevelType))\n  );\n}\n\n/**\n * Returns whether or not this touch end event makes it such that there are no\n * longer any touches that started inside of the current `responderInst`.\n *\n * @param {NativeEvent} nativeEvent Native touch end event.\n * @return {boolean} Whether or not this touch end event ends the responder.\n */\nfunction noResponderTouches(nativeEvent) {\n  var touches = nativeEvent.touches;\n  if (!touches || touches.length === 0) {\n    return true;\n  }\n  for (var i = 0; i < touches.length; i++) {\n    var activeTouch = touches[i];\n    var target = activeTouch.target;\n    if (target !== null && target !== undefined && target !== 0) {\n      // Is the original touch location inside of the current responder?\n      var targetInst = getInstanceFromNode(target);\n      if (isAncestor(responderInst, targetInst)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nvar ResponderEventPlugin = {\n  /* For unit testing only */\n  _getResponder: function() {\n    return responderInst;\n  },\n\n  eventTypes: eventTypes$1,\n\n  /**\n   * We must be resilient to `targetInst` being `null` on `touchMove` or\n   * `touchEnd`. On certain platforms, this means that a native scroll has\n   * assumed control and the original touch targets are destroyed.\n   */\n  extractEvents: function(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget\n  ) {\n    if (isStartish(topLevelType)) {\n      trackedTouchCount += 1;\n    } else if (isEndish(topLevelType)) {\n      if (trackedTouchCount >= 0) {\n        trackedTouchCount -= 1;\n      } else {\n        console.error(\n          \"Ended a touch event which was not counted in `trackedTouchCount`.\"\n        );\n        return null;\n      }\n    }\n\n    ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);\n\n    var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent)\n      ? setResponderAndExtractTransfer(\n          topLevelType,\n          targetInst,\n          nativeEvent,\n          nativeEventTarget\n        )\n      : null;\n    // Responder may or may not have transferred on a new touch start/move.\n    // Regardless, whoever is the responder after any potential transfer, we\n    // direct all touch start/move/ends to them in the form of\n    // `onResponderMove/Start/End`. These will be called for *every* additional\n    // finger that move/start/end, dispatched directly to whoever is the\n    // current responder at that moment, until the responder is \"released\".\n    //\n    // These multiple individual change touch events are are always bookended\n    // by `onResponderGrant`, and one of\n    // (`onResponderRelease/onResponderTerminate`).\n    var isResponderTouchStart = responderInst && isStartish(topLevelType);\n    var isResponderTouchMove = responderInst && isMoveish(topLevelType);\n    var isResponderTouchEnd = responderInst && isEndish(topLevelType);\n    var incrementalTouch = isResponderTouchStart\n      ? eventTypes$1.responderStart\n      : isResponderTouchMove\n        ? eventTypes$1.responderMove\n        : isResponderTouchEnd ? eventTypes$1.responderEnd : null;\n\n    if (incrementalTouch) {\n      var gesture = ResponderSyntheticEvent.getPooled(\n        incrementalTouch,\n        responderInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(gesture);\n      extracted = accumulate(extracted, gesture);\n    }\n\n    var isResponderTerminate =\n      responderInst && topLevelType === TOP_TOUCH_CANCEL;\n    var isResponderRelease =\n      responderInst &&\n      !isResponderTerminate &&\n      isEndish(topLevelType) &&\n      noResponderTouches(nativeEvent);\n    var finalTouch = isResponderTerminate\n      ? eventTypes$1.responderTerminate\n      : isResponderRelease ? eventTypes$1.responderRelease : null;\n    if (finalTouch) {\n      var finalEvent = ResponderSyntheticEvent.getPooled(\n        finalTouch,\n        responderInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(finalEvent);\n      extracted = accumulate(extracted, finalEvent);\n      changeResponder(null);\n    }\n\n    return extracted;\n  },\n\n  GlobalResponderHandler: null,\n\n  injection: {\n    /**\n     * @param {{onChange: (ReactID, ReactID) => void} GlobalResponderHandler\n     * Object that handles any change in responder. Use this to inject\n     * integration with an existing touch handling system etc.\n     */\n    injectGlobalResponderHandler: function(GlobalResponderHandler) {\n      ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;\n    }\n  }\n};\n\nvar customBubblingEventTypes$1 =\n  ReactNativeViewConfigRegistry.customBubblingEventTypes;\nvar customDirectEventTypes$1 =\n  ReactNativeViewConfigRegistry.customDirectEventTypes;\nvar eventTypes$2 = ReactNativeViewConfigRegistry.eventTypes;\n\nvar ReactNativeBridgeEventPlugin = {\n  eventTypes: eventTypes$2,\n\n  /**\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget\n  ) {\n    if (targetInst == null) {\n      // Probably a node belonging to another renderer's tree.\n      return null;\n    }\n    var bubbleDispatchConfig = customBubblingEventTypes$1[topLevelType];\n    var directDispatchConfig = customDirectEventTypes$1[topLevelType];\n    invariant(\n      bubbleDispatchConfig || directDispatchConfig,\n      'Unsupported top level event type \"%s\" dispatched',\n      topLevelType\n    );\n    var event = SyntheticEvent$1.getPooled(\n      bubbleDispatchConfig || directDispatchConfig,\n      targetInst,\n      nativeEvent,\n      nativeEventTarget\n    );\n    if (bubbleDispatchConfig) {\n      accumulateTwoPhaseDispatches(event);\n    } else if (directDispatchConfig) {\n      accumulateDirectDispatches(event);\n    } else {\n      return null;\n    }\n    return event;\n  }\n};\n\nvar ReactNativeEventPluginOrder = [\n  \"ResponderEventPlugin\",\n  \"ReactNativeBridgeEventPlugin\"\n];\n\n/**\n * Make sure essential globals are available and are patched correctly. Please don't remove this\n * line. Bundles created by react-packager `require` it before executing any application code. This\n * ensures it exists in the dependency graph and can be `require`d.\n * TODO: require this in packager, not in React #10932517\n */\n// Module provided by RN:\n/**\n * Inject module for resolving DOM hierarchy and plugin ordering.\n */\ninjection.injectEventPluginOrder(ReactNativeEventPluginOrder);\n\n/**\n * Some important event plugins included by default (without having to require\n * them).\n */\ninjection.injectEventPluginsByName({\n  ResponderEventPlugin: ResponderEventPlugin,\n  ReactNativeBridgeEventPlugin: ReactNativeBridgeEventPlugin\n});\n\nvar instanceCache = {};\nvar instanceProps = {};\n\nfunction precacheFiberNode(hostInst, tag) {\n  instanceCache[tag] = hostInst;\n}\n\nfunction uncacheFiberNode(tag) {\n  delete instanceCache[tag];\n  delete instanceProps[tag];\n}\n\nfunction getInstanceFromTag(tag) {\n  return instanceCache[tag] || null;\n}\n\nfunction getTagFromInstance(inst) {\n  var tag = inst.stateNode._nativeTag;\n  if (tag === undefined) {\n    tag = inst.stateNode.canonical._nativeTag;\n  }\n  invariant(tag, \"All native instances should have a tag.\");\n  return tag;\n}\n\nfunction getFiberCurrentPropsFromNode$1(stateNode) {\n  return instanceProps[stateNode._nativeTag] || null;\n}\n\nfunction updateFiberProps(tag, props) {\n  instanceProps[tag] = props;\n}\n\nvar ReactNativeComponentTree = Object.freeze({\n  precacheFiberNode: precacheFiberNode,\n  uncacheFiberNode: uncacheFiberNode,\n  getClosestInstanceFromNode: getInstanceFromTag,\n  getInstanceFromNode: getInstanceFromTag,\n  getNodeFromInstance: getTagFromInstance,\n  getFiberCurrentPropsFromNode: getFiberCurrentPropsFromNode$1,\n  updateFiberProps: updateFiberProps\n});\n\n// Use to restore controlled state after a change event has fired.\n\nvar fiberHostComponent = null;\n\nvar restoreTarget = null;\nvar restoreQueue = null;\n\nfunction restoreStateOfTarget(target) {\n  // We perform this translation at the end of the event loop so that we\n  // always receive the correct fiber here\n  var internalInstance = getInstanceFromNode(target);\n  if (!internalInstance) {\n    // Unmounted\n    return;\n  }\n  invariant(\n    fiberHostComponent &&\n      typeof fiberHostComponent.restoreControlledState === \"function\",\n    \"Fiber needs to be injected to handle a fiber target for controlled \" +\n      \"events. This error is likely caused by a bug in React. Please file an issue.\"\n  );\n  var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);\n  fiberHostComponent.restoreControlledState(\n    internalInstance.stateNode,\n    internalInstance.type,\n    props\n  );\n}\n\nfunction needsStateRestore() {\n  return restoreTarget !== null || restoreQueue !== null;\n}\n\nfunction restoreStateIfNeeded() {\n  if (!restoreTarget) {\n    return;\n  }\n  var target = restoreTarget;\n  var queuedTargets = restoreQueue;\n  restoreTarget = null;\n  restoreQueue = null;\n\n  restoreStateOfTarget(target);\n  if (queuedTargets) {\n    for (var i = 0; i < queuedTargets.length; i++) {\n      restoreStateOfTarget(queuedTargets[i]);\n    }\n  }\n}\n\n// Used as a way to call batchedUpdates when we don't have a reference to\n// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n\n// Defaults\nvar _batchedUpdates = function(fn, bookkeeping) {\n  return fn(bookkeeping);\n};\nvar _interactiveUpdates = function(fn, a, b) {\n  return fn(a, b);\n};\nvar _flushInteractiveUpdates = function() {};\n\nvar isBatching = false;\nfunction batchedUpdates(fn, bookkeeping) {\n  if (isBatching) {\n    // If we are currently inside another batch, we need to wait until it\n    // fully completes before restoring state.\n    return fn(bookkeeping);\n  }\n  isBatching = true;\n  try {\n    return _batchedUpdates(fn, bookkeeping);\n  } finally {\n    // Here we wait until all updates have propagated, which is important\n    // when using controlled components within layers:\n    // https://github.com/facebook/react/issues/1698\n    // Then we restore state of any controlled component.\n    isBatching = false;\n    var controlledComponentsHavePendingUpdates = needsStateRestore();\n    if (controlledComponentsHavePendingUpdates) {\n      // If a controlled event was fired, we may need to restore the state of\n      // the DOM node back to the controlled value. This is necessary when React\n      // bails out of the update without touching the DOM.\n      _flushInteractiveUpdates();\n      restoreStateIfNeeded();\n    }\n  }\n}\n\nvar injection$2 = {\n  injectRenderer: function(renderer) {\n    _batchedUpdates = renderer.batchedUpdates;\n    _interactiveUpdates = renderer.interactiveUpdates;\n    _flushInteractiveUpdates = renderer.flushInteractiveUpdates;\n  }\n};\n\n/**\n * Version of `ReactBrowserEventEmitter` that works on the receiving side of a\n * serialized worker boundary.\n */\n\n// Shared default empty native event - conserve memory.\nvar EMPTY_NATIVE_EVENT = {};\n\n/**\n * Selects a subsequence of `Touch`es, without destroying `touches`.\n *\n * @param {Array<Touch>} touches Deserialized touch objects.\n * @param {Array<number>} indices Indices by which to pull subsequence.\n * @return {Array<Touch>} Subsequence of touch objects.\n */\nvar touchSubsequence = function(touches, indices) {\n  var ret = [];\n  for (var i = 0; i < indices.length; i++) {\n    ret.push(touches[indices[i]]);\n  }\n  return ret;\n};\n\n/**\n * TODO: Pool all of this.\n *\n * Destroys `touches` by removing touch objects at indices `indices`. This is\n * to maintain compatibility with W3C touch \"end\" events, where the active\n * touches don't include the set that has just been \"ended\".\n *\n * @param {Array<Touch>} touches Deserialized touch objects.\n * @param {Array<number>} indices Indices to remove from `touches`.\n * @return {Array<Touch>} Subsequence of removed touch objects.\n */\nvar removeTouchesAtIndices = function(touches, indices) {\n  var rippedOut = [];\n  // use an unsafe downcast to alias to nullable elements,\n  // so we can delete and then compact.\n  var temp = touches;\n  for (var i = 0; i < indices.length; i++) {\n    var index = indices[i];\n    rippedOut.push(touches[index]);\n    temp[index] = null;\n  }\n  var fillAt = 0;\n  for (var j = 0; j < temp.length; j++) {\n    var cur = temp[j];\n    if (cur !== null) {\n      temp[fillAt++] = cur;\n    }\n  }\n  temp.length = fillAt;\n  return rippedOut;\n};\n\n/**\n * Internal version of `receiveEvent` in terms of normalized (non-tag)\n * `rootNodeID`.\n *\n * @see receiveEvent.\n *\n * @param {rootNodeID} rootNodeID React root node ID that event occurred on.\n * @param {TopLevelType} topLevelType Top level type of event.\n * @param {?object} nativeEventParam Object passed from native.\n */\nfunction _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam) {\n  var nativeEvent = nativeEventParam || EMPTY_NATIVE_EVENT;\n  var inst = getInstanceFromTag(rootNodeID);\n  batchedUpdates(function() {\n    runExtractedEventsInBatch(\n      topLevelType,\n      inst,\n      nativeEvent,\n      nativeEvent.target\n    );\n  });\n  // React Native doesn't use ReactControlledComponent but if it did, here's\n  // where it would do it.\n}\n\n/**\n * Publicly exposed method on module for native objc to invoke when a top\n * level event is extracted.\n * @param {rootNodeID} rootNodeID React root node ID that event occurred on.\n * @param {TopLevelType} topLevelType Top level type of event.\n * @param {object} nativeEventParam Object passed from native.\n */\nfunction receiveEvent(rootNodeID, topLevelType, nativeEventParam) {\n  _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam);\n}\n\n/**\n * Simple multi-wrapper around `receiveEvent` that is intended to receive an\n * efficient representation of `Touch` objects, and other information that\n * can be used to construct W3C compliant `Event` and `Touch` lists.\n *\n * This may create dispatch behavior that differs than web touch handling. We\n * loop through each of the changed touches and receive it as a single event.\n * So two `touchStart`/`touchMove`s that occur simultaneously are received as\n * two separate touch event dispatches - when they arguably should be one.\n *\n * This implementation reuses the `Touch` objects themselves as the `Event`s\n * since we dispatch an event for each touch (though that might not be spec\n * compliant). The main purpose of reusing them is to save allocations.\n *\n * TODO: Dispatch multiple changed touches in one event. The bubble path\n * could be the first common ancestor of all the `changedTouches`.\n *\n * One difference between this behavior and W3C spec: cancelled touches will\n * not appear in `.touches`, or in any future `.touches`, though they may\n * still be \"actively touching the surface\".\n *\n * Web desktop polyfills only need to construct a fake touch event with\n * identifier 0, also abandoning traditional click handlers.\n */\nfunction receiveTouches(eventTopLevelType, touches, changedIndices) {\n  var changedTouches =\n    eventTopLevelType === \"topTouchEnd\" ||\n    eventTopLevelType === \"topTouchCancel\"\n      ? removeTouchesAtIndices(touches, changedIndices)\n      : touchSubsequence(touches, changedIndices);\n\n  for (var jj = 0; jj < changedTouches.length; jj++) {\n    var touch = changedTouches[jj];\n    // Touch objects can fulfill the role of `DOM` `Event` objects if we set\n    // the `changedTouches`/`touches`. This saves allocations.\n    touch.changedTouches = changedTouches;\n    touch.touches = touches;\n    var nativeEvent = touch;\n    var rootNodeID = null;\n    var target = nativeEvent.target;\n    if (target !== null && target !== undefined) {\n      if (target < 1) {\n        {\n          warning(\n            false,\n            \"A view is reporting that a touch occurred on tag zero.\"\n          );\n        }\n      } else {\n        rootNodeID = target;\n      }\n    }\n    // $FlowFixMe Shouldn't we *not* call it if rootNodeID is null?\n    _receiveRootNodeIDEvent(rootNodeID, eventTopLevelType, nativeEvent);\n  }\n}\n\nvar ReactNativeEventEmitter = Object.freeze({\n  getListener: getListener,\n  registrationNames: registrationNameModules,\n  _receiveRootNodeIDEvent: _receiveRootNodeIDEvent,\n  receiveEvent: receiveEvent,\n  receiveTouches: receiveTouches\n});\n\n// Module provided by RN:\nvar ReactNativeGlobalResponderHandler = {\n  onChange: function(from, to, blockNativeResponder) {\n    if (to !== null) {\n      var tag = to.stateNode._nativeTag;\n      UIManager.setJSResponder(tag, blockNativeResponder);\n    } else {\n      UIManager.clearJSResponder();\n    }\n  }\n};\n\n// Module provided by RN:\n/**\n * Register the event emitter with the native bridge\n */\nRCTEventEmitter.register(ReactNativeEventEmitter);\n\ninjection$1.injectComponentTree(ReactNativeComponentTree);\n\nResponderEventPlugin.injection.injectGlobalResponderHandler(\n  ReactNativeGlobalResponderHandler\n);\n\n/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */\n\n/**\n * This API should be called `delete` but we'd have to make sure to always\n * transform these to strings for IE support. When this transform is fully\n * supported we can rename it.\n */\n\nfunction get$1(key) {\n  return key._reactInternalFiber;\n}\n\nfunction set(key, value) {\n  key._reactInternalFiber = value;\n}\n\nvar ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nvar ReactCurrentOwner = ReactInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === \"function\" && Symbol.for;\n\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for(\"react.element\") : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for(\"react.portal\") : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for(\"react.fragment\") : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol\n  ? Symbol.for(\"react.strict_mode\")\n  : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for(\"react.profiler\") : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for(\"react.provider\") : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for(\"react.context\") : 0xeace;\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for(\"react.async_mode\") : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol\n  ? Symbol.for(\"react.forward_ref\")\n  : 0xead0;\nvar REACT_TIMEOUT_TYPE = hasSymbol ? Symbol.for(\"react.timeout\") : 0xead1;\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === \"function\" && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable === \"undefined\") {\n    return null;\n  }\n  var maybeIterator =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === \"function\") {\n    return maybeIterator;\n  }\n  return null;\n}\n\nfunction getComponentName(fiber) {\n  var type = fiber.type;\n\n  if (typeof type === \"function\") {\n    return type.displayName || type.name;\n  }\n  if (typeof type === \"string\") {\n    return type;\n  }\n  switch (type) {\n    case REACT_ASYNC_MODE_TYPE:\n      return \"AsyncMode\";\n    case REACT_CONTEXT_TYPE:\n      return \"Context.Consumer\";\n    case REACT_FRAGMENT_TYPE:\n      return \"ReactFragment\";\n    case REACT_PORTAL_TYPE:\n      return \"ReactPortal\";\n    case REACT_PROFILER_TYPE:\n      return \"Profiler(\" + fiber.pendingProps.id + \")\";\n    case REACT_PROVIDER_TYPE:\n      return \"Context.Provider\";\n    case REACT_STRICT_MODE_TYPE:\n      return \"StrictMode\";\n    case REACT_TIMEOUT_TYPE:\n      return \"Timeout\";\n  }\n  if (typeof type === \"object\" && type !== null) {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        var functionName = type.render.displayName || type.render.name || \"\";\n        return functionName !== \"\"\n          ? \"ForwardRef(\" + functionName + \")\"\n          : \"ForwardRef\";\n    }\n  }\n  return null;\n}\n\n// Don't change these two values. They're used by React Dev Tools.\nvar NoEffect = /*              */ 0;\nvar PerformedWork = /*         */ 1;\n\n// You can change the rest (and add more).\nvar Placement = /*             */ 2;\nvar Update = /*                */ 4;\nvar PlacementAndUpdate = /*    */ 6;\nvar Deletion = /*              */ 8;\nvar ContentReset = /*          */ 16;\nvar Callback = /*              */ 32;\nvar DidCapture = /*            */ 64;\nvar Ref = /*                   */ 128;\nvar Snapshot = /*              */ 256;\n\n// Union of all host effects\nvar HostEffectMask = /*        */ 511;\n\nvar Incomplete = /*            */ 512;\nvar ShouldCapture = /*         */ 1024;\n\nvar MOUNTING = 1;\nvar MOUNTED = 2;\nvar UNMOUNTED = 3;\n\nfunction isFiberMountedImpl(fiber) {\n  var node = fiber;\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    if ((node.effectTag & Placement) !== NoEffect) {\n      return MOUNTING;\n    }\n    while (node.return) {\n      node = node.return;\n      if ((node.effectTag & Placement) !== NoEffect) {\n        return MOUNTING;\n      }\n    }\n  } else {\n    while (node.return) {\n      node = node.return;\n    }\n  }\n  if (node.tag === HostRoot) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return MOUNTED;\n  }\n  // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n  return UNMOUNTED;\n}\n\nfunction isFiberMounted(fiber) {\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction isMounted(component) {\n  {\n    var owner = ReactCurrentOwner.current;\n    if (owner !== null && owner.tag === ClassComponent) {\n      var ownerFiber = owner;\n      var instance = ownerFiber.stateNode;\n      !instance._warnedAboutRefsInRender\n        ? warning(\n            false,\n            \"%s is accessing isMounted inside its render() function. \" +\n              \"render() should be a pure function of props and state. It should \" +\n              \"never access something that requires stale data from the previous \" +\n              \"render, such as refs. Move this logic to componentDidMount and \" +\n              \"componentDidUpdate instead.\",\n            getComponentName(ownerFiber) || \"A component\"\n          )\n        : void 0;\n      instance._warnedAboutRefsInRender = true;\n    }\n  }\n\n  var fiber = get$1(component);\n  if (!fiber) {\n    return false;\n  }\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction assertIsMounted(fiber) {\n  invariant(\n    isFiberMountedImpl(fiber) === MOUNTED,\n    \"Unable to find node on an unmounted component.\"\n  );\n}\n\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  var alternate = fiber.alternate;\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    var state = isFiberMountedImpl(fiber);\n    invariant(\n      state !== UNMOUNTED,\n      \"Unable to find node on an unmounted component.\"\n    );\n    if (state === MOUNTING) {\n      return null;\n    }\n    return fiber;\n  }\n  // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n  var a = fiber;\n  var b = alternate;\n  while (true) {\n    var parentA = a.return;\n    var parentB = parentA ? parentA.alternate : null;\n    if (!parentA || !parentB) {\n      // We're at the root.\n      break;\n    }\n\n    // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n    if (parentA.child === parentB.child) {\n      var child = parentA.child;\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          assertIsMounted(parentA);\n          return fiber;\n        }\n        if (child === b) {\n          // We've determined that B is the current branch.\n          assertIsMounted(parentA);\n          return alternate;\n        }\n        child = child.sibling;\n      }\n      // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n      invariant(false, \"Unable to find node on an unmounted component.\");\n    }\n\n    if (a.return !== b.return) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      var didFindChild = false;\n      var _child = parentA.child;\n      while (_child) {\n        if (_child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (_child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        _child = _child.sibling;\n      }\n      if (!didFindChild) {\n        // Search parent B's child set\n        _child = parentB.child;\n        while (_child) {\n          if (_child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (_child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          _child = _child.sibling;\n        }\n        invariant(\n          didFindChild,\n          \"Child was not found in either parent set. This indicates a bug \" +\n            \"in React related to the return pointer. Please file an issue.\"\n        );\n      }\n    }\n\n    invariant(\n      a.alternate === b,\n      \"Return fibers should always be each others' alternates. \" +\n        \"This error is likely caused by a bug in React. Please file an issue.\"\n    );\n  }\n  // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n  invariant(\n    a.tag === HostRoot,\n    \"Unable to find node on an unmounted component.\"\n  );\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  }\n  // Otherwise B has to be current branch.\n  return alternate;\n}\n\nfunction findCurrentHostFiber(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node.return || node.return === currentParent) {\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nfunction findCurrentHostFiberWithNoPortals(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child && node.tag !== HostPortal) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node.return || node.return === currentParent) {\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\n// Modules provided by RN:\nvar emptyObject$1 = {};\n\n/**\n * Create a payload that contains all the updates between two sets of props.\n *\n * These helpers are all encapsulated into a single module, because they use\n * mutation as a performance optimization which leads to subtle shared\n * dependencies between the code paths. To avoid this mutable state leaking\n * across modules, I've kept them isolated to this module.\n */\n\n// Tracks removed keys\nvar removedKeys = null;\nvar removedKeyCount = 0;\n\nfunction defaultDiffer(prevProp, nextProp) {\n  if (typeof nextProp !== \"object\" || nextProp === null) {\n    // Scalars have already been checked for equality\n    return true;\n  } else {\n    // For objects and arrays, the default diffing algorithm is a deep compare\n    return deepDiffer(prevProp, nextProp);\n  }\n}\n\nfunction restoreDeletedValuesInNestedArray(\n  updatePayload,\n  node,\n  validAttributes\n) {\n  if (Array.isArray(node)) {\n    var i = node.length;\n    while (i-- && removedKeyCount > 0) {\n      restoreDeletedValuesInNestedArray(\n        updatePayload,\n        node[i],\n        validAttributes\n      );\n    }\n  } else if (node && removedKeyCount > 0) {\n    var obj = node;\n    for (var propKey in removedKeys) {\n      if (!removedKeys[propKey]) {\n        continue;\n      }\n      var _nextProp = obj[propKey];\n      if (_nextProp === undefined) {\n        continue;\n      }\n\n      var attributeConfig = validAttributes[propKey];\n      if (!attributeConfig) {\n        continue; // not a valid native prop\n      }\n\n      if (typeof _nextProp === \"function\") {\n        _nextProp = true;\n      }\n      if (typeof _nextProp === \"undefined\") {\n        _nextProp = null;\n      }\n\n      if (typeof attributeConfig !== \"object\") {\n        // case: !Object is the default case\n        updatePayload[propKey] = _nextProp;\n      } else if (\n        typeof attributeConfig.diff === \"function\" ||\n        typeof attributeConfig.process === \"function\"\n      ) {\n        // case: CustomAttributeConfiguration\n        var nextValue =\n          typeof attributeConfig.process === \"function\"\n            ? attributeConfig.process(_nextProp)\n            : _nextProp;\n        updatePayload[propKey] = nextValue;\n      }\n      removedKeys[propKey] = false;\n      removedKeyCount--;\n    }\n  }\n}\n\nfunction diffNestedArrayProperty(\n  updatePayload,\n  prevArray,\n  nextArray,\n  validAttributes\n) {\n  var minLength =\n    prevArray.length < nextArray.length ? prevArray.length : nextArray.length;\n  var i = void 0;\n  for (i = 0; i < minLength; i++) {\n    // Diff any items in the array in the forward direction. Repeated keys\n    // will be overwritten by later values.\n    updatePayload = diffNestedProperty(\n      updatePayload,\n      prevArray[i],\n      nextArray[i],\n      validAttributes\n    );\n  }\n  for (; i < prevArray.length; i++) {\n    // Clear out all remaining properties.\n    updatePayload = clearNestedProperty(\n      updatePayload,\n      prevArray[i],\n      validAttributes\n    );\n  }\n  for (; i < nextArray.length; i++) {\n    // Add all remaining properties.\n    updatePayload = addNestedProperty(\n      updatePayload,\n      nextArray[i],\n      validAttributes\n    );\n  }\n  return updatePayload;\n}\n\nfunction diffNestedProperty(\n  updatePayload,\n  prevProp,\n  nextProp,\n  validAttributes\n) {\n  if (!updatePayload && prevProp === nextProp) {\n    // If no properties have been added, then we can bail out quickly on object\n    // equality.\n    return updatePayload;\n  }\n\n  if (!prevProp || !nextProp) {\n    if (nextProp) {\n      return addNestedProperty(updatePayload, nextProp, validAttributes);\n    }\n    if (prevProp) {\n      return clearNestedProperty(updatePayload, prevProp, validAttributes);\n    }\n    return updatePayload;\n  }\n\n  if (!Array.isArray(prevProp) && !Array.isArray(nextProp)) {\n    // Both are leaves, we can diff the leaves.\n    return diffProperties(updatePayload, prevProp, nextProp, validAttributes);\n  }\n\n  if (Array.isArray(prevProp) && Array.isArray(nextProp)) {\n    // Both are arrays, we can diff the arrays.\n    return diffNestedArrayProperty(\n      updatePayload,\n      prevProp,\n      nextProp,\n      validAttributes\n    );\n  }\n\n  if (Array.isArray(prevProp)) {\n    return diffProperties(\n      updatePayload,\n      // $FlowFixMe - We know that this is always an object when the input is.\n      flattenStyle(prevProp),\n      // $FlowFixMe - We know that this isn't an array because of above flow.\n      nextProp,\n      validAttributes\n    );\n  }\n\n  return diffProperties(\n    updatePayload,\n    prevProp,\n    // $FlowFixMe - We know that this is always an object when the input is.\n    flattenStyle(nextProp),\n    validAttributes\n  );\n}\n\n/**\n * addNestedProperty takes a single set of props and valid attribute\n * attribute configurations. It processes each prop and adds it to the\n * updatePayload.\n */\nfunction addNestedProperty(updatePayload, nextProp, validAttributes) {\n  if (!nextProp) {\n    return updatePayload;\n  }\n\n  if (!Array.isArray(nextProp)) {\n    // Add each property of the leaf.\n    return addProperties(updatePayload, nextProp, validAttributes);\n  }\n\n  for (var i = 0; i < nextProp.length; i++) {\n    // Add all the properties of the array.\n    updatePayload = addNestedProperty(\n      updatePayload,\n      nextProp[i],\n      validAttributes\n    );\n  }\n\n  return updatePayload;\n}\n\n/**\n * clearNestedProperty takes a single set of props and valid attributes. It\n * adds a null sentinel to the updatePayload, for each prop key.\n */\nfunction clearNestedProperty(updatePayload, prevProp, validAttributes) {\n  if (!prevProp) {\n    return updatePayload;\n  }\n\n  if (!Array.isArray(prevProp)) {\n    // Add each property of the leaf.\n    return clearProperties(updatePayload, prevProp, validAttributes);\n  }\n\n  for (var i = 0; i < prevProp.length; i++) {\n    // Add all the properties of the array.\n    updatePayload = clearNestedProperty(\n      updatePayload,\n      prevProp[i],\n      validAttributes\n    );\n  }\n  return updatePayload;\n}\n\n/**\n * diffProperties takes two sets of props and a set of valid attributes\n * and write to updatePayload the values that changed or were deleted.\n * If no updatePayload is provided, a new one is created and returned if\n * anything changed.\n */\nfunction diffProperties(updatePayload, prevProps, nextProps, validAttributes) {\n  var attributeConfig = void 0;\n  var nextProp = void 0;\n  var prevProp = void 0;\n\n  for (var propKey in nextProps) {\n    attributeConfig = validAttributes[propKey];\n    if (!attributeConfig) {\n      continue; // not a valid native prop\n    }\n\n    prevProp = prevProps[propKey];\n    nextProp = nextProps[propKey];\n\n    // functions are converted to booleans as markers that the associated\n    // events should be sent from native.\n    if (typeof nextProp === \"function\") {\n      nextProp = true;\n      // If nextProp is not a function, then don't bother changing prevProp\n      // since nextProp will win and go into the updatePayload regardless.\n      if (typeof prevProp === \"function\") {\n        prevProp = true;\n      }\n    }\n\n    // An explicit value of undefined is treated as a null because it overrides\n    // any other preceding value.\n    if (typeof nextProp === \"undefined\") {\n      nextProp = null;\n      if (typeof prevProp === \"undefined\") {\n        prevProp = null;\n      }\n    }\n\n    if (removedKeys) {\n      removedKeys[propKey] = false;\n    }\n\n    if (updatePayload && updatePayload[propKey] !== undefined) {\n      // Something else already triggered an update to this key because another\n      // value diffed. Since we're now later in the nested arrays our value is\n      // more important so we need to calculate it and override the existing\n      // value. It doesn't matter if nothing changed, we'll set it anyway.\n\n      // Pattern match on: attributeConfig\n      if (typeof attributeConfig !== \"object\") {\n        // case: !Object is the default case\n        updatePayload[propKey] = nextProp;\n      } else if (\n        typeof attributeConfig.diff === \"function\" ||\n        typeof attributeConfig.process === \"function\"\n      ) {\n        // case: CustomAttributeConfiguration\n        var nextValue =\n          typeof attributeConfig.process === \"function\"\n            ? attributeConfig.process(nextProp)\n            : nextProp;\n        updatePayload[propKey] = nextValue;\n      }\n      continue;\n    }\n\n    if (prevProp === nextProp) {\n      continue; // nothing changed\n    }\n\n    // Pattern match on: attributeConfig\n    if (typeof attributeConfig !== \"object\") {\n      // case: !Object is the default case\n      if (defaultDiffer(prevProp, nextProp)) {\n        // a normal leaf has changed\n        (updatePayload || (updatePayload = {}))[propKey] = nextProp;\n      }\n    } else if (\n      typeof attributeConfig.diff === \"function\" ||\n      typeof attributeConfig.process === \"function\"\n    ) {\n      // case: CustomAttributeConfiguration\n      var shouldUpdate =\n        prevProp === undefined ||\n        (typeof attributeConfig.diff === \"function\"\n          ? attributeConfig.diff(prevProp, nextProp)\n          : defaultDiffer(prevProp, nextProp));\n      if (shouldUpdate) {\n        var _nextValue =\n          typeof attributeConfig.process === \"function\"\n            ? attributeConfig.process(nextProp)\n            : nextProp;\n        (updatePayload || (updatePayload = {}))[propKey] = _nextValue;\n      }\n    } else {\n      // default: fallthrough case when nested properties are defined\n      removedKeys = null;\n      removedKeyCount = 0;\n      // We think that attributeConfig is not CustomAttributeConfiguration at\n      // this point so we assume it must be AttributeConfiguration.\n      updatePayload = diffNestedProperty(\n        updatePayload,\n        prevProp,\n        nextProp,\n        attributeConfig\n      );\n      if (removedKeyCount > 0 && updatePayload) {\n        restoreDeletedValuesInNestedArray(\n          updatePayload,\n          nextProp,\n          attributeConfig\n        );\n        removedKeys = null;\n      }\n    }\n  }\n\n  // Also iterate through all the previous props to catch any that have been\n  // removed and make sure native gets the signal so it can reset them to the\n  // default.\n  for (var _propKey in prevProps) {\n    if (nextProps[_propKey] !== undefined) {\n      continue; // we've already covered this key in the previous pass\n    }\n    attributeConfig = validAttributes[_propKey];\n    if (!attributeConfig) {\n      continue; // not a valid native prop\n    }\n\n    if (updatePayload && updatePayload[_propKey] !== undefined) {\n      // This was already updated to a diff result earlier.\n      continue;\n    }\n\n    prevProp = prevProps[_propKey];\n    if (prevProp === undefined) {\n      continue; // was already empty anyway\n    }\n    // Pattern match on: attributeConfig\n    if (\n      typeof attributeConfig !== \"object\" ||\n      typeof attributeConfig.diff === \"function\" ||\n      typeof attributeConfig.process === \"function\"\n    ) {\n      // case: CustomAttributeConfiguration | !Object\n      // Flag the leaf property for removal by sending a sentinel.\n      (updatePayload || (updatePayload = {}))[_propKey] = null;\n      if (!removedKeys) {\n        removedKeys = {};\n      }\n      if (!removedKeys[_propKey]) {\n        removedKeys[_propKey] = true;\n        removedKeyCount++;\n      }\n    } else {\n      // default:\n      // This is a nested attribute configuration where all the properties\n      // were removed so we need to go through and clear out all of them.\n      updatePayload = clearNestedProperty(\n        updatePayload,\n        prevProp,\n        attributeConfig\n      );\n    }\n  }\n  return updatePayload;\n}\n\n/**\n * addProperties adds all the valid props to the payload after being processed.\n */\nfunction addProperties(updatePayload, props, validAttributes) {\n  // TODO: Fast path\n  return diffProperties(updatePayload, emptyObject$1, props, validAttributes);\n}\n\n/**\n * clearProperties clears all the previous props by adding a null sentinel\n * to the payload for each valid key.\n */\nfunction clearProperties(updatePayload, prevProps, validAttributes) {\n  // TODO: Fast path\n  return diffProperties(\n    updatePayload,\n    prevProps,\n    emptyObject$1,\n    validAttributes\n  );\n}\n\nfunction create(props, validAttributes) {\n  return addProperties(\n    null, // updatePayload\n    props,\n    validAttributes\n  );\n}\n\nfunction diff(prevProps, nextProps, validAttributes) {\n  return diffProperties(\n    null, // updatePayload\n    prevProps,\n    nextProps,\n    validAttributes\n  );\n}\n\n/**\n * In the future, we should cleanup callbacks by cancelling them instead of\n * using this.\n */\nfunction mountSafeCallback(context, callback) {\n  return function() {\n    if (!callback) {\n      return undefined;\n    }\n    if (typeof context.__isMounted === \"boolean\") {\n      // TODO(gaearon): this is gross and should be removed.\n      // It is currently necessary because View uses createClass,\n      // and so any measure() calls on View (which are done by React\n      // DevTools) trigger the isMounted() deprecation warning.\n      if (!context.__isMounted) {\n        return undefined;\n      }\n      // The else branch is important so that we don't\n      // trigger the deprecation warning by calling isMounted.\n    } else if (typeof context.isMounted === \"function\") {\n      if (!context.isMounted()) {\n        return undefined;\n      }\n    }\n    return callback.apply(context, arguments);\n  };\n}\n\nfunction throwOnStylesProp(component, props) {\n  if (props.styles !== undefined) {\n    var owner = component._owner || null;\n    var name = component.constructor.displayName;\n    var msg =\n      \"`styles` is not a supported property of `\" +\n      name +\n      \"`, did \" +\n      \"you mean `style` (singular)?\";\n    if (owner && owner.constructor && owner.constructor.displayName) {\n      msg +=\n        \"\\n\\nCheck the `\" +\n        owner.constructor.displayName +\n        \"` parent \" +\n        \" component.\";\n    }\n    throw new Error(msg);\n  }\n}\n\nfunction warnForStyleProps(props, validAttributes) {\n  for (var key in validAttributes.style) {\n    if (!(validAttributes[key] || props[key] === undefined)) {\n      console.error(\n        \"You are setting the style `{ \" +\n          key +\n          \": ... }` as a prop. You \" +\n          \"should nest it in a style object. \" +\n          \"E.g. `{ style: { \" +\n          key +\n          \": ... } }`\"\n      );\n    }\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n// Modules provided by RN:\n/**\n * This component defines the same methods as NativeMethodsMixin but without the\n * findNodeHandle wrapper. This wrapper is unnecessary for HostComponent views\n * and would also result in a circular require.js dependency (since\n * ReactNativeFiber depends on this component and NativeMethodsMixin depends on\n * ReactNativeFiber).\n */\n\nvar ReactNativeFiberHostComponent = (function() {\n  function ReactNativeFiberHostComponent(tag, viewConfig) {\n    _classCallCheck(this, ReactNativeFiberHostComponent);\n\n    this._nativeTag = tag;\n    this._children = [];\n    this.viewConfig = viewConfig;\n  }\n\n  ReactNativeFiberHostComponent.prototype.blur = function blur() {\n    TextInputState.blurTextInput(this._nativeTag);\n  };\n\n  ReactNativeFiberHostComponent.prototype.focus = function focus() {\n    TextInputState.focusTextInput(this._nativeTag);\n  };\n\n  ReactNativeFiberHostComponent.prototype.measure = function measure(callback) {\n    UIManager.measure(this._nativeTag, mountSafeCallback(this, callback));\n  };\n\n  ReactNativeFiberHostComponent.prototype.measureInWindow = function measureInWindow(\n    callback\n  ) {\n    UIManager.measureInWindow(\n      this._nativeTag,\n      mountSafeCallback(this, callback)\n    );\n  };\n\n  ReactNativeFiberHostComponent.prototype.measureLayout = function measureLayout(\n    relativeToNativeNode,\n    onSuccess,\n    onFail /* currently unused */\n  ) {\n    UIManager.measureLayout(\n      this._nativeTag,\n      relativeToNativeNode,\n      mountSafeCallback(this, onFail),\n      mountSafeCallback(this, onSuccess)\n    );\n  };\n\n  ReactNativeFiberHostComponent.prototype.setNativeProps = function setNativeProps(\n    nativeProps\n  ) {\n    {\n      warnForStyleProps(nativeProps, this.viewConfig.validAttributes);\n    }\n\n    var updatePayload = create(nativeProps, this.viewConfig.validAttributes);\n\n    // Avoid the overhead of bridge calls if there's no update.\n    // This is an expensive no-op for Android, and causes an unnecessary\n    // view invalidation for certain components (eg RCTTextInput) on iOS.\n    if (updatePayload != null) {\n      UIManager.updateView(\n        this._nativeTag,\n        this.viewConfig.uiViewClassName,\n        updatePayload\n      );\n    }\n  };\n\n  return ReactNativeFiberHostComponent;\n})();\n\nvar hasNativePerformanceNow =\n  typeof performance === \"object\" && typeof performance.now === \"function\";\n\nvar now$1 = hasNativePerformanceNow\n  ? function() {\n      return performance.now();\n    }\n  : function() {\n      return Date.now();\n    };\n\nvar scheduledCallback = null;\nvar frameDeadline = 0;\n\nvar frameDeadlineObject = {\n  timeRemaining: function() {\n    return frameDeadline - now$1();\n  },\n  didTimeout: false\n};\n\nfunction setTimeoutCallback() {\n  // TODO (bvaughn) Hard-coded 5ms unblocks initial async testing.\n  // React API probably changing to boolean rather than time remaining.\n  // Longer-term plan is to rewrite this using shared memory,\n  // And just return the value of the bit as the boolean.\n  frameDeadline = now$1() + 5;\n\n  var callback = scheduledCallback;\n  scheduledCallback = null;\n  if (callback !== null) {\n    callback(frameDeadlineObject);\n  }\n}\n\n// RN has a poor polyfill for requestIdleCallback so we aren't using it.\n// This implementation is only intended for short-term use anyway.\n// We also don't implement cancel functionality b'c Fiber doesn't currently need it.\nfunction scheduleDeferredCallback$1(callback, options) {\n  // We assume only one callback is scheduled at a time b'c that's how Fiber works.\n  scheduledCallback = callback;\n  var timeoutId = setTimeout(setTimeoutCallback, 1);\n  return timeoutId; // Timeouts are always numbers on RN\n}\n\nfunction cancelDeferredCallback$1(callbackID) {\n  scheduledCallback = null;\n  clearTimeout(callbackID); // Timeouts are always numbers on RN\n}\n\n// Renderers that don't support persistence\n// can re-export everything from this module.\n\nfunction shim() {\n  invariant(\n    false,\n    \"The current renderer does not support persistence. \" +\n      \"This error is likely caused by a bug in React. \" +\n      \"Please file an issue.\"\n  );\n}\n\n// Persistence (when unsupported)\nvar supportsPersistence = false;\nvar cloneInstance = shim;\nvar createContainerChildSet = shim;\nvar appendChildToContainerChildSet = shim;\nvar finalizeContainerChildren = shim;\nvar replaceContainerChildren = shim;\n\n// Renderers that don't support hydration\n// can re-export everything from this module.\n\nfunction shim$1() {\n  invariant(\n    false,\n    \"The current renderer does not support hyration. \" +\n      \"This error is likely caused by a bug in React. \" +\n      \"Please file an issue.\"\n  );\n}\n\n// Hydration (when unsupported)\nvar supportsHydration = false;\nvar canHydrateInstance = shim$1;\nvar canHydrateTextInstance = shim$1;\nvar getNextHydratableSibling = shim$1;\nvar getFirstHydratableChild = shim$1;\nvar hydrateInstance = shim$1;\nvar hydrateTextInstance = shim$1;\nvar didNotMatchHydratedContainerTextInstance = shim$1;\nvar didNotMatchHydratedTextInstance = shim$1;\nvar didNotHydrateContainerInstance = shim$1;\nvar didNotHydrateInstance = shim$1;\nvar didNotFindHydratableContainerInstance = shim$1;\nvar didNotFindHydratableContainerTextInstance = shim$1;\nvar didNotFindHydratableInstance = shim$1;\nvar didNotFindHydratableTextInstance = shim$1;\n\n// Modules provided by RN:\n// Unused\n\n// Counter for uniquely identifying views.\n// % 10 === 1 means it is a rootTag.\n// % 2 === 0 means it is a Fabric tag.\nvar nextReactTag = 3;\nfunction allocateTag() {\n  var tag = nextReactTag;\n  if (tag % 10 === 1) {\n    tag += 2;\n  }\n  nextReactTag = tag + 2;\n  return tag;\n}\n\nfunction recursivelyUncacheFiberNode(node) {\n  if (typeof node === \"number\") {\n    // Leaf node (eg text)\n    uncacheFiberNode(node);\n  } else {\n    uncacheFiberNode(node._nativeTag);\n\n    node._children.forEach(recursivelyUncacheFiberNode);\n  }\n}\n\nfunction appendInitialChild(parentInstance, child) {\n  parentInstance._children.push(child);\n}\n\nfunction createInstance(\n  type,\n  props,\n  rootContainerInstance,\n  hostContext,\n  internalInstanceHandle\n) {\n  var tag = allocateTag();\n  var viewConfig = ReactNativeViewConfigRegistry.get(type);\n\n  {\n    for (var key in viewConfig.validAttributes) {\n      if (props.hasOwnProperty(key)) {\n        deepFreezeAndThrowOnMutationInDev(props[key]);\n      }\n    }\n  }\n\n  invariant(\n    type !== \"RCTView\" || !hostContext.isInAParentText,\n    \"Nesting of <View> within <Text> is not currently supported.\"\n  );\n\n  var updatePayload = create(props, viewConfig.validAttributes);\n\n  UIManager.createView(\n    tag, // reactTag\n    viewConfig.uiViewClassName, // viewName\n    rootContainerInstance, // rootTag\n    updatePayload // props\n  );\n\n  var component = new ReactNativeFiberHostComponent(tag, viewConfig);\n\n  precacheFiberNode(internalInstanceHandle, tag);\n  updateFiberProps(tag, props);\n\n  // Not sure how to avoid this cast. Flow is okay if the component is defined\n  // in the same file but if it's external it can't see the types.\n  return component;\n}\n\nfunction createTextInstance(\n  text,\n  rootContainerInstance,\n  hostContext,\n  internalInstanceHandle\n) {\n  invariant(\n    hostContext.isInAParentText,\n    \"Text strings must be rendered within a <Text> component.\"\n  );\n\n  var tag = allocateTag();\n\n  UIManager.createView(\n    tag, // reactTag\n    \"RCTRawText\", // viewName\n    rootContainerInstance, // rootTag\n    { text: text } // props\n  );\n\n  precacheFiberNode(internalInstanceHandle, tag);\n\n  return tag;\n}\n\nfunction finalizeInitialChildren(\n  parentInstance,\n  type,\n  props,\n  rootContainerInstance,\n  hostContext\n) {\n  // Don't send a no-op message over the bridge.\n  if (parentInstance._children.length === 0) {\n    return false;\n  }\n\n  // Map from child objects to native tags.\n  // Either way we need to pass a copy of the Array to prevent it from being frozen.\n  var nativeTags = parentInstance._children.map(function(child) {\n    return typeof child === \"number\"\n      ? child // Leaf node (eg text)\n      : child._nativeTag;\n  });\n\n  UIManager.setChildren(\n    parentInstance._nativeTag, // containerTag\n    nativeTags // reactTags\n  );\n\n  return false;\n}\n\nfunction getRootHostContext(rootContainerInstance) {\n  return { isInAParentText: false };\n}\n\nfunction getChildHostContext(parentHostContext, type, rootContainerInstance) {\n  var prevIsInAParentText = parentHostContext.isInAParentText;\n  var isInAParentText =\n    type === \"AndroidTextInput\" || // Android\n    type === \"RCTMultilineTextInputView\" || // iOS\n    type === \"RCTSinglelineTextInputView\" || // iOS\n    type === \"RCTText\" ||\n    type === \"RCTVirtualText\";\n\n  if (prevIsInAParentText !== isInAParentText) {\n    return { isInAParentText: isInAParentText };\n  } else {\n    return parentHostContext;\n  }\n}\n\nfunction getPublicInstance(instance) {\n  return instance;\n}\n\nfunction prepareForCommit(containerInfo) {\n  // Noop\n}\n\nfunction prepareUpdate(\n  instance,\n  type,\n  oldProps,\n  newProps,\n  rootContainerInstance,\n  hostContext\n) {\n  return emptyObject;\n}\n\nfunction resetAfterCommit(containerInfo) {\n  // Noop\n}\n\nvar now = now$1;\nvar isPrimaryRenderer = true;\nvar scheduleDeferredCallback = scheduleDeferredCallback$1;\nvar cancelDeferredCallback = cancelDeferredCallback$1;\n\nfunction shouldDeprioritizeSubtree(type, props) {\n  return false;\n}\n\nfunction shouldSetTextContent(type, props) {\n  // TODO (bvaughn) Revisit this decision.\n  // Always returning false simplifies the createInstance() implementation,\n  // But creates an additional child Fiber for raw text children.\n  // No additional native views are created though.\n  // It's not clear to me which is better so I'm deferring for now.\n  // More context @ github.com/facebook/react/pull/8560#discussion_r92111303\n  return false;\n}\n\n// -------------------\n//     Mutation\n// -------------------\n\nvar supportsMutation = true;\n\nfunction appendChild(parentInstance, child) {\n  var childTag = typeof child === \"number\" ? child : child._nativeTag;\n  var children = parentInstance._children;\n  var index = children.indexOf(child);\n\n  if (index >= 0) {\n    children.splice(index, 1);\n    children.push(child);\n\n    UIManager.manageChildren(\n      parentInstance._nativeTag, // containerTag\n      [index], // moveFromIndices\n      [children.length - 1], // moveToIndices\n      [], // addChildReactTags\n      [], // addAtIndices\n      [] // removeAtIndices\n    );\n  } else {\n    children.push(child);\n\n    UIManager.manageChildren(\n      parentInstance._nativeTag, // containerTag\n      [], // moveFromIndices\n      [], // moveToIndices\n      [childTag], // addChildReactTags\n      [children.length - 1], // addAtIndices\n      [] // removeAtIndices\n    );\n  }\n}\n\nfunction appendChildToContainer(parentInstance, child) {\n  var childTag = typeof child === \"number\" ? child : child._nativeTag;\n  UIManager.setChildren(\n    parentInstance, // containerTag\n    [childTag] // reactTags\n  );\n}\n\nfunction commitTextUpdate(textInstance, oldText, newText) {\n  UIManager.updateView(\n    textInstance, // reactTag\n    \"RCTRawText\", // viewName\n    { text: newText } // props\n  );\n}\n\nfunction commitUpdate(\n  instance,\n  updatePayloadTODO,\n  type,\n  oldProps,\n  newProps,\n  internalInstanceHandle\n) {\n  var viewConfig = instance.viewConfig;\n\n  updateFiberProps(instance._nativeTag, newProps);\n\n  var updatePayload = diff(oldProps, newProps, viewConfig.validAttributes);\n\n  // Avoid the overhead of bridge calls if there's no update.\n  // This is an expensive no-op for Android, and causes an unnecessary\n  // view invalidation for certain components (eg RCTTextInput) on iOS.\n  if (updatePayload != null) {\n    UIManager.updateView(\n      instance._nativeTag, // reactTag\n      viewConfig.uiViewClassName, // viewName\n      updatePayload // props\n    );\n  }\n}\n\nfunction insertBefore(parentInstance, child, beforeChild) {\n  var children = parentInstance._children;\n  var index = children.indexOf(child);\n\n  // Move existing child or add new child?\n  if (index >= 0) {\n    children.splice(index, 1);\n    var beforeChildIndex = children.indexOf(beforeChild);\n    children.splice(beforeChildIndex, 0, child);\n\n    UIManager.manageChildren(\n      parentInstance._nativeTag, // containerID\n      [index], // moveFromIndices\n      [beforeChildIndex], // moveToIndices\n      [], // addChildReactTags\n      [], // addAtIndices\n      [] // removeAtIndices\n    );\n  } else {\n    var _beforeChildIndex = children.indexOf(beforeChild);\n    children.splice(_beforeChildIndex, 0, child);\n\n    var childTag = typeof child === \"number\" ? child : child._nativeTag;\n\n    UIManager.manageChildren(\n      parentInstance._nativeTag, // containerID\n      [], // moveFromIndices\n      [], // moveToIndices\n      [childTag], // addChildReactTags\n      [_beforeChildIndex], // addAtIndices\n      [] // removeAtIndices\n    );\n  }\n}\n\nfunction insertInContainerBefore(parentInstance, child, beforeChild) {\n  // TODO (bvaughn): Remove this check when...\n  // We create a wrapper object for the container in ReactNative render()\n  // Or we refactor to remove wrapper objects entirely.\n  // For more info on pros/cons see PR #8560 description.\n  invariant(\n    typeof parentInstance !== \"number\",\n    \"Container does not support insertBefore operation\"\n  );\n}\n\nfunction removeChild(parentInstance, child) {\n  recursivelyUncacheFiberNode(child);\n  var children = parentInstance._children;\n  var index = children.indexOf(child);\n\n  children.splice(index, 1);\n\n  UIManager.manageChildren(\n    parentInstance._nativeTag, // containerID\n    [], // moveFromIndices\n    [], // moveToIndices\n    [], // addChildReactTags\n    [], // addAtIndices\n    [index] // removeAtIndices\n  );\n}\n\nfunction removeChildFromContainer(parentInstance, child) {\n  recursivelyUncacheFiberNode(child);\n  UIManager.manageChildren(\n    parentInstance, // containerID\n    [], // moveFromIndices\n    [], // moveToIndices\n    [], // addChildReactTags\n    [], // addAtIndices\n    [0] // removeAtIndices\n  );\n}\n\nfunction resetTextContent(instance) {\n  // Noop\n}\n\nvar describeComponentFrame = function(name, source, ownerName) {\n  return (\n    \"\\n    in \" +\n    (name || \"Unknown\") +\n    (source\n      ? \" (at \" +\n        source.fileName.replace(/^.*[\\\\\\/]/, \"\") +\n        \":\" +\n        source.lineNumber +\n        \")\"\n      : ownerName ? \" (created by \" + ownerName + \")\" : \"\")\n  );\n};\n\nfunction describeFiber(fiber) {\n  switch (fiber.tag) {\n    case IndeterminateComponent:\n    case FunctionalComponent:\n    case ClassComponent:\n    case HostComponent:\n      var owner = fiber._debugOwner;\n      var source = fiber._debugSource;\n      var name = getComponentName(fiber);\n      var ownerName = null;\n      if (owner) {\n        ownerName = getComponentName(owner);\n      }\n      return describeComponentFrame(name, source, ownerName);\n    default:\n      return \"\";\n  }\n}\n\n// This function can only be called with a work-in-progress fiber and\n// only during begin or complete phase. Do not call it under any other\n// circumstances.\nfunction getStackAddendumByWorkInProgressFiber(workInProgress) {\n  var info = \"\";\n  var node = workInProgress;\n  do {\n    info += describeFiber(node);\n    // Otherwise this return pointer might point to the wrong tree:\n    node = node.return;\n  } while (node);\n  return info;\n}\n\nfunction getCurrentFiberOwnerName() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    var owner = fiber._debugOwner;\n    if (owner !== null && typeof owner !== \"undefined\") {\n      return getComponentName(owner);\n    }\n  }\n  return null;\n}\n\nfunction getCurrentFiberStackAddendum() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    // Safe because if current fiber exists, we are reconciling,\n    // and it is guaranteed to be the work-in-progress version.\n    return getStackAddendumByWorkInProgressFiber(fiber);\n  }\n  return null;\n}\n\nfunction resetCurrentFiber() {\n  ReactDebugCurrentFrame.getCurrentStack = null;\n  ReactDebugCurrentFiber.current = null;\n  ReactDebugCurrentFiber.phase = null;\n}\n\nfunction setCurrentFiber(fiber) {\n  ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum;\n  ReactDebugCurrentFiber.current = fiber;\n  ReactDebugCurrentFiber.phase = null;\n}\n\nfunction setCurrentPhase(phase) {\n  ReactDebugCurrentFiber.phase = phase;\n}\n\nvar ReactDebugCurrentFiber = {\n  current: null,\n  phase: null,\n  resetCurrentFiber: resetCurrentFiber,\n  setCurrentFiber: setCurrentFiber,\n  setCurrentPhase: setCurrentPhase,\n  getCurrentFiberOwnerName: getCurrentFiberOwnerName,\n  getCurrentFiberStackAddendum: getCurrentFiberStackAddendum\n};\n\nvar debugRenderPhaseSideEffects = false;\nvar debugRenderPhaseSideEffectsForStrictMode = false;\nvar enableGetDerivedStateFromCatch = false;\nvar enableSuspense = false;\nvar enableUserTimingAPI = true;\nvar replayFailedUnitOfWorkWithInvokeGuardedCallback = true;\nvar warnAboutDeprecatedLifecycles = false;\nvar warnAboutLegacyContextAPI = false;\nvar enableProfilerTimer = true;\n\n// Only used in www builds.\n\n// Prefix measurements so that it's possible to filter them.\n// Longer prefixes are hard to read in DevTools.\nvar reactEmoji = \"\\u269B\";\nvar warningEmoji = \"\\u26D4\";\nvar supportsUserTiming =\n  typeof performance !== \"undefined\" &&\n  typeof performance.mark === \"function\" &&\n  typeof performance.clearMarks === \"function\" &&\n  typeof performance.measure === \"function\" &&\n  typeof performance.clearMeasures === \"function\";\n\n// Keep track of current fiber so that we know the path to unwind on pause.\n// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\nvar currentFiber = null;\n// If we're in the middle of user code, which fiber and method is it?\n// Reusing `currentFiber` would be confusing for this because user code fiber\n// can change during commit phase too, but we don't need to unwind it (since\n// lifecycles in the commit phase don't resemble a tree).\nvar currentPhase = null;\nvar currentPhaseFiber = null;\n// Did lifecycle hook schedule an update? This is often a performance problem,\n// so we will keep track of it, and include it in the report.\n// Track commits caused by cascading updates.\nvar isCommitting = false;\nvar hasScheduledUpdateInCurrentCommit = false;\nvar hasScheduledUpdateInCurrentPhase = false;\nvar commitCountInCurrentWorkLoop = 0;\nvar effectCountInCurrentCommit = 0;\nvar isWaitingForCallback = false;\n// During commits, we only show a measurement once per method name\n// to avoid stretch the commit phase with measurement overhead.\nvar labelsInCurrentCommit = new Set();\n\nvar formatMarkName = function(markName) {\n  return reactEmoji + \" \" + markName;\n};\n\nvar formatLabel = function(label, warning$$1) {\n  var prefix = warning$$1 ? warningEmoji + \" \" : reactEmoji + \" \";\n  var suffix = warning$$1 ? \" Warning: \" + warning$$1 : \"\";\n  return \"\" + prefix + label + suffix;\n};\n\nvar beginMark = function(markName) {\n  performance.mark(formatMarkName(markName));\n};\n\nvar clearMark = function(markName) {\n  performance.clearMarks(formatMarkName(markName));\n};\n\nvar endMark = function(label, markName, warning$$1) {\n  var formattedMarkName = formatMarkName(markName);\n  var formattedLabel = formatLabel(label, warning$$1);\n  try {\n    performance.measure(formattedLabel, formattedMarkName);\n  } catch (err) {}\n  // If previous mark was missing for some reason, this will throw.\n  // This could only happen if React crashed in an unexpected place earlier.\n  // Don't pile on with more errors.\n\n  // Clear marks immediately to avoid growing buffer.\n  performance.clearMarks(formattedMarkName);\n  performance.clearMeasures(formattedLabel);\n};\n\nvar getFiberMarkName = function(label, debugID) {\n  return label + \" (#\" + debugID + \")\";\n};\n\nvar getFiberLabel = function(componentName, isMounted, phase) {\n  if (phase === null) {\n    // These are composite component total time measurements.\n    return componentName + \" [\" + (isMounted ? \"update\" : \"mount\") + \"]\";\n  } else {\n    // Composite component methods.\n    return componentName + \".\" + phase;\n  }\n};\n\nvar beginFiberMark = function(fiber, phase) {\n  var componentName = getComponentName(fiber) || \"Unknown\";\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n\n  if (isCommitting && labelsInCurrentCommit.has(label)) {\n    // During the commit phase, we don't show duplicate labels because\n    // there is a fixed overhead for every measurement, and we don't\n    // want to stretch the commit phase beyond necessary.\n    return false;\n  }\n  labelsInCurrentCommit.add(label);\n\n  var markName = getFiberMarkName(label, debugID);\n  beginMark(markName);\n  return true;\n};\n\nvar clearFiberMark = function(fiber, phase) {\n  var componentName = getComponentName(fiber) || \"Unknown\";\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  clearMark(markName);\n};\n\nvar endFiberMark = function(fiber, phase, warning$$1) {\n  var componentName = getComponentName(fiber) || \"Unknown\";\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  endMark(label, markName, warning$$1);\n};\n\nvar shouldIgnoreFiber = function(fiber) {\n  // Host components should be skipped in the timeline.\n  // We could check typeof fiber.type, but does this work with RN?\n  switch (fiber.tag) {\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n    case Fragment:\n    case ContextProvider:\n    case ContextConsumer:\n    case Mode:\n      return true;\n    default:\n      return false;\n  }\n};\n\nvar clearPendingPhaseMeasurement = function() {\n  if (currentPhase !== null && currentPhaseFiber !== null) {\n    clearFiberMark(currentPhaseFiber, currentPhase);\n  }\n  currentPhaseFiber = null;\n  currentPhase = null;\n  hasScheduledUpdateInCurrentPhase = false;\n};\n\nvar pauseTimers = function() {\n  // Stops all currently active measurements so that they can be resumed\n  // if we continue in a later deferred loop from the same unit of work.\n  var fiber = currentFiber;\n  while (fiber) {\n    if (fiber._debugIsCurrentlyTiming) {\n      endFiberMark(fiber, null, null);\n    }\n    fiber = fiber.return;\n  }\n};\n\nvar resumeTimersRecursively = function(fiber) {\n  if (fiber.return !== null) {\n    resumeTimersRecursively(fiber.return);\n  }\n  if (fiber._debugIsCurrentlyTiming) {\n    beginFiberMark(fiber, null);\n  }\n};\n\nvar resumeTimers = function() {\n  // Resumes all measurements that were active during the last deferred loop.\n  if (currentFiber !== null) {\n    resumeTimersRecursively(currentFiber);\n  }\n};\n\nfunction recordEffect() {\n  if (enableUserTimingAPI) {\n    effectCountInCurrentCommit++;\n  }\n}\n\nfunction recordScheduleUpdate() {\n  if (enableUserTimingAPI) {\n    if (isCommitting) {\n      hasScheduledUpdateInCurrentCommit = true;\n    }\n    if (\n      currentPhase !== null &&\n      currentPhase !== \"componentWillMount\" &&\n      currentPhase !== \"componentWillReceiveProps\"\n    ) {\n      hasScheduledUpdateInCurrentPhase = true;\n    }\n  }\n}\n\nfunction startRequestCallbackTimer() {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming && !isWaitingForCallback) {\n      isWaitingForCallback = true;\n      beginMark(\"(Waiting for async callback...)\");\n    }\n  }\n}\n\nfunction stopRequestCallbackTimer(didExpire, expirationTime) {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming) {\n      isWaitingForCallback = false;\n      var warning$$1 = didExpire ? \"React was blocked by main thread\" : null;\n      endMark(\n        \"(Waiting for async callback... will force flush in \" +\n          expirationTime +\n          \" ms)\",\n        \"(Waiting for async callback...)\",\n        warning$$1\n      );\n    }\n  }\n}\n\nfunction startWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, this is the fiber to unwind from.\n    currentFiber = fiber;\n    if (!beginFiberMark(fiber, null)) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = true;\n  }\n}\n\nfunction cancelWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // Remember we shouldn't complete measurement for this fiber.\n    // Otherwise flamechart will be deep even for small updates.\n    fiber._debugIsCurrentlyTiming = false;\n    clearFiberMark(fiber, null);\n  }\n}\n\nfunction stopWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber.return;\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    endFiberMark(fiber, null, null);\n  }\n}\n\nfunction stopFailedWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber.return;\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    var warning$$1 = \"An error was thrown inside this error boundary\";\n    endFiberMark(fiber, null, warning$$1);\n  }\n}\n\nfunction startPhaseTimer(fiber, phase) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    clearPendingPhaseMeasurement();\n    if (!beginFiberMark(fiber, phase)) {\n      return;\n    }\n    currentPhaseFiber = fiber;\n    currentPhase = phase;\n  }\n}\n\nfunction stopPhaseTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    if (currentPhase !== null && currentPhaseFiber !== null) {\n      var warning$$1 = hasScheduledUpdateInCurrentPhase\n        ? \"Scheduled a cascading update\"\n        : null;\n      endFiberMark(currentPhaseFiber, currentPhase, warning$$1);\n    }\n    currentPhase = null;\n    currentPhaseFiber = null;\n  }\n}\n\nfunction startWorkLoopTimer(nextUnitOfWork) {\n  if (enableUserTimingAPI) {\n    currentFiber = nextUnitOfWork;\n    if (!supportsUserTiming) {\n      return;\n    }\n    commitCountInCurrentWorkLoop = 0;\n    // This is top level call.\n    // Any other measurements are performed within.\n    beginMark(\"(React Tree Reconciliation)\");\n    // Resume any measurements that were in progress during the last loop.\n    resumeTimers();\n  }\n}\n\nfunction stopWorkLoopTimer(interruptedBy, didCompleteRoot) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var warning$$1 = null;\n    if (interruptedBy !== null) {\n      if (interruptedBy.tag === HostRoot) {\n        warning$$1 = \"A top-level update interrupted the previous render\";\n      } else {\n        var componentName = getComponentName(interruptedBy) || \"Unknown\";\n        warning$$1 =\n          \"An update to \" + componentName + \" interrupted the previous render\";\n      }\n    } else if (commitCountInCurrentWorkLoop > 1) {\n      warning$$1 = \"There were cascading updates\";\n    }\n    commitCountInCurrentWorkLoop = 0;\n    var label = didCompleteRoot\n      ? \"(React Tree Reconciliation: Completed Root)\"\n      : \"(React Tree Reconciliation: Yielded)\";\n    // Pause any measurements until the next loop.\n    pauseTimers();\n    endMark(label, \"(React Tree Reconciliation)\", warning$$1);\n  }\n}\n\nfunction startCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    isCommitting = true;\n    hasScheduledUpdateInCurrentCommit = false;\n    labelsInCurrentCommit.clear();\n    beginMark(\"(Committing Changes)\");\n  }\n}\n\nfunction stopCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    var warning$$1 = null;\n    if (hasScheduledUpdateInCurrentCommit) {\n      warning$$1 = \"Lifecycle hook scheduled a cascading update\";\n    } else if (commitCountInCurrentWorkLoop > 0) {\n      warning$$1 = \"Caused by a cascading update in earlier commit\";\n    }\n    hasScheduledUpdateInCurrentCommit = false;\n    commitCountInCurrentWorkLoop++;\n    isCommitting = false;\n    labelsInCurrentCommit.clear();\n\n    endMark(\"(Committing Changes)\", \"(Committing Changes)\", warning$$1);\n  }\n}\n\nfunction startCommitSnapshotEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark(\"(Committing Snapshot Effects)\");\n  }\n}\n\nfunction stopCommitSnapshotEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark(\n      \"(Committing Snapshot Effects: \" + count + \" Total)\",\n      \"(Committing Snapshot Effects)\",\n      null\n    );\n  }\n}\n\nfunction startCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark(\"(Committing Host Effects)\");\n  }\n}\n\nfunction stopCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark(\n      \"(Committing Host Effects: \" + count + \" Total)\",\n      \"(Committing Host Effects)\",\n      null\n    );\n  }\n}\n\nfunction startCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark(\"(Calling Lifecycle Methods)\");\n  }\n}\n\nfunction stopCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark(\n      \"(Calling Lifecycle Methods: \" + count + \" Total)\",\n      \"(Calling Lifecycle Methods)\",\n      null\n    );\n  }\n}\n\nvar valueStack = [];\n\nvar fiberStack = void 0;\n\n{\n  fiberStack = [];\n}\n\nvar index = -1;\n\nfunction createCursor(defaultValue) {\n  return {\n    current: defaultValue\n  };\n}\n\nfunction pop(cursor, fiber) {\n  if (index < 0) {\n    {\n      warning(false, \"Unexpected pop.\");\n    }\n    return;\n  }\n\n  {\n    if (fiber !== fiberStack[index]) {\n      warning(false, \"Unexpected Fiber popped.\");\n    }\n  }\n\n  cursor.current = valueStack[index];\n\n  valueStack[index] = null;\n\n  {\n    fiberStack[index] = null;\n  }\n\n  index--;\n}\n\nfunction push(cursor, value, fiber) {\n  index++;\n\n  valueStack[index] = cursor.current;\n\n  {\n    fiberStack[index] = fiber;\n  }\n\n  cursor.current = value;\n}\n\nfunction checkThatStackIsEmpty() {\n  {\n    if (index !== -1) {\n      warning(\n        false,\n        \"Expected an empty stack. Something was not reset properly.\"\n      );\n    }\n  }\n}\n\nfunction resetStackAfterFatalErrorInDev() {\n  {\n    index = -1;\n    valueStack.length = 0;\n    fiberStack.length = 0;\n  }\n}\n\nvar warnedAboutMissingGetChildContext = void 0;\n\n{\n  warnedAboutMissingGetChildContext = {};\n}\n\n// A cursor to the current merged context object on the stack.\nvar contextStackCursor = createCursor(emptyObject);\n// A cursor to a boolean indicating whether the context has changed.\nvar didPerformWorkStackCursor = createCursor(false);\n// Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\nvar previousContext = emptyObject;\n\nfunction getUnmaskedContext(workInProgress) {\n  var hasOwnContext = isContextProvider(workInProgress);\n  if (hasOwnContext) {\n    // If the fiber is a context provider itself, when we read its context\n    // we have already pushed its own child context on the stack. A context\n    // provider should not \"see\" its own child context. Therefore we read the\n    // previous (parent) context instead for a context provider.\n    return previousContext;\n  }\n  return contextStackCursor.current;\n}\n\nfunction cacheContext(workInProgress, unmaskedContext, maskedContext) {\n  var instance = workInProgress.stateNode;\n  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n}\n\nfunction getMaskedContext(workInProgress, unmaskedContext) {\n  var type = workInProgress.type;\n  var contextTypes = type.contextTypes;\n  if (!contextTypes) {\n    return emptyObject;\n  }\n\n  // Avoid recreating masked context unless unmasked context has changed.\n  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n  // This may trigger infinite loops if componentWillReceiveProps calls setState.\n  var instance = workInProgress.stateNode;\n  if (\n    instance &&\n    instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext\n  ) {\n    return instance.__reactInternalMemoizedMaskedChildContext;\n  }\n\n  var context = {};\n  for (var key in contextTypes) {\n    context[key] = unmaskedContext[key];\n  }\n\n  {\n    var name = getComponentName(workInProgress) || \"Unknown\";\n    checkPropTypes(\n      contextTypes,\n      context,\n      \"context\",\n      name,\n      ReactDebugCurrentFiber.getCurrentFiberStackAddendum\n    );\n  }\n\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // Context is created before the class component is instantiated so check for instance.\n  if (instance) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return context;\n}\n\nfunction hasContextChanged() {\n  return didPerformWorkStackCursor.current;\n}\n\nfunction isContextConsumer(fiber) {\n  return fiber.tag === ClassComponent && fiber.type.contextTypes != null;\n}\n\nfunction isContextProvider(fiber) {\n  return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;\n}\n\nfunction popContextProvider(fiber) {\n  if (!isContextProvider(fiber)) {\n    return;\n  }\n\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction popTopLevelContextObject(fiber) {\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction pushTopLevelContextObject(fiber, context, didChange) {\n  invariant(\n    contextStackCursor.current === emptyObject,\n    \"Unexpected context found on stack. \" +\n      \"This error is likely caused by a bug in React. Please file an issue.\"\n  );\n\n  push(contextStackCursor, context, fiber);\n  push(didPerformWorkStackCursor, didChange, fiber);\n}\n\nfunction processChildContext(fiber, parentContext) {\n  var instance = fiber.stateNode;\n  var childContextTypes = fiber.type.childContextTypes;\n\n  // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n  // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n  if (typeof instance.getChildContext !== \"function\") {\n    {\n      var componentName = getComponentName(fiber) || \"Unknown\";\n\n      if (!warnedAboutMissingGetChildContext[componentName]) {\n        warnedAboutMissingGetChildContext[componentName] = true;\n        warning(\n          false,\n          \"%s.childContextTypes is specified but there is no getChildContext() method \" +\n            \"on the instance. You can either define getChildContext() on %s or remove \" +\n            \"childContextTypes from it.\",\n          componentName,\n          componentName\n        );\n      }\n    }\n    return parentContext;\n  }\n\n  var childContext = void 0;\n  {\n    ReactDebugCurrentFiber.setCurrentPhase(\"getChildContext\");\n  }\n  startPhaseTimer(fiber, \"getChildContext\");\n  childContext = instance.getChildContext();\n  stopPhaseTimer();\n  {\n    ReactDebugCurrentFiber.setCurrentPhase(null);\n  }\n  for (var contextKey in childContext) {\n    invariant(\n      contextKey in childContextTypes,\n      '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.',\n      getComponentName(fiber) || \"Unknown\",\n      contextKey\n    );\n  }\n  {\n    var name = getComponentName(fiber) || \"Unknown\";\n    checkPropTypes(\n      childContextTypes,\n      childContext,\n      \"child context\",\n      name,\n      // In practice, there is one case in which we won't get a stack. It's when\n      // somebody calls unstable_renderSubtreeIntoContainer() and we process\n      // context from the parent component instance. The stack will be missing\n      // because it's outside of the reconciliation, and so the pointer has not\n      // been set. This is rare and doesn't matter. We'll also remove that API.\n      ReactDebugCurrentFiber.getCurrentFiberStackAddendum\n    );\n  }\n\n  return Object.assign({}, parentContext, childContext);\n}\n\nfunction pushContextProvider(workInProgress) {\n  if (!isContextProvider(workInProgress)) {\n    return false;\n  }\n\n  var instance = workInProgress.stateNode;\n  // We push the context as early as possible to ensure stack integrity.\n  // If the instance does not exist yet, we will push null at first,\n  // and replace it on the stack later when invalidating the context.\n  var memoizedMergedChildContext =\n    (instance && instance.__reactInternalMemoizedMergedChildContext) ||\n    emptyObject;\n\n  // Remember the parent context so we can merge with it later.\n  // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n  previousContext = contextStackCursor.current;\n  push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n  push(\n    didPerformWorkStackCursor,\n    didPerformWorkStackCursor.current,\n    workInProgress\n  );\n\n  return true;\n}\n\nfunction invalidateContextProvider(workInProgress, didChange) {\n  var instance = workInProgress.stateNode;\n  invariant(\n    instance,\n    \"Expected to have an instance by this point. \" +\n      \"This error is likely caused by a bug in React. Please file an issue.\"\n  );\n\n  if (didChange) {\n    // Merge parent and own context.\n    // Skip this if we're not updating due to sCU.\n    // This avoids unnecessarily recomputing memoized values.\n    var mergedContext = processChildContext(workInProgress, previousContext);\n    instance.__reactInternalMemoizedMergedChildContext = mergedContext;\n\n    // Replace the old (or empty) context with the new one.\n    // It is important to unwind the context in the reverse order.\n    pop(didPerformWorkStackCursor, workInProgress);\n    pop(contextStackCursor, workInProgress);\n    // Now push the new context and mark that it has changed.\n    push(contextStackCursor, mergedContext, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  } else {\n    pop(didPerformWorkStackCursor, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  }\n}\n\nfunction findCurrentUnmaskedContext(fiber) {\n  // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n  // makes sense elsewhere\n  invariant(\n    isFiberMounted(fiber) && fiber.tag === ClassComponent,\n    \"Expected subtree parent to be a mounted class component. \" +\n      \"This error is likely caused by a bug in React. Please file an issue.\"\n  );\n\n  var node = fiber;\n  while (node.tag !== HostRoot) {\n    if (isContextProvider(node)) {\n      return node.stateNode.__reactInternalMemoizedMergedChildContext;\n    }\n    var parent = node.return;\n    invariant(\n      parent,\n      \"Found unexpected detached subtree parent. \" +\n        \"This error is likely caused by a bug in React. Please file an issue.\"\n    );\n    node = parent;\n  }\n  return node.stateNode.context;\n}\n\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nvar MAX_SIGNED_31_BIT_INT = 1073741823;\n\nvar NoWork = 0;\nvar Sync = 1;\nvar Never = MAX_SIGNED_31_BIT_INT;\n\nvar UNIT_SIZE = 10;\nvar MAGIC_NUMBER_OFFSET = 2;\n\n// 1 unit of expiration time represents 10ms.\nfunction msToExpirationTime(ms) {\n  // Always add an offset so that we don't clash with the magic number for NoWork.\n  return ((ms / UNIT_SIZE) | 0) + MAGIC_NUMBER_OFFSET;\n}\n\nfunction expirationTimeToMs(expirationTime) {\n  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;\n}\n\nfunction ceiling(num, precision) {\n  return (((num / precision) | 0) + 1) * precision;\n}\n\nfunction computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {\n  return (\n    MAGIC_NUMBER_OFFSET +\n    ceiling(\n      currentTime - MAGIC_NUMBER_OFFSET + expirationInMs / UNIT_SIZE,\n      bucketSizeMs / UNIT_SIZE\n    )\n  );\n}\n\nvar NoContext = 0;\nvar AsyncMode = 1;\nvar StrictMode = 2;\nvar ProfileMode = 4;\n\nvar hasBadMapPolyfill = void 0;\n\n{\n  hasBadMapPolyfill = false;\n  try {\n    var nonExtensibleObject = Object.preventExtensions({});\n    var testMap = new Map([[nonExtensibleObject, null]]);\n    var testSet = new Set([nonExtensibleObject]);\n    // This is necessary for Rollup to not consider these unused.\n    // https://github.com/rollup/rollup/issues/1771\n    // TODO: we can remove these if Rollup fixes the bug.\n    testMap.set(0, 0);\n    testSet.add(0);\n  } catch (e) {\n    // TODO: Consider warning about bad polyfills\n    hasBadMapPolyfill = true;\n  }\n}\n\n// A Fiber is work on a Component that needs to be done or was done. There can\n// be more than one per component.\n\nvar debugCounter = void 0;\n\n{\n  debugCounter = 1;\n}\n\nfunction FiberNode(tag, pendingProps, key, mode) {\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.type = null;\n  this.stateNode = null;\n\n  // Fiber\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n\n  this.mode = mode;\n\n  // Effects\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  this.expirationTime = NoWork;\n\n  this.alternate = null;\n\n  if (enableProfilerTimer) {\n    this.actualDuration = 0;\n    this.actualStartTime = 0;\n    this.selfBaseTime = 0;\n    this.treeBaseTime = 0;\n  }\n\n  {\n    this._debugID = debugCounter++;\n    this._debugSource = null;\n    this._debugOwner = null;\n    this._debugIsCurrentlyTiming = false;\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === \"function\") {\n      Object.preventExtensions(this);\n    }\n  }\n}\n\n// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber = function(tag, pendingProps, key, mode) {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, pendingProps, key, mode);\n};\n\nfunction shouldConstruct(Component) {\n  return !!(Component.prototype && Component.prototype.isReactComponent);\n}\n\n// This is used to create an alternate fiber to do work on.\nfunction createWorkInProgress(current, pendingProps, expirationTime) {\n  var workInProgress = current.alternate;\n  if (workInProgress === null) {\n    // We use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. We pool the \"other\" unused\n    // node that we're free to reuse. This is lazily created to avoid allocating\n    // extra objects for things that are never updated. It also allow us to\n    // reclaim the extra memory if needed.\n    workInProgress = createFiber(\n      current.tag,\n      pendingProps,\n      current.key,\n      current.mode\n    );\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n\n    {\n      // DEV-only fields\n      workInProgress._debugID = current._debugID;\n      workInProgress._debugSource = current._debugSource;\n      workInProgress._debugOwner = current._debugOwner;\n    }\n\n    workInProgress.alternate = current;\n    current.alternate = workInProgress;\n  } else {\n    workInProgress.pendingProps = pendingProps;\n\n    // We already have an alternate.\n    // Reset the effect tag.\n    workInProgress.effectTag = NoEffect;\n\n    // The effect list is no longer valid.\n    workInProgress.nextEffect = null;\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n\n    if (enableProfilerTimer) {\n      // We intentionally reset, rather than copy, actualDuration & actualStartTime.\n      // This prevents time from endlessly accumulating in new commits.\n      // This has the downside of resetting values for different priority renders,\n      // But works for yielding (the common case) and should support resuming.\n      workInProgress.actualDuration = 0;\n      workInProgress.actualStartTime = 0;\n    }\n  }\n\n  workInProgress.expirationTime = expirationTime;\n\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n\n  // These will be overridden during the parent's reconciliation\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n\n  if (enableProfilerTimer) {\n    workInProgress.selfBaseTime = current.selfBaseTime;\n    workInProgress.treeBaseTime = current.treeBaseTime;\n  }\n\n  return workInProgress;\n}\n\nfunction createHostRootFiber(isAsync) {\n  var mode = isAsync ? AsyncMode | StrictMode : NoContext;\n  return createFiber(HostRoot, null, null, mode);\n}\n\nfunction createFiberFromElement(element, mode, expirationTime) {\n  var owner = null;\n  {\n    owner = element._owner;\n  }\n\n  var fiber = void 0;\n  var type = element.type;\n  var key = element.key;\n  var pendingProps = element.props;\n\n  var fiberTag = void 0;\n  if (typeof type === \"function\") {\n    fiberTag = shouldConstruct(type) ? ClassComponent : IndeterminateComponent;\n  } else if (typeof type === \"string\") {\n    fiberTag = HostComponent;\n  } else {\n    switch (type) {\n      case REACT_FRAGMENT_TYPE:\n        return createFiberFromFragment(\n          pendingProps.children,\n          mode,\n          expirationTime,\n          key\n        );\n      case REACT_ASYNC_MODE_TYPE:\n        fiberTag = Mode;\n        mode |= AsyncMode | StrictMode;\n        break;\n      case REACT_STRICT_MODE_TYPE:\n        fiberTag = Mode;\n        mode |= StrictMode;\n        break;\n      case REACT_PROFILER_TYPE:\n        return createFiberFromProfiler(pendingProps, mode, expirationTime, key);\n      case REACT_TIMEOUT_TYPE:\n        fiberTag = TimeoutComponent;\n        // Suspense does not require async, but its children should be strict\n        // mode compatible.\n        mode |= StrictMode;\n        break;\n      default:\n        fiberTag = getFiberTagFromObjectType(type, owner);\n        break;\n    }\n  }\n\n  fiber = createFiber(fiberTag, pendingProps, key, mode);\n  fiber.type = type;\n  fiber.expirationTime = expirationTime;\n\n  {\n    fiber._debugSource = element._source;\n    fiber._debugOwner = element._owner;\n  }\n\n  return fiber;\n}\n\nfunction getFiberTagFromObjectType(type, owner) {\n  var $$typeof =\n    typeof type === \"object\" && type !== null ? type.$$typeof : null;\n\n  switch ($$typeof) {\n    case REACT_PROVIDER_TYPE:\n      return ContextProvider;\n    case REACT_CONTEXT_TYPE:\n      // This is a consumer\n      return ContextConsumer;\n    case REACT_FORWARD_REF_TYPE:\n      return ForwardRef;\n    default: {\n      var info = \"\";\n      {\n        if (\n          type === undefined ||\n          (typeof type === \"object\" &&\n            type !== null &&\n            Object.keys(type).length === 0)\n        ) {\n          info +=\n            \" You likely forgot to export your component from the file \" +\n            \"it's defined in, or you might have mixed up default and \" +\n            \"named imports.\";\n        }\n        var ownerName = owner ? getComponentName(owner) : null;\n        if (ownerName) {\n          info += \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n        }\n      }\n      invariant(\n        false,\n        \"Element type is invalid: expected a string (for built-in \" +\n          \"components) or a class/function (for composite components) \" +\n          \"but got: %s.%s\",\n        type == null ? type : typeof type,\n        info\n      );\n    }\n  }\n}\n\nfunction createFiberFromFragment(elements, mode, expirationTime, key) {\n  var fiber = createFiber(Fragment, elements, key, mode);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromProfiler(pendingProps, mode, expirationTime, key) {\n  {\n    if (\n      typeof pendingProps.id !== \"string\" ||\n      typeof pendingProps.onRender !== \"function\"\n    ) {\n      invariant(\n        false,\n        'Profiler must specify an \"id\" string and \"onRender\" function as props'\n      );\n    }\n  }\n\n  var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);\n  fiber.type = REACT_PROFILER_TYPE;\n  fiber.expirationTime = expirationTime;\n\n  return fiber;\n}\n\nfunction createFiberFromText(content, mode, expirationTime) {\n  var fiber = createFiber(HostText, content, null, mode);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromHostInstanceForDeletion() {\n  var fiber = createFiber(HostComponent, null, null, NoContext);\n  fiber.type = \"DELETED\";\n  return fiber;\n}\n\nfunction createFiberFromPortal(portal, mode, expirationTime) {\n  var pendingProps = portal.children !== null ? portal.children : [];\n  var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n  fiber.expirationTime = expirationTime;\n  fiber.stateNode = {\n    containerInfo: portal.containerInfo,\n    pendingChildren: null, // Used by persistent updates\n    implementation: portal.implementation\n  };\n  return fiber;\n}\n\n// Used for stashing WIP properties to replay failed work in DEV.\nfunction assignFiberPropertiesInDEV(target, source) {\n  if (target === null) {\n    // This Fiber's initial properties will always be overwritten.\n    // We only use a Fiber to ensure the same hidden class so DEV isn't slow.\n    target = createFiber(IndeterminateComponent, null, null, NoContext);\n  }\n\n  // This is intentionally written as a list of all properties.\n  // We tried to use Object.assign() instead but this is called in\n  // the hottest path, and Object.assign() was too slow:\n  // https://github.com/facebook/react/issues/12502\n  // This code is DEV-only so size is not a concern.\n\n  target.tag = source.tag;\n  target.key = source.key;\n  target.type = source.type;\n  target.stateNode = source.stateNode;\n  target.return = source.return;\n  target.child = source.child;\n  target.sibling = source.sibling;\n  target.index = source.index;\n  target.ref = source.ref;\n  target.pendingProps = source.pendingProps;\n  target.memoizedProps = source.memoizedProps;\n  target.updateQueue = source.updateQueue;\n  target.memoizedState = source.memoizedState;\n  target.mode = source.mode;\n  target.effectTag = source.effectTag;\n  target.nextEffect = source.nextEffect;\n  target.firstEffect = source.firstEffect;\n  target.lastEffect = source.lastEffect;\n  target.expirationTime = source.expirationTime;\n  target.alternate = source.alternate;\n  if (enableProfilerTimer) {\n    target.actualDuration = source.actualDuration;\n    target.actualStartTime = source.actualStartTime;\n    target.selfBaseTime = source.selfBaseTime;\n    target.treeBaseTime = source.treeBaseTime;\n  }\n  target._debugID = source._debugID;\n  target._debugSource = source._debugSource;\n  target._debugOwner = source._debugOwner;\n  target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;\n  return target;\n}\n\n// TODO: This should be lifted into the renderer.\n\nfunction createFiberRoot(containerInfo, isAsync, hydrate) {\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  var uninitializedFiber = createHostRootFiber(isAsync);\n  var root = {\n    current: uninitializedFiber,\n    containerInfo: containerInfo,\n    pendingChildren: null,\n\n    earliestPendingTime: NoWork,\n    latestPendingTime: NoWork,\n    earliestSuspendedTime: NoWork,\n    latestSuspendedTime: NoWork,\n    latestPingedTime: NoWork,\n\n    didError: false,\n\n    pendingCommitExpirationTime: NoWork,\n    finishedWork: null,\n    context: null,\n    pendingContext: null,\n    hydrate: hydrate,\n    nextExpirationTimeToWorkOn: NoWork,\n    expirationTime: NoWork,\n    firstBatch: null,\n    nextScheduledRoot: null\n  };\n  uninitializedFiber.stateNode = root;\n  return root;\n}\n\nvar onCommitFiberRoot = null;\nvar onCommitFiberUnmount = null;\nvar hasLoggedError = false;\n\nfunction catchErrors(fn) {\n  return function(arg) {\n    try {\n      return fn(arg);\n    } catch (err) {\n      if (true && !hasLoggedError) {\n        hasLoggedError = true;\n        warning(false, \"React DevTools encountered an error: %s\", err);\n      }\n    }\n  };\n}\n\nfunction injectInternals(internals) {\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\") {\n    // No DevTools\n    return false;\n  }\n  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n  if (hook.isDisabled) {\n    // This isn't a real property on the hook, but it can be set to opt out\n    // of DevTools integration and associated warnings and logs.\n    // https://github.com/facebook/react/issues/3877\n    return true;\n  }\n  if (!hook.supportsFiber) {\n    {\n      warning(\n        false,\n        \"The installed version of React DevTools is too old and will not work \" +\n          \"with the current version of React. Please update React DevTools. \" +\n          \"https://fb.me/react-devtools\"\n      );\n    }\n    // DevTools exists, even though it doesn't support Fiber.\n    return true;\n  }\n  try {\n    var rendererID = hook.inject(internals);\n    // We have successfully injected, so now it is safe to set up hooks.\n    onCommitFiberRoot = catchErrors(function(root) {\n      return hook.onCommitFiberRoot(rendererID, root);\n    });\n    onCommitFiberUnmount = catchErrors(function(fiber) {\n      return hook.onCommitFiberUnmount(rendererID, fiber);\n    });\n  } catch (err) {\n    // Catch all errors because it is unsafe to throw during initialization.\n    {\n      warning(false, \"React DevTools encountered an error: %s.\", err);\n    }\n  }\n  // DevTools exists\n  return true;\n}\n\nfunction onCommitRoot(root) {\n  if (typeof onCommitFiberRoot === \"function\") {\n    onCommitFiberRoot(root);\n  }\n}\n\nfunction onCommitUnmount(fiber) {\n  if (typeof onCommitFiberUnmount === \"function\") {\n    onCommitFiberUnmount(fiber);\n  }\n}\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar lowPriorityWarning = function() {};\n\n{\n  var printWarning = function(format) {\n    for (\n      var _len = arguments.length,\n        args = Array(_len > 1 ? _len - 1 : 0),\n        _key = 1;\n      _key < _len;\n      _key++\n    ) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message =\n      \"Warning: \" +\n      format.replace(/%s/g, function() {\n        return args[argIndex++];\n      });\n    if (typeof console !== \"undefined\") {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning = function(condition, format) {\n    if (format === undefined) {\n      throw new Error(\n        \"`warning(condition, format, ...args)` requires a warning \" +\n          \"message argument\"\n      );\n    }\n    if (!condition) {\n      for (\n        var _len2 = arguments.length,\n          args = Array(_len2 > 2 ? _len2 - 2 : 0),\n          _key2 = 2;\n        _key2 < _len2;\n        _key2++\n      ) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarning$1 = lowPriorityWarning;\n\nvar ReactStrictModeWarnings = {\n  discardPendingWarnings: function() {},\n  flushPendingDeprecationWarnings: function() {},\n  flushPendingUnsafeLifecycleWarnings: function() {},\n  recordDeprecationWarnings: function(fiber, instance) {},\n  recordUnsafeLifecycleWarnings: function(fiber, instance) {},\n  recordLegacyContextWarning: function(fiber, instance) {},\n  flushLegacyContextWarning: function() {}\n};\n\n{\n  var LIFECYCLE_SUGGESTIONS = {\n    UNSAFE_componentWillMount: \"componentDidMount\",\n    UNSAFE_componentWillReceiveProps: \"static getDerivedStateFromProps\",\n    UNSAFE_componentWillUpdate: \"componentDidUpdate\"\n  };\n\n  var pendingComponentWillMountWarnings = [];\n  var pendingComponentWillReceivePropsWarnings = [];\n  var pendingComponentWillUpdateWarnings = [];\n  var pendingUnsafeLifecycleWarnings = new Map();\n  var pendingLegacyContextWarning = new Map();\n\n  // Tracks components we have already warned about.\n  var didWarnAboutDeprecatedLifecycles = new Set();\n  var didWarnAboutUnsafeLifecycles = new Set();\n  var didWarnAboutLegacyContext = new Set();\n\n  var setToSortedString = function(set) {\n    var array = [];\n    set.forEach(function(value) {\n      array.push(value);\n    });\n    return array.sort().join(\", \");\n  };\n\n  ReactStrictModeWarnings.discardPendingWarnings = function() {\n    pendingComponentWillMountWarnings = [];\n    pendingComponentWillReceivePropsWarnings = [];\n    pendingComponentWillUpdateWarnings = [];\n    pendingUnsafeLifecycleWarnings = new Map();\n    pendingLegacyContextWarning = new Map();\n  };\n\n  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {\n    pendingUnsafeLifecycleWarnings.forEach(function(\n      lifecycleWarningsMap,\n      strictRoot\n    ) {\n      var lifecyclesWarningMesages = [];\n\n      Object.keys(lifecycleWarningsMap).forEach(function(lifecycle) {\n        var lifecycleWarnings = lifecycleWarningsMap[lifecycle];\n        if (lifecycleWarnings.length > 0) {\n          var componentNames = new Set();\n          lifecycleWarnings.forEach(function(fiber) {\n            componentNames.add(getComponentName(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n          });\n\n          var formatted = lifecycle.replace(\"UNSAFE_\", \"\");\n          var suggestion = LIFECYCLE_SUGGESTIONS[lifecycle];\n          var sortedComponentNames = setToSortedString(componentNames);\n\n          lifecyclesWarningMesages.push(\n            formatted +\n              \": Please update the following components to use \" +\n              (suggestion + \" instead: \" + sortedComponentNames)\n          );\n        }\n      });\n\n      if (lifecyclesWarningMesages.length > 0) {\n        var strictRootComponentStack = getStackAddendumByWorkInProgressFiber(\n          strictRoot\n        );\n\n        warning(\n          false,\n          \"Unsafe lifecycle methods were found within a strict-mode tree:%s\" +\n            \"\\n\\n%s\" +\n            \"\\n\\nLearn more about this warning here:\" +\n            \"\\nhttps://fb.me/react-strict-mode-warnings\",\n          strictRootComponentStack,\n          lifecyclesWarningMesages.join(\"\\n\\n\")\n        );\n      }\n    });\n\n    pendingUnsafeLifecycleWarnings = new Map();\n  };\n\n  var findStrictRoot = function(fiber) {\n    var maybeStrictRoot = null;\n\n    var node = fiber;\n    while (node !== null) {\n      if (node.mode & StrictMode) {\n        maybeStrictRoot = node;\n      }\n      node = node.return;\n    }\n\n    return maybeStrictRoot;\n  };\n\n  ReactStrictModeWarnings.flushPendingDeprecationWarnings = function() {\n    if (pendingComponentWillMountWarnings.length > 0) {\n      var uniqueNames = new Set();\n      pendingComponentWillMountWarnings.forEach(function(fiber) {\n        uniqueNames.add(getComponentName(fiber) || \"Component\");\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var sortedNames = setToSortedString(uniqueNames);\n\n      lowPriorityWarning$1(\n        false,\n        \"componentWillMount is deprecated and will be removed in the next major version. \" +\n          \"Use componentDidMount instead. As a temporary workaround, \" +\n          \"you can rename to UNSAFE_componentWillMount.\" +\n          \"\\n\\nPlease update the following components: %s\" +\n          \"\\n\\nLearn more about this warning here:\" +\n          \"\\nhttps://fb.me/react-async-component-lifecycle-hooks\",\n        sortedNames\n      );\n\n      pendingComponentWillMountWarnings = [];\n    }\n\n    if (pendingComponentWillReceivePropsWarnings.length > 0) {\n      var _uniqueNames = new Set();\n      pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {\n        _uniqueNames.add(getComponentName(fiber) || \"Component\");\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var _sortedNames = setToSortedString(_uniqueNames);\n\n      lowPriorityWarning$1(\n        false,\n        \"componentWillReceiveProps is deprecated and will be removed in the next major version. \" +\n          \"Use static getDerivedStateFromProps instead.\" +\n          \"\\n\\nPlease update the following components: %s\" +\n          \"\\n\\nLearn more about this warning here:\" +\n          \"\\nhttps://fb.me/react-async-component-lifecycle-hooks\",\n        _sortedNames\n      );\n\n      pendingComponentWillReceivePropsWarnings = [];\n    }\n\n    if (pendingComponentWillUpdateWarnings.length > 0) {\n      var _uniqueNames2 = new Set();\n      pendingComponentWillUpdateWarnings.forEach(function(fiber) {\n        _uniqueNames2.add(getComponentName(fiber) || \"Component\");\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var _sortedNames2 = setToSortedString(_uniqueNames2);\n\n      lowPriorityWarning$1(\n        false,\n        \"componentWillUpdate is deprecated and will be removed in the next major version. \" +\n          \"Use componentDidUpdate instead. As a temporary workaround, \" +\n          \"you can rename to UNSAFE_componentWillUpdate.\" +\n          \"\\n\\nPlease update the following components: %s\" +\n          \"\\n\\nLearn more about this warning here:\" +\n          \"\\nhttps://fb.me/react-async-component-lifecycle-hooks\",\n        _sortedNames2\n      );\n\n      pendingComponentWillUpdateWarnings = [];\n    }\n  };\n\n  ReactStrictModeWarnings.recordDeprecationWarnings = function(\n    fiber,\n    instance\n  ) {\n    // Dedup strategy: Warn once per component.\n    if (didWarnAboutDeprecatedLifecycles.has(fiber.type)) {\n      return;\n    }\n\n    // Don't warn about react-lifecycles-compat polyfilled components.\n    if (\n      typeof instance.componentWillMount === \"function\" &&\n      instance.componentWillMount.__suppressDeprecationWarning !== true\n    ) {\n      pendingComponentWillMountWarnings.push(fiber);\n    }\n    if (\n      typeof instance.componentWillReceiveProps === \"function\" &&\n      instance.componentWillReceiveProps.__suppressDeprecationWarning !== true\n    ) {\n      pendingComponentWillReceivePropsWarnings.push(fiber);\n    }\n    if (\n      typeof instance.componentWillUpdate === \"function\" &&\n      instance.componentWillUpdate.__suppressDeprecationWarning !== true\n    ) {\n      pendingComponentWillUpdateWarnings.push(fiber);\n    }\n  };\n\n  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(\n    fiber,\n    instance\n  ) {\n    var strictRoot = findStrictRoot(fiber);\n    if (strictRoot === null) {\n      warning(\n        false,\n        \"Expected to find a StrictMode component in a strict mode tree. \" +\n          \"This error is likely caused by a bug in React. Please file an issue.\"\n      );\n      return;\n    }\n\n    // Dedup strategy: Warn once per component.\n    // This is difficult to track any other way since component names\n    // are often vague and are likely to collide between 3rd party libraries.\n    // An expand property is probably okay to use here since it's DEV-only,\n    // and will only be set in the event of serious warnings.\n    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n      return;\n    }\n\n    var warningsForRoot = void 0;\n    if (!pendingUnsafeLifecycleWarnings.has(strictRoot)) {\n      warningsForRoot = {\n        UNSAFE_componentWillMount: [],\n        UNSAFE_componentWillReceiveProps: [],\n        UNSAFE_componentWillUpdate: []\n      };\n\n      pendingUnsafeLifecycleWarnings.set(strictRoot, warningsForRoot);\n    } else {\n      warningsForRoot = pendingUnsafeLifecycleWarnings.get(strictRoot);\n    }\n\n    var unsafeLifecycles = [];\n    if (\n      (typeof instance.componentWillMount === \"function\" &&\n        instance.componentWillMount.__suppressDeprecationWarning !== true) ||\n      typeof instance.UNSAFE_componentWillMount === \"function\"\n    ) {\n      unsafeLifecycles.push(\"UNSAFE_componentWillMount\");\n    }\n    if (\n      (typeof instance.componentWillReceiveProps === \"function\" &&\n        instance.componentWillReceiveProps.__suppressDeprecationWarning !==\n          true) ||\n      typeof instance.UNSAFE_componentWillReceiveProps === \"function\"\n    ) {\n      unsafeLifecycles.push(\"UNSAFE_componentWillReceiveProps\");\n    }\n    if (\n      (typeof instance.componentWillUpdate === \"function\" &&\n        instance.componentWillUpdate.__suppressDeprecationWarning !== true) ||\n      typeof instance.UNSAFE_componentWillUpdate === \"function\"\n    ) {\n      unsafeLifecycles.push(\"UNSAFE_componentWillUpdate\");\n    }\n\n    if (unsafeLifecycles.length > 0) {\n      unsafeLifecycles.forEach(function(lifecycle) {\n        warningsForRoot[lifecycle].push(fiber);\n      });\n    }\n  };\n\n  ReactStrictModeWarnings.recordLegacyContextWarning = function(\n    fiber,\n    instance\n  ) {\n    var strictRoot = findStrictRoot(fiber);\n    if (strictRoot === null) {\n      warning(\n        false,\n        \"Expected to find a StrictMode component in a strict mode tree. \" +\n          \"This error is likely caused by a bug in React. Please file an issue.\"\n      );\n      return;\n    }\n\n    // Dedup strategy: Warn once per component.\n    if (didWarnAboutLegacyContext.has(fiber.type)) {\n      return;\n    }\n\n    var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);\n\n    if (\n      fiber.type.contextTypes != null ||\n      fiber.type.childContextTypes != null ||\n      (instance !== null && typeof instance.getChildContext === \"function\")\n    ) {\n      if (warningsForRoot === undefined) {\n        warningsForRoot = [];\n        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);\n      }\n      warningsForRoot.push(fiber);\n    }\n  };\n\n  ReactStrictModeWarnings.flushLegacyContextWarning = function() {\n    pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {\n      var uniqueNames = new Set();\n      fiberArray.forEach(function(fiber) {\n        uniqueNames.add(getComponentName(fiber) || \"Component\");\n        didWarnAboutLegacyContext.add(fiber.type);\n      });\n\n      var sortedNames = setToSortedString(uniqueNames);\n      var strictRootComponentStack = getStackAddendumByWorkInProgressFiber(\n        strictRoot\n      );\n\n      warning(\n        false,\n        \"Legacy context API has been detected within a strict-mode tree: %s\" +\n          \"\\n\\nPlease update the following components: %s\" +\n          \"\\n\\nLearn more about this warning here:\" +\n          \"\\nhttps://fb.me/react-strict-mode-warnings\",\n        strictRootComponentStack,\n        sortedNames\n      );\n    });\n  };\n}\n\n// This lets us hook into Fiber to debug what it's doing.\n// See https://github.com/facebook/react/pull/8033.\n// This is not part of the public API, not even for React DevTools.\n// You may only inject a debugTool if you work on React Fiber itself.\nvar ReactFiberInstrumentation = {\n  debugTool: null\n};\n\nvar ReactFiberInstrumentation_1 = ReactFiberInstrumentation;\n\n// TODO: Offscreen updates\n\nfunction markPendingPriorityLevel(root, expirationTime) {\n  // If there's a gap between completing a failed root and retrying it,\n  // additional updates may be scheduled. Clear `didError`, in case the update\n  // is sufficient to fix the error.\n  root.didError = false;\n\n  // Update the latest and earliest pending times\n  var earliestPendingTime = root.earliestPendingTime;\n  if (earliestPendingTime === NoWork) {\n    // No other pending updates.\n    root.earliestPendingTime = root.latestPendingTime = expirationTime;\n  } else {\n    if (earliestPendingTime > expirationTime) {\n      // This is the earliest pending update.\n      root.earliestPendingTime = expirationTime;\n    } else {\n      var latestPendingTime = root.latestPendingTime;\n      if (latestPendingTime < expirationTime) {\n        // This is the latest pending update\n        root.latestPendingTime = expirationTime;\n      }\n    }\n  }\n  findNextPendingPriorityLevel(root);\n}\n\nfunction markCommittedPriorityLevels(root, currentTime, earliestRemainingTime) {\n  root.didError = false;\n\n  if (earliestRemainingTime === NoWork) {\n    // Fast path. There's no remaining work. Clear everything.\n    root.earliestPendingTime = NoWork;\n    root.latestPendingTime = NoWork;\n    root.earliestSuspendedTime = NoWork;\n    root.latestSuspendedTime = NoWork;\n    root.latestPingedTime = NoWork;\n    findNextPendingPriorityLevel(root);\n    return;\n  }\n\n  // Let's see if the previous latest known pending level was just flushed.\n  var latestPendingTime = root.latestPendingTime;\n  if (latestPendingTime !== NoWork) {\n    if (latestPendingTime < earliestRemainingTime) {\n      // We've flushed all the known pending levels.\n      root.earliestPendingTime = root.latestPendingTime = NoWork;\n    } else {\n      var earliestPendingTime = root.earliestPendingTime;\n      if (earliestPendingTime < earliestRemainingTime) {\n        // We've flushed the earliest known pending level. Set this to the\n        // latest pending time.\n        root.earliestPendingTime = root.latestPendingTime;\n      }\n    }\n  }\n\n  // Now let's handle the earliest remaining level in the whole tree. We need to\n  // decide whether to treat it as a pending level or as suspended. Check\n  // it falls within the range of known suspended levels.\n\n  var earliestSuspendedTime = root.earliestSuspendedTime;\n  if (earliestSuspendedTime === NoWork) {\n    // There's no suspended work. Treat the earliest remaining level as a\n    // pending level.\n    markPendingPriorityLevel(root, earliestRemainingTime);\n    findNextPendingPriorityLevel(root);\n    return;\n  }\n\n  var latestSuspendedTime = root.latestSuspendedTime;\n  if (earliestRemainingTime > latestSuspendedTime) {\n    // The earliest remaining level is later than all the suspended work. That\n    // means we've flushed all the suspended work.\n    root.earliestSuspendedTime = NoWork;\n    root.latestSuspendedTime = NoWork;\n    root.latestPingedTime = NoWork;\n\n    // There's no suspended work. Treat the earliest remaining level as a\n    // pending level.\n    markPendingPriorityLevel(root, earliestRemainingTime);\n    findNextPendingPriorityLevel(root);\n    return;\n  }\n\n  if (earliestRemainingTime < earliestSuspendedTime) {\n    // The earliest remaining time is earlier than all the suspended work.\n    // Treat it as a pending update.\n    markPendingPriorityLevel(root, earliestRemainingTime);\n    findNextPendingPriorityLevel(root);\n    return;\n  }\n\n  // The earliest remaining time falls within the range of known suspended\n  // levels. We should treat this as suspended work.\n  findNextPendingPriorityLevel(root);\n}\n\nfunction hasLowerPriorityWork(root, renderExpirationTime) {\n  return (\n    renderExpirationTime !== root.latestPendingTime &&\n    renderExpirationTime !== root.latestSuspendedTime\n  );\n}\n\nfunction markSuspendedPriorityLevel(root, suspendedTime, didError) {\n  if (didError && !hasLowerPriorityWork(root, suspendedTime)) {\n    // TODO: When we add back resuming, we need to ensure the progressed work\n    // is thrown out and not reused during the restarted render. One way to\n    // invalidate the progressed work is to restart at expirationTime + 1.\n    root.didError = true;\n    findNextPendingPriorityLevel(root);\n    return;\n  }\n\n  // First, check the known pending levels and update them if needed.\n  var earliestPendingTime = root.earliestPendingTime;\n  var latestPendingTime = root.latestPendingTime;\n  if (earliestPendingTime === suspendedTime) {\n    if (latestPendingTime === suspendedTime) {\n      // Both known pending levels were suspended. Clear them.\n      root.earliestPendingTime = root.latestPendingTime = NoWork;\n    } else {\n      // The earliest pending level was suspended. Clear by setting it to the\n      // latest pending level.\n      root.earliestPendingTime = latestPendingTime;\n    }\n  } else if (latestPendingTime === suspendedTime) {\n    // The latest pending level was suspended. Clear by setting it to the\n    // latest pending level.\n    root.latestPendingTime = earliestPendingTime;\n  }\n\n  // Next, if we're working on the lowest known suspended level, clear the ping.\n  // TODO: What if a promise suspends and pings before the root completes?\n  var latestSuspendedTime = root.latestSuspendedTime;\n  if (latestSuspendedTime === suspendedTime) {\n    root.latestPingedTime = NoWork;\n  }\n\n  // Finally, update the known suspended levels.\n  var earliestSuspendedTime = root.earliestSuspendedTime;\n  if (earliestSuspendedTime === NoWork) {\n    // No other suspended levels.\n    root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime;\n  } else {\n    if (earliestSuspendedTime > suspendedTime) {\n      // This is the earliest suspended level.\n      root.earliestSuspendedTime = suspendedTime;\n    } else if (latestSuspendedTime < suspendedTime) {\n      // This is the latest suspended level\n      root.latestSuspendedTime = suspendedTime;\n    }\n  }\n  findNextPendingPriorityLevel(root);\n}\n\nfunction markPingedPriorityLevel(root, pingedTime) {\n  var latestSuspendedTime = root.latestSuspendedTime;\n  if (latestSuspendedTime !== NoWork && latestSuspendedTime <= pingedTime) {\n    var latestPingedTime = root.latestPingedTime;\n    if (latestPingedTime === NoWork || latestPingedTime < pingedTime) {\n      root.latestPingedTime = pingedTime;\n    }\n  }\n  findNextPendingPriorityLevel(root);\n}\n\nfunction findNextPendingPriorityLevel(root) {\n  var earliestSuspendedTime = root.earliestSuspendedTime;\n  var earliestPendingTime = root.earliestPendingTime;\n  var nextExpirationTimeToWorkOn = void 0;\n  var expirationTime = void 0;\n  if (earliestSuspendedTime === NoWork) {\n    // Fast path. There's no suspended work.\n    nextExpirationTimeToWorkOn = expirationTime = earliestPendingTime;\n  } else if (earliestPendingTime !== NoWork) {\n    // Check if there's known pending work.\n    nextExpirationTimeToWorkOn = earliestPendingTime;\n    expirationTime =\n      earliestSuspendedTime < earliestPendingTime\n        ? earliestSuspendedTime\n        : earliestPendingTime;\n  } else {\n    // Finally, if a suspended level was pinged, work on that. Otherwise there's\n    // nothing to work on.\n    nextExpirationTimeToWorkOn = expirationTime = root.latestPingedTime;\n  }\n\n  if (root.didError) {\n    // Revert to synchronous mode.\n    expirationTime = Sync;\n  }\n\n  root.nextExpirationTimeToWorkOn = nextExpirationTimeToWorkOn;\n  root.expirationTime = expirationTime;\n}\n\n// UpdateQueue is a linked list of prioritized updates.\n//\n// Like fibers, update queues come in pairs: a current queue, which represents\n// the visible state of the screen, and a work-in-progress queue, which is\n// can be mutated and processed asynchronously before it is committed  a form\n// of double buffering. If a work-in-progress render is discarded before\n// finishing, we create a new work-in-progress by cloning the current queue.\n//\n// Both queues share a persistent, singly-linked list structure. To schedule an\n// update, we append it to the end of both queues. Each queue maintains a\n// pointer to first update in the persistent list that hasn't been processed.\n// The work-in-progress pointer always has a position equal to or greater than\n// the current queue, since we always work on that one. The current queue's\n// pointer is only updated during the commit phase, when we swap in the\n// work-in-progress.\n//\n// For example:\n//\n//   Current pointer:           A - B - C - D - E - F\n//   Work-in-progress pointer:              D - E - F\n//                                          ^\n//                                          The work-in-progress queue has\n//                                          processed more updates than current.\n//\n// The reason we append to both queues is because otherwise we might drop\n// updates without ever processing them. For example, if we only add updates to\n// the work-in-progress queue, some updates could be lost whenever a work-in\n// -progress render restarts by cloning from current. Similarly, if we only add\n// updates to the current queue, the updates will be lost whenever an already\n// in-progress queue commits and swaps with the current queue. However, by\n// adding to both queues, we guarantee that the update will be part of the next\n// work-in-progress. (And because the work-in-progress queue becomes the\n// current queue once it commits, there's no danger of applying the same\n// update twice.)\n//\n// Prioritization\n// --------------\n//\n// Updates are not sorted by priority, but by insertion; new updates are always\n// appended to the end of the list.\n//\n// The priority is still important, though. When processing the update queue\n// during the render phase, only the updates with sufficient priority are\n// included in the result. If we skip an update because it has insufficient\n// priority, it remains in the queue to be processed later, during a lower\n// priority render. Crucially, all updates subsequent to a skipped update also\n// remain in the queue *regardless of their priority*. That means high priority\n// updates are sometimes processed twice, at two separate priorities. We also\n// keep track of a base state, that represents the state before the first\n// update in the queue is applied.\n//\n// For example:\n//\n//   Given a base state of '', and the following queue of updates\n//\n//     A1 - B2 - C1 - D2\n//\n//   where the number indicates the priority, and the update is applied to the\n//   previous state by appending a letter, React will process these updates as\n//   two separate renders, one per distinct priority level:\n//\n//   First render, at priority 1:\n//     Base state: ''\n//     Updates: [A1, C1]\n//     Result state: 'AC'\n//\n//   Second render, at priority 2:\n//     Base state: 'A'            <-  The base state does not include C1,\n//                                    because B2 was skipped.\n//     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2\n//     Result state: 'ABCD'\n//\n// Because we process updates in insertion order, and rebase high priority\n// updates when preceding updates are skipped, the final result is deterministic\n// regardless of priority. Intermediate state may vary according to system\n// resources, but the final state is always the same.\n\nvar UpdateState = 0;\nvar ReplaceState = 1;\nvar ForceUpdate = 2;\nvar CaptureUpdate = 3;\n\n// Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\nvar hasForceUpdate = false;\n\nvar didWarnUpdateInsideUpdate = void 0;\nvar currentlyProcessingQueue = void 0;\nvar resetCurrentlyProcessingQueue = void 0;\n{\n  didWarnUpdateInsideUpdate = false;\n  currentlyProcessingQueue = null;\n  resetCurrentlyProcessingQueue = function() {\n    currentlyProcessingQueue = null;\n  };\n}\n\nfunction createUpdateQueue(baseState) {\n  var queue = {\n    expirationTime: NoWork,\n    baseState: baseState,\n    firstUpdate: null,\n    lastUpdate: null,\n    firstCapturedUpdate: null,\n    lastCapturedUpdate: null,\n    firstEffect: null,\n    lastEffect: null,\n    firstCapturedEffect: null,\n    lastCapturedEffect: null\n  };\n  return queue;\n}\n\nfunction cloneUpdateQueue(currentQueue) {\n  var queue = {\n    expirationTime: currentQueue.expirationTime,\n    baseState: currentQueue.baseState,\n    firstUpdate: currentQueue.firstUpdate,\n    lastUpdate: currentQueue.lastUpdate,\n\n    // TODO: With resuming, if we bail out and resuse the child tree, we should\n    // keep these effects.\n    firstCapturedUpdate: null,\n    lastCapturedUpdate: null,\n\n    firstEffect: null,\n    lastEffect: null,\n\n    firstCapturedEffect: null,\n    lastCapturedEffect: null\n  };\n  return queue;\n}\n\nfunction createUpdate(expirationTime) {\n  return {\n    expirationTime: expirationTime,\n\n    tag: UpdateState,\n    payload: null,\n    callback: null,\n\n    next: null,\n    nextEffect: null\n  };\n}\n\nfunction appendUpdateToQueue(queue, update, expirationTime) {\n  // Append the update to the end of the list.\n  if (queue.lastUpdate === null) {\n    // Queue is empty\n    queue.firstUpdate = queue.lastUpdate = update;\n  } else {\n    queue.lastUpdate.next = update;\n    queue.lastUpdate = update;\n  }\n  if (\n    queue.expirationTime === NoWork ||\n    queue.expirationTime > expirationTime\n  ) {\n    // The incoming update has the earliest expiration of any update in the\n    // queue. Update the queue's expiration time.\n    queue.expirationTime = expirationTime;\n  }\n}\n\nfunction enqueueUpdate(fiber, update, expirationTime) {\n  // Update queues are created lazily.\n  var alternate = fiber.alternate;\n  var queue1 = void 0;\n  var queue2 = void 0;\n  if (alternate === null) {\n    // There's only one fiber.\n    queue1 = fiber.updateQueue;\n    queue2 = null;\n    if (queue1 === null) {\n      queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n    }\n  } else {\n    // There are two owners.\n    queue1 = fiber.updateQueue;\n    queue2 = alternate.updateQueue;\n    if (queue1 === null) {\n      if (queue2 === null) {\n        // Neither fiber has an update queue. Create new ones.\n        queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n        queue2 = alternate.updateQueue = createUpdateQueue(\n          alternate.memoizedState\n        );\n      } else {\n        // Only one fiber has an update queue. Clone to create a new one.\n        queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);\n      }\n    } else {\n      if (queue2 === null) {\n        // Only one fiber has an update queue. Clone to create a new one.\n        queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);\n      } else {\n        // Both owners have an update queue.\n      }\n    }\n  }\n  if (queue2 === null || queue1 === queue2) {\n    // There's only a single queue.\n    appendUpdateToQueue(queue1, update, expirationTime);\n  } else {\n    // There are two queues. We need to append the update to both queues,\n    // while accounting for the persistent structure of the list  we don't\n    // want the same update to be added multiple times.\n    if (queue1.lastUpdate === null || queue2.lastUpdate === null) {\n      // One of the queues is not empty. We must add the update to both queues.\n      appendUpdateToQueue(queue1, update, expirationTime);\n      appendUpdateToQueue(queue2, update, expirationTime);\n    } else {\n      // Both queues are non-empty. The last update is the same in both lists,\n      // because of structural sharing. So, only append to one of the lists.\n      appendUpdateToQueue(queue1, update, expirationTime);\n      // But we still need to update the `lastUpdate` pointer of queue2.\n      queue2.lastUpdate = update;\n    }\n  }\n\n  {\n    if (\n      fiber.tag === ClassComponent &&\n      (currentlyProcessingQueue === queue1 ||\n        (queue2 !== null && currentlyProcessingQueue === queue2)) &&\n      !didWarnUpdateInsideUpdate\n    ) {\n      warning(\n        false,\n        \"An update (setState, replaceState, or forceUpdate) was scheduled \" +\n          \"from inside an update function. Update functions should be pure, \" +\n          \"with zero side-effects. Consider using componentDidUpdate or a \" +\n          \"callback.\"\n      );\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n}\n\nfunction enqueueCapturedUpdate(workInProgress, update, renderExpirationTime) {\n  // Captured updates go into a separate list, and only on the work-in-\n  // progress queue.\n  var workInProgressQueue = workInProgress.updateQueue;\n  if (workInProgressQueue === null) {\n    workInProgressQueue = workInProgress.updateQueue = createUpdateQueue(\n      workInProgress.memoizedState\n    );\n  } else {\n    // TODO: I put this here rather than createWorkInProgress so that we don't\n    // clone the queue unnecessarily. There's probably a better way to\n    // structure this.\n    workInProgressQueue = ensureWorkInProgressQueueIsAClone(\n      workInProgress,\n      workInProgressQueue\n    );\n  }\n\n  // Append the update to the end of the list.\n  if (workInProgressQueue.lastCapturedUpdate === null) {\n    // This is the first render phase update\n    workInProgressQueue.firstCapturedUpdate = workInProgressQueue.lastCapturedUpdate = update;\n  } else {\n    workInProgressQueue.lastCapturedUpdate.next = update;\n    workInProgressQueue.lastCapturedUpdate = update;\n  }\n  if (\n    workInProgressQueue.expirationTime === NoWork ||\n    workInProgressQueue.expirationTime > renderExpirationTime\n  ) {\n    // The incoming update has the earliest expiration of any update in the\n    // queue. Update the queue's expiration time.\n    workInProgressQueue.expirationTime = renderExpirationTime;\n  }\n}\n\nfunction ensureWorkInProgressQueueIsAClone(workInProgress, queue) {\n  var current = workInProgress.alternate;\n  if (current !== null) {\n    // If the work-in-progress queue is equal to the current queue,\n    // we need to clone it first.\n    if (queue === current.updateQueue) {\n      queue = workInProgress.updateQueue = cloneUpdateQueue(queue);\n    }\n  }\n  return queue;\n}\n\nfunction getStateFromUpdate(\n  workInProgress,\n  queue,\n  update,\n  prevState,\n  nextProps,\n  instance\n) {\n  switch (update.tag) {\n    case ReplaceState: {\n      var _payload = update.payload;\n      if (typeof _payload === \"function\") {\n        // Updater function\n        {\n          if (\n            debugRenderPhaseSideEffects ||\n            (debugRenderPhaseSideEffectsForStrictMode &&\n              workInProgress.mode & StrictMode)\n          ) {\n            _payload.call(instance, prevState, nextProps);\n          }\n        }\n        return _payload.call(instance, prevState, nextProps);\n      }\n      // State object\n      return _payload;\n    }\n    case CaptureUpdate: {\n      workInProgress.effectTag =\n        (workInProgress.effectTag & ~ShouldCapture) | DidCapture;\n    }\n    // Intentional fallthrough\n    case UpdateState: {\n      var _payload2 = update.payload;\n      var partialState = void 0;\n      if (typeof _payload2 === \"function\") {\n        // Updater function\n        {\n          if (\n            debugRenderPhaseSideEffects ||\n            (debugRenderPhaseSideEffectsForStrictMode &&\n              workInProgress.mode & StrictMode)\n          ) {\n            _payload2.call(instance, prevState, nextProps);\n          }\n        }\n        partialState = _payload2.call(instance, prevState, nextProps);\n      } else {\n        // Partial state object\n        partialState = _payload2;\n      }\n      if (partialState === null || partialState === undefined) {\n        // Null and undefined are treated as no-ops.\n        return prevState;\n      }\n      // Merge the partial state and the previous state.\n      return Object.assign({}, prevState, partialState);\n    }\n    case ForceUpdate: {\n      hasForceUpdate = true;\n      return prevState;\n    }\n  }\n  return prevState;\n}\n\nfunction processUpdateQueue(\n  workInProgress,\n  queue,\n  props,\n  instance,\n  renderExpirationTime\n) {\n  hasForceUpdate = false;\n\n  if (\n    queue.expirationTime === NoWork ||\n    queue.expirationTime > renderExpirationTime\n  ) {\n    // Insufficient priority. Bailout.\n    return;\n  }\n\n  queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);\n\n  {\n    currentlyProcessingQueue = queue;\n  }\n\n  // These values may change as we process the queue.\n  var newBaseState = queue.baseState;\n  var newFirstUpdate = null;\n  var newExpirationTime = NoWork;\n\n  // Iterate through the list of updates to compute the result.\n  var update = queue.firstUpdate;\n  var resultState = newBaseState;\n  while (update !== null) {\n    var updateExpirationTime = update.expirationTime;\n    if (updateExpirationTime > renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      if (newFirstUpdate === null) {\n        // This is the first skipped update. It will be the first update in\n        // the new list.\n        newFirstUpdate = update;\n        // Since this is the first update that was skipped, the current result\n        // is the new base state.\n        newBaseState = resultState;\n      }\n      // Since this update will remain in the list, update the remaining\n      // expiration time.\n      if (\n        newExpirationTime === NoWork ||\n        newExpirationTime > updateExpirationTime\n      ) {\n        newExpirationTime = updateExpirationTime;\n      }\n    } else {\n      // This update does have sufficient priority. Process it and compute\n      // a new result.\n      resultState = getStateFromUpdate(\n        workInProgress,\n        queue,\n        update,\n        resultState,\n        props,\n        instance\n      );\n      var _callback = update.callback;\n      if (_callback !== null) {\n        workInProgress.effectTag |= Callback;\n        // Set this to null, in case it was mutated during an aborted render.\n        update.nextEffect = null;\n        if (queue.lastEffect === null) {\n          queue.firstEffect = queue.lastEffect = update;\n        } else {\n          queue.lastEffect.nextEffect = update;\n          queue.lastEffect = update;\n        }\n      }\n    }\n    // Continue to the next update.\n    update = update.next;\n  }\n\n  // Separately, iterate though the list of captured updates.\n  var newFirstCapturedUpdate = null;\n  update = queue.firstCapturedUpdate;\n  while (update !== null) {\n    var _updateExpirationTime = update.expirationTime;\n    if (_updateExpirationTime > renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      if (newFirstCapturedUpdate === null) {\n        // This is the first skipped captured update. It will be the first\n        // update in the new list.\n        newFirstCapturedUpdate = update;\n        // If this is the first update that was skipped, the current result is\n        // the new base state.\n        if (newFirstUpdate === null) {\n          newBaseState = resultState;\n        }\n      }\n      // Since this update will remain in the list, update the remaining\n      // expiration time.\n      if (\n        newExpirationTime === NoWork ||\n        newExpirationTime > _updateExpirationTime\n      ) {\n        newExpirationTime = _updateExpirationTime;\n      }\n    } else {\n      // This update does have sufficient priority. Process it and compute\n      // a new result.\n      resultState = getStateFromUpdate(\n        workInProgress,\n        queue,\n        update,\n        resultState,\n        props,\n        instance\n      );\n      var _callback2 = update.callback;\n      if (_callback2 !== null) {\n        workInProgress.effectTag |= Callback;\n        // Set this to null, in case it was mutated during an aborted render.\n        update.nextEffect = null;\n        if (queue.lastCapturedEffect === null) {\n          queue.firstCapturedEffect = queue.lastCapturedEffect = update;\n        } else {\n          queue.lastCapturedEffect.nextEffect = update;\n          queue.lastCapturedEffect = update;\n        }\n      }\n    }\n    update = update.next;\n  }\n\n  if (newFirstUpdate === null) {\n    queue.lastUpdate = null;\n  }\n  if (newFirstCapturedUpdate === null) {\n    queue.lastCapturedUpdate = null;\n  } else {\n    workInProgress.effectTag |= Callback;\n  }\n  if (newFirstUpdate === null && newFirstCapturedUpdate === null) {\n    // We processed every update, without skipping. That means the new base\n    // state is the same as the result state.\n    newBaseState = resultState;\n  }\n\n  queue.baseState = newBaseState;\n  queue.firstUpdate = newFirstUpdate;\n  queue.firstCapturedUpdate = newFirstCapturedUpdate;\n  queue.expirationTime = newExpirationTime;\n\n  workInProgress.memoizedState = resultState;\n\n  {\n    currentlyProcessingQueue = null;\n  }\n}\n\nfunction callCallback(callback, context) {\n  invariant(\n    typeof callback === \"function\",\n    \"Invalid argument passed as callback. Expected a function. Instead \" +\n      \"received: %s\",\n    callback\n  );\n  callback.call(context);\n}\n\nfunction resetHasForceUpdateBeforeProcessing() {\n  hasForceUpdate = false;\n}\n\nfunction checkHasForceUpdateAfterProcessing() {\n  return hasForceUpdate;\n}\n\nfunction commitUpdateQueue(\n  finishedWork,\n  finishedQueue,\n  instance,\n  renderExpirationTime\n) {\n  // If the finished render included captured updates, and there are still\n  // lower priority updates left over, we need to keep the captured updates\n  // in the queue so that they are rebased and not dropped once we process the\n  // queue again at the lower priority.\n  if (finishedQueue.firstCapturedUpdate !== null) {\n    // Join the captured update list to the end of the normal list.\n    if (finishedQueue.lastUpdate !== null) {\n      finishedQueue.lastUpdate.next = finishedQueue.firstCapturedUpdate;\n      finishedQueue.lastUpdate = finishedQueue.lastCapturedUpdate;\n    }\n    // Clear the list of captured updates.\n    finishedQueue.firstCapturedUpdate = finishedQueue.lastCapturedUpdate = null;\n  }\n\n  // Commit the effects\n  var effect = finishedQueue.firstEffect;\n  finishedQueue.firstEffect = finishedQueue.lastEffect = null;\n  while (effect !== null) {\n    var _callback3 = effect.callback;\n    if (_callback3 !== null) {\n      effect.callback = null;\n      callCallback(_callback3, instance);\n    }\n    effect = effect.nextEffect;\n  }\n\n  effect = finishedQueue.firstCapturedEffect;\n  finishedQueue.firstCapturedEffect = finishedQueue.lastCapturedEffect = null;\n  while (effect !== null) {\n    var _callback4 = effect.callback;\n    if (_callback4 !== null) {\n      effect.callback = null;\n      callCallback(_callback4, instance);\n    }\n    effect = effect.nextEffect;\n  }\n}\n\nfunction createCapturedValue(value, source) {\n  // If the value is an error, call this function immediately after it is thrown\n  // so the stack is accurate.\n  return {\n    value: value,\n    source: source,\n    stack: getStackAddendumByWorkInProgressFiber(source)\n  };\n}\n\nvar providerCursor = createCursor(null);\nvar valueCursor = createCursor(null);\nvar changedBitsCursor = createCursor(0);\n\nvar rendererSigil = void 0;\n{\n  // Use this to detect multiple renderers using the same context\n  rendererSigil = {};\n}\n\nfunction pushProvider(providerFiber) {\n  var context = providerFiber.type._context;\n\n  if (isPrimaryRenderer) {\n    push(changedBitsCursor, context._changedBits, providerFiber);\n    push(valueCursor, context._currentValue, providerFiber);\n    push(providerCursor, providerFiber, providerFiber);\n\n    context._currentValue = providerFiber.pendingProps.value;\n    context._changedBits = providerFiber.stateNode;\n    {\n      !(\n        context._currentRenderer === undefined ||\n        context._currentRenderer === null ||\n        context._currentRenderer === rendererSigil\n      )\n        ? warning(\n            false,\n            \"Detected multiple renderers concurrently rendering the \" +\n              \"same context provider. This is currently unsupported.\"\n          )\n        : void 0;\n      context._currentRenderer = rendererSigil;\n    }\n  } else {\n    push(changedBitsCursor, context._changedBits2, providerFiber);\n    push(valueCursor, context._currentValue2, providerFiber);\n    push(providerCursor, providerFiber, providerFiber);\n\n    context._currentValue2 = providerFiber.pendingProps.value;\n    context._changedBits2 = providerFiber.stateNode;\n    {\n      !(\n        context._currentRenderer2 === undefined ||\n        context._currentRenderer2 === null ||\n        context._currentRenderer2 === rendererSigil\n      )\n        ? warning(\n            false,\n            \"Detected multiple renderers concurrently rendering the \" +\n              \"same context provider. This is currently unsupported.\"\n          )\n        : void 0;\n      context._currentRenderer2 = rendererSigil;\n    }\n  }\n}\n\nfunction popProvider(providerFiber) {\n  var changedBits = changedBitsCursor.current;\n  var currentValue = valueCursor.current;\n\n  pop(providerCursor, providerFiber);\n  pop(valueCursor, providerFiber);\n  pop(changedBitsCursor, providerFiber);\n\n  var context = providerFiber.type._context;\n  if (isPrimaryRenderer) {\n    context._currentValue = currentValue;\n    context._changedBits = changedBits;\n  } else {\n    context._currentValue2 = currentValue;\n    context._changedBits2 = changedBits;\n  }\n}\n\nfunction getContextCurrentValue(context) {\n  return isPrimaryRenderer ? context._currentValue : context._currentValue2;\n}\n\nfunction getContextChangedBits(context) {\n  return isPrimaryRenderer ? context._changedBits : context._changedBits2;\n}\n\nvar NO_CONTEXT = {};\n\nvar contextStackCursor$1 = createCursor(NO_CONTEXT);\nvar contextFiberStackCursor = createCursor(NO_CONTEXT);\nvar rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\nfunction requiredContext(c) {\n  invariant(\n    c !== NO_CONTEXT,\n    \"Expected host context to exist. This error is likely caused by a bug \" +\n      \"in React. Please file an issue.\"\n  );\n  return c;\n}\n\nfunction getRootHostContainer() {\n  var rootInstance = requiredContext(rootInstanceStackCursor.current);\n  return rootInstance;\n}\n\nfunction pushHostContainer(fiber, nextRootInstance) {\n  // Push current root instance onto the stack;\n  // This allows us to reset root when portals are popped.\n  push(rootInstanceStackCursor, nextRootInstance, fiber);\n  // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n  push(contextFiberStackCursor, fiber, fiber);\n\n  // Finally, we need to push the host context to the stack.\n  // However, we can't just call getRootHostContext() and push it because\n  // we'd have a different number of entries on the stack depending on\n  // whether getRootHostContext() throws somewhere in renderer code or not.\n  // So we push an empty value first. This lets us safely unwind on errors.\n  push(contextStackCursor$1, NO_CONTEXT, fiber);\n  var nextRootContext = getRootHostContext(nextRootInstance);\n  // Now that we know this function doesn't throw, replace it.\n  pop(contextStackCursor$1, fiber);\n  push(contextStackCursor$1, nextRootContext, fiber);\n}\n\nfunction popHostContainer(fiber) {\n  pop(contextStackCursor$1, fiber);\n  pop(contextFiberStackCursor, fiber);\n  pop(rootInstanceStackCursor, fiber);\n}\n\nfunction getHostContext() {\n  var context = requiredContext(contextStackCursor$1.current);\n  return context;\n}\n\nfunction pushHostContext(fiber) {\n  var rootInstance = requiredContext(rootInstanceStackCursor.current);\n  var context = requiredContext(contextStackCursor$1.current);\n  var nextContext = getChildHostContext(context, fiber.type, rootInstance);\n\n  // Don't push this Fiber's context unless it's unique.\n  if (context === nextContext) {\n    return;\n  }\n\n  // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n  push(contextFiberStackCursor, fiber, fiber);\n  push(contextStackCursor$1, nextContext, fiber);\n}\n\nfunction popHostContext(fiber) {\n  // Do not pop unless this Fiber provided the current context.\n  // pushHostContext() only pushes Fibers that provide unique contexts.\n  if (contextFiberStackCursor.current !== fiber) {\n    return;\n  }\n\n  pop(contextStackCursor$1, fiber);\n  pop(contextFiberStackCursor, fiber);\n}\n\nvar commitTime = 0;\n\nfunction getCommitTime() {\n  return commitTime;\n}\n\nfunction recordCommitTime() {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  commitTime = now();\n}\n\n/**\n * The \"actual\" render time is total time required to render the descendants of a Profiler component.\n * This time is stored as a stack, since Profilers can be nested.\n * This time is started during the \"begin\" phase and stopped during the \"complete\" phase.\n * It is paused (and accumulated) in the event of an interruption or an aborted render.\n */\n\nvar fiberStack$1 = void 0;\n\n{\n  fiberStack$1 = [];\n}\n\nvar timerPausedAt = 0;\nvar totalElapsedPauseTime = 0;\n\nfunction checkActualRenderTimeStackEmpty() {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  {\n    !(fiberStack$1.length === 0)\n      ? warning(\n          false,\n          \"Expected an empty stack. Something was not reset properly.\"\n        )\n      : void 0;\n  }\n}\n\nfunction markActualRenderTimeStarted(fiber) {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  {\n    fiberStack$1.push(fiber);\n  }\n\n  fiber.actualDuration = now() - fiber.actualDuration - totalElapsedPauseTime;\n  fiber.actualStartTime = now();\n}\n\nfunction pauseActualRenderTimerIfRunning() {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  if (timerPausedAt === 0) {\n    timerPausedAt = now();\n  }\n}\n\nfunction recordElapsedActualRenderTime(fiber) {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  {\n    !(fiber === fiberStack$1.pop())\n      ? warning(false, \"Unexpected Fiber (%s) popped.\", getComponentName(fiber))\n      : void 0;\n  }\n\n  fiber.actualDuration = now() - totalElapsedPauseTime - fiber.actualDuration;\n}\n\nfunction resetActualRenderTimer() {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  totalElapsedPauseTime = 0;\n}\n\nfunction resumeActualRenderTimerIfPaused() {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  if (timerPausedAt > 0) {\n    totalElapsedPauseTime += now() - timerPausedAt;\n    timerPausedAt = 0;\n  }\n}\n\n/**\n * The \"base\" render time is the duration of the begin phase of work for a particular fiber.\n * This time is measured and stored on each fiber.\n * The time for all sibling fibers are accumulated and stored on their parent during the \"complete\" phase.\n * If a fiber bails out (sCU false) then its \"base\" timer is cancelled and the fiber is not updated.\n */\n\nvar baseStartTime = -1;\n\nfunction recordElapsedBaseRenderTimeIfRunning(fiber) {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  if (baseStartTime !== -1) {\n    fiber.selfBaseTime = now() - baseStartTime;\n  }\n}\n\nfunction startBaseRenderTimer() {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  {\n    if (baseStartTime !== -1) {\n      warning(\n        false,\n        \"Cannot start base timer that is already running. \" +\n          \"This error is likely caused by a bug in React. \" +\n          \"Please file an issue.\"\n      );\n    }\n  }\n  baseStartTime = now();\n}\n\nfunction stopBaseRenderTimerIfRunning() {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  baseStartTime = -1;\n}\n\n/*eslint-disable no-self-compare */\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    // Added the nonzero y check to make Flow happy, but it is redundant\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    // Step 6.a: NaN == NaN\n    return x !== x && y !== y;\n  }\n}\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (\n    typeof objA !== \"object\" ||\n    objA === null ||\n    typeof objB !== \"object\" ||\n    objB === null\n  ) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  for (var i = 0; i < keysA.length; i++) {\n    if (\n      !hasOwnProperty.call(objB, keysA[i]) ||\n      !is(objA[keysA[i]], objB[keysA[i]])\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar fakeInternalInstance = {};\nvar isArray = Array.isArray;\n\nvar didWarnAboutStateAssignmentForComponent = void 0;\nvar didWarnAboutUninitializedState = void 0;\nvar didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = void 0;\nvar didWarnAboutLegacyLifecyclesAndDerivedState = void 0;\nvar didWarnAboutUndefinedDerivedState = void 0;\nvar warnOnUndefinedDerivedState = void 0;\nvar warnOnInvalidCallback = void 0;\n\n{\n  didWarnAboutStateAssignmentForComponent = new Set();\n  didWarnAboutUninitializedState = new Set();\n  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n  didWarnAboutUndefinedDerivedState = new Set();\n\n  var didWarnOnInvalidCallback = new Set();\n\n  warnOnInvalidCallback = function(callback, callerName) {\n    if (callback === null || typeof callback === \"function\") {\n      return;\n    }\n    var key = callerName + \"_\" + callback;\n    if (!didWarnOnInvalidCallback.has(key)) {\n      didWarnOnInvalidCallback.add(key);\n      warning(\n        false,\n        \"%s(...): Expected the last optional `callback` argument to be a \" +\n          \"function. Instead received: %s.\",\n        callerName,\n        callback\n      );\n    }\n  };\n\n  warnOnUndefinedDerivedState = function(workInProgress, partialState) {\n    if (partialState === undefined) {\n      var componentName = getComponentName(workInProgress) || \"Component\";\n      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n        didWarnAboutUndefinedDerivedState.add(componentName);\n        warning(\n          false,\n          \"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. \" +\n            \"You have returned undefined.\",\n          componentName\n        );\n      }\n    }\n  };\n\n  // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n  Object.defineProperty(fakeInternalInstance, \"_processChildContext\", {\n    enumerable: false,\n    value: function() {\n      invariant(\n        false,\n        \"_processChildContext is not available in React 16+. This likely \" +\n          \"means you have multiple copies of React and are attempting to nest \" +\n          \"a React 15 tree inside a React 16 tree using \" +\n          \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" +\n          \"to make sure you have only one copy of React (and ideally, switch \" +\n          \"to ReactDOM.createPortal).\"\n      );\n    }\n  });\n  Object.freeze(fakeInternalInstance);\n}\n\nfunction applyDerivedStateFromProps(\n  workInProgress,\n  getDerivedStateFromProps,\n  nextProps\n) {\n  var prevState = workInProgress.memoizedState;\n\n  {\n    if (\n      debugRenderPhaseSideEffects ||\n      (debugRenderPhaseSideEffectsForStrictMode &&\n        workInProgress.mode & StrictMode)\n    ) {\n      // Invoke the function an extra time to help detect side-effects.\n      getDerivedStateFromProps(nextProps, prevState);\n    }\n  }\n\n  var partialState = getDerivedStateFromProps(nextProps, prevState);\n\n  {\n    warnOnUndefinedDerivedState(workInProgress, partialState);\n  }\n  // Merge the partial state and the previous state.\n  var memoizedState =\n    partialState === null || partialState === undefined\n      ? prevState\n      : Object.assign({}, prevState, partialState);\n  workInProgress.memoizedState = memoizedState;\n\n  // Once the update queue is empty, persist the derived state onto the\n  // base state.\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null && updateQueue.expirationTime === NoWork) {\n    updateQueue.baseState = memoizedState;\n  }\n}\n\nvar classComponentUpdater = {\n  isMounted: isMounted,\n  enqueueSetState: function(inst, payload, callback) {\n    var fiber = get$1(inst);\n    var currentTime = recalculateCurrentTime();\n    var expirationTime = computeExpirationForFiber(currentTime, fiber);\n\n    var update = createUpdate(expirationTime);\n    update.payload = payload;\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback(callback, \"setState\");\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update, expirationTime);\n    scheduleWork(fiber, expirationTime);\n  },\n  enqueueReplaceState: function(inst, payload, callback) {\n    var fiber = get$1(inst);\n    var currentTime = recalculateCurrentTime();\n    var expirationTime = computeExpirationForFiber(currentTime, fiber);\n\n    var update = createUpdate(expirationTime);\n    update.tag = ReplaceState;\n    update.payload = payload;\n\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback(callback, \"replaceState\");\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update, expirationTime);\n    scheduleWork(fiber, expirationTime);\n  },\n  enqueueForceUpdate: function(inst, callback) {\n    var fiber = get$1(inst);\n    var currentTime = recalculateCurrentTime();\n    var expirationTime = computeExpirationForFiber(currentTime, fiber);\n\n    var update = createUpdate(expirationTime);\n    update.tag = ForceUpdate;\n\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback(callback, \"forceUpdate\");\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update, expirationTime);\n    scheduleWork(fiber, expirationTime);\n  }\n};\n\nfunction checkShouldComponentUpdate(\n  workInProgress,\n  oldProps,\n  newProps,\n  oldState,\n  newState,\n  newContext\n) {\n  var instance = workInProgress.stateNode;\n  var ctor = workInProgress.type;\n  if (typeof instance.shouldComponentUpdate === \"function\") {\n    startPhaseTimer(workInProgress, \"shouldComponentUpdate\");\n    var shouldUpdate = instance.shouldComponentUpdate(\n      newProps,\n      newState,\n      newContext\n    );\n    stopPhaseTimer();\n\n    {\n      !(shouldUpdate !== undefined)\n        ? warning(\n            false,\n            \"%s.shouldComponentUpdate(): Returned undefined instead of a \" +\n              \"boolean value. Make sure to return true or false.\",\n            getComponentName(workInProgress) || \"Component\"\n          )\n        : void 0;\n    }\n\n    return shouldUpdate;\n  }\n\n  if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n    return (\n      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\n    );\n  }\n\n  return true;\n}\n\nfunction checkClassInstance(workInProgress) {\n  var instance = workInProgress.stateNode;\n  var type = workInProgress.type;\n  {\n    var name = getComponentName(workInProgress) || \"Component\";\n    var renderPresent = instance.render;\n\n    if (!renderPresent) {\n      if (type.prototype && typeof type.prototype.render === \"function\") {\n        warning(\n          false,\n          \"%s(...): No `render` method found on the returned component \" +\n            \"instance: did you accidentally return an object from the constructor?\",\n          name\n        );\n      } else {\n        warning(\n          false,\n          \"%s(...): No `render` method found on the returned component \" +\n            \"instance: you may have forgotten to define `render`.\",\n          name\n        );\n      }\n    }\n\n    var noGetInitialStateOnES6 =\n      !instance.getInitialState ||\n      instance.getInitialState.isReactClassApproved ||\n      instance.state;\n    !noGetInitialStateOnES6\n      ? warning(\n          false,\n          \"getInitialState was defined on %s, a plain JavaScript class. \" +\n            \"This is only supported for classes created using React.createClass. \" +\n            \"Did you mean to define a state property instead?\",\n          name\n        )\n      : void 0;\n    var noGetDefaultPropsOnES6 =\n      !instance.getDefaultProps ||\n      instance.getDefaultProps.isReactClassApproved;\n    !noGetDefaultPropsOnES6\n      ? warning(\n          false,\n          \"getDefaultProps was defined on %s, a plain JavaScript class. \" +\n            \"This is only supported for classes created using React.createClass. \" +\n            \"Use a static property to define defaultProps instead.\",\n          name\n        )\n      : void 0;\n    var noInstancePropTypes = !instance.propTypes;\n    !noInstancePropTypes\n      ? warning(\n          false,\n          \"propTypes was defined as an instance property on %s. Use a static \" +\n            \"property to define propTypes instead.\",\n          name\n        )\n      : void 0;\n    var noInstanceContextTypes = !instance.contextTypes;\n    !noInstanceContextTypes\n      ? warning(\n          false,\n          \"contextTypes was defined as an instance property on %s. Use a static \" +\n            \"property to define contextTypes instead.\",\n          name\n        )\n      : void 0;\n    var noComponentShouldUpdate =\n      typeof instance.componentShouldUpdate !== \"function\";\n    !noComponentShouldUpdate\n      ? warning(\n          false,\n          \"%s has a method called \" +\n            \"componentShouldUpdate(). Did you mean shouldComponentUpdate()? \" +\n            \"The name is phrased as a question because the function is \" +\n            \"expected to return a value.\",\n          name\n        )\n      : void 0;\n    if (\n      type.prototype &&\n      type.prototype.isPureReactComponent &&\n      typeof instance.shouldComponentUpdate !== \"undefined\"\n    ) {\n      warning(\n        false,\n        \"%s has a method called shouldComponentUpdate(). \" +\n          \"shouldComponentUpdate should not be used when extending React.PureComponent. \" +\n          \"Please extend React.Component if shouldComponentUpdate is used.\",\n        getComponentName(workInProgress) || \"A pure component\"\n      );\n    }\n    var noComponentDidUnmount =\n      typeof instance.componentDidUnmount !== \"function\";\n    !noComponentDidUnmount\n      ? warning(\n          false,\n          \"%s has a method called \" +\n            \"componentDidUnmount(). But there is no such lifecycle method. \" +\n            \"Did you mean componentWillUnmount()?\",\n          name\n        )\n      : void 0;\n    var noComponentDidReceiveProps =\n      typeof instance.componentDidReceiveProps !== \"function\";\n    !noComponentDidReceiveProps\n      ? warning(\n          false,\n          \"%s has a method called \" +\n            \"componentDidReceiveProps(). But there is no such lifecycle method. \" +\n            \"If you meant to update the state in response to changing props, \" +\n            \"use componentWillReceiveProps(). If you meant to fetch data or \" +\n            \"run side-effects or mutations after React has updated the UI, use componentDidUpdate().\",\n          name\n        )\n      : void 0;\n    var noComponentWillRecieveProps =\n      typeof instance.componentWillRecieveProps !== \"function\";\n    !noComponentWillRecieveProps\n      ? warning(\n          false,\n          \"%s has a method called \" +\n            \"componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\",\n          name\n        )\n      : void 0;\n    var noUnsafeComponentWillRecieveProps =\n      typeof instance.UNSAFE_componentWillRecieveProps !== \"function\";\n    !noUnsafeComponentWillRecieveProps\n      ? warning(\n          false,\n          \"%s has a method called \" +\n            \"UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\",\n          name\n        )\n      : void 0;\n    var hasMutatedProps = instance.props !== workInProgress.pendingProps;\n    !(instance.props === undefined || !hasMutatedProps)\n      ? warning(\n          false,\n          \"%s(...): When calling super() in `%s`, make sure to pass \" +\n            \"up the same props that your component's constructor was passed.\",\n          name,\n          name\n        )\n      : void 0;\n    var noInstanceDefaultProps = !instance.defaultProps;\n    !noInstanceDefaultProps\n      ? warning(\n          false,\n          \"Setting defaultProps as an instance property on %s is not supported and will be ignored.\" +\n            \" Instead, define defaultProps as a static property on %s.\",\n          name,\n          name\n        )\n      : void 0;\n\n    if (\n      typeof instance.getSnapshotBeforeUpdate === \"function\" &&\n      typeof instance.componentDidUpdate !== \"function\" &&\n      !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type)\n    ) {\n      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type);\n      warning(\n        false,\n        \"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). \" +\n          \"This component defines getSnapshotBeforeUpdate() only.\",\n        getComponentName(workInProgress)\n      );\n    }\n\n    var noInstanceGetDerivedStateFromProps =\n      typeof instance.getDerivedStateFromProps !== \"function\";\n    !noInstanceGetDerivedStateFromProps\n      ? warning(\n          false,\n          \"%s: getDerivedStateFromProps() is defined as an instance method \" +\n            \"and will be ignored. Instead, declare it as a static method.\",\n          name\n        )\n      : void 0;\n    var noInstanceGetDerivedStateFromCatch =\n      typeof instance.getDerivedStateFromCatch !== \"function\";\n    !noInstanceGetDerivedStateFromCatch\n      ? warning(\n          false,\n          \"%s: getDerivedStateFromCatch() is defined as an instance method \" +\n            \"and will be ignored. Instead, declare it as a static method.\",\n          name\n        )\n      : void 0;\n    var noStaticGetSnapshotBeforeUpdate =\n      typeof type.getSnapshotBeforeUpdate !== \"function\";\n    !noStaticGetSnapshotBeforeUpdate\n      ? warning(\n          false,\n          \"%s: getSnapshotBeforeUpdate() is defined as a static method \" +\n            \"and will be ignored. Instead, declare it as an instance method.\",\n          name\n        )\n      : void 0;\n    var _state = instance.state;\n    if (_state && (typeof _state !== \"object\" || isArray(_state))) {\n      warning(false, \"%s.state: must be set to an object or null\", name);\n    }\n    if (typeof instance.getChildContext === \"function\") {\n      !(typeof type.childContextTypes === \"object\")\n        ? warning(\n            false,\n            \"%s.getChildContext(): childContextTypes must be defined in order to \" +\n              \"use getChildContext().\",\n            name\n          )\n        : void 0;\n    }\n  }\n}\n\nfunction adoptClassInstance(workInProgress, instance) {\n  instance.updater = classComponentUpdater;\n  workInProgress.stateNode = instance;\n  // The instance needs access to the fiber so that it can schedule updates\n  set(instance, workInProgress);\n  {\n    instance._reactInternalInstance = fakeInternalInstance;\n  }\n}\n\nfunction constructClassInstance(workInProgress, props, renderExpirationTime) {\n  var ctor = workInProgress.type;\n  var unmaskedContext = getUnmaskedContext(workInProgress);\n  var needsContext = isContextConsumer(workInProgress);\n  var context = needsContext\n    ? getMaskedContext(workInProgress, unmaskedContext)\n    : emptyObject;\n\n  // Instantiate twice to help detect side-effects.\n  {\n    if (\n      debugRenderPhaseSideEffects ||\n      (debugRenderPhaseSideEffectsForStrictMode &&\n        workInProgress.mode & StrictMode)\n    ) {\n      new ctor(props, context); // eslint-disable-line no-new\n    }\n  }\n\n  var instance = new ctor(props, context);\n  var state = (workInProgress.memoizedState =\n    instance.state !== null && instance.state !== undefined\n      ? instance.state\n      : null);\n  adoptClassInstance(workInProgress, instance);\n\n  {\n    if (typeof ctor.getDerivedStateFromProps === \"function\" && state === null) {\n      var componentName = getComponentName(workInProgress) || \"Component\";\n      if (!didWarnAboutUninitializedState.has(componentName)) {\n        didWarnAboutUninitializedState.add(componentName);\n        warning(\n          false,\n          \"%s: Did not properly initialize state during construction. \" +\n            \"Expected state to be an object, but it was %s.\",\n          componentName,\n          instance.state === null ? \"null\" : \"undefined\"\n        );\n      }\n    }\n\n    // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n    // Warn about these lifecycles if they are present.\n    // Don't warn about react-lifecycles-compat polyfilled methods though.\n    if (\n      typeof ctor.getDerivedStateFromProps === \"function\" ||\n      typeof instance.getSnapshotBeforeUpdate === \"function\"\n    ) {\n      var foundWillMountName = null;\n      var foundWillReceivePropsName = null;\n      var foundWillUpdateName = null;\n      if (\n        typeof instance.componentWillMount === \"function\" &&\n        instance.componentWillMount.__suppressDeprecationWarning !== true\n      ) {\n        foundWillMountName = \"componentWillMount\";\n      } else if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n        foundWillMountName = \"UNSAFE_componentWillMount\";\n      }\n      if (\n        typeof instance.componentWillReceiveProps === \"function\" &&\n        instance.componentWillReceiveProps.__suppressDeprecationWarning !== true\n      ) {\n        foundWillReceivePropsName = \"componentWillReceiveProps\";\n      } else if (\n        typeof instance.UNSAFE_componentWillReceiveProps === \"function\"\n      ) {\n        foundWillReceivePropsName = \"UNSAFE_componentWillReceiveProps\";\n      }\n      if (\n        typeof instance.componentWillUpdate === \"function\" &&\n        instance.componentWillUpdate.__suppressDeprecationWarning !== true\n      ) {\n        foundWillUpdateName = \"componentWillUpdate\";\n      } else if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n        foundWillUpdateName = \"UNSAFE_componentWillUpdate\";\n      }\n      if (\n        foundWillMountName !== null ||\n        foundWillReceivePropsName !== null ||\n        foundWillUpdateName !== null\n      ) {\n        var _componentName = getComponentName(workInProgress) || \"Component\";\n        var newApiName =\n          typeof ctor.getDerivedStateFromProps === \"function\"\n            ? \"getDerivedStateFromProps()\"\n            : \"getSnapshotBeforeUpdate()\";\n        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n          didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n          warning(\n            false,\n            \"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n\" +\n              \"%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n\" +\n              \"The above lifecycles should be removed. Learn more about this warning here:\\n\" +\n              \"https://fb.me/react-async-component-lifecycle-hooks\",\n            _componentName,\n            newApiName,\n            foundWillMountName !== null ? \"\\n  \" + foundWillMountName : \"\",\n            foundWillReceivePropsName !== null\n              ? \"\\n  \" + foundWillReceivePropsName\n              : \"\",\n            foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : \"\"\n          );\n        }\n      }\n    }\n  }\n\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // ReactFiberContext usually updates this cache but can't for newly-created instances.\n  if (needsContext) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return instance;\n}\n\nfunction callComponentWillMount(workInProgress, instance) {\n  startPhaseTimer(workInProgress, \"componentWillMount\");\n  var oldState = instance.state;\n\n  if (typeof instance.componentWillMount === \"function\") {\n    instance.componentWillMount();\n  }\n  if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n    instance.UNSAFE_componentWillMount();\n  }\n\n  stopPhaseTimer();\n\n  if (oldState !== instance.state) {\n    {\n      warning(\n        false,\n        \"%s.componentWillMount(): Assigning directly to this.state is \" +\n          \"deprecated (except inside a component's \" +\n          \"constructor). Use setState instead.\",\n        getComponentName(workInProgress) || \"Component\"\n      );\n    }\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\nfunction callComponentWillReceiveProps(\n  workInProgress,\n  instance,\n  newProps,\n  newContext\n) {\n  var oldState = instance.state;\n  startPhaseTimer(workInProgress, \"componentWillReceiveProps\");\n  if (typeof instance.componentWillReceiveProps === \"function\") {\n    instance.componentWillReceiveProps(newProps, newContext);\n  }\n  if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n    instance.UNSAFE_componentWillReceiveProps(newProps, newContext);\n  }\n  stopPhaseTimer();\n\n  if (instance.state !== oldState) {\n    {\n      var componentName = getComponentName(workInProgress) || \"Component\";\n      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n        didWarnAboutStateAssignmentForComponent.add(componentName);\n        warning(\n          false,\n          \"%s.componentWillReceiveProps(): Assigning directly to \" +\n            \"this.state is deprecated (except inside a component's \" +\n            \"constructor). Use setState instead.\",\n          componentName\n        );\n      }\n    }\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\n// Invokes the mount life-cycles on a previously never rendered instance.\nfunction mountClassInstance(workInProgress, renderExpirationTime) {\n  var ctor = workInProgress.type;\n\n  {\n    checkClassInstance(workInProgress);\n  }\n\n  var instance = workInProgress.stateNode;\n  var props = workInProgress.pendingProps;\n  var unmaskedContext = getUnmaskedContext(workInProgress);\n\n  instance.props = props;\n  instance.state = workInProgress.memoizedState;\n  instance.refs = emptyObject;\n  instance.context = getMaskedContext(workInProgress, unmaskedContext);\n\n  {\n    if (workInProgress.mode & StrictMode) {\n      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(\n        workInProgress,\n        instance\n      );\n\n      ReactStrictModeWarnings.recordLegacyContextWarning(\n        workInProgress,\n        instance\n      );\n    }\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.recordDeprecationWarnings(\n        workInProgress,\n        instance\n      );\n    }\n  }\n\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    processUpdateQueue(\n      workInProgress,\n      updateQueue,\n      props,\n      instance,\n      renderExpirationTime\n    );\n    instance.state = workInProgress.memoizedState;\n  }\n\n  var getDerivedStateFromProps = workInProgress.type.getDerivedStateFromProps;\n  if (typeof getDerivedStateFromProps === \"function\") {\n    applyDerivedStateFromProps(workInProgress, getDerivedStateFromProps, props);\n    instance.state = workInProgress.memoizedState;\n  }\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (\n    typeof ctor.getDerivedStateFromProps !== \"function\" &&\n    typeof instance.getSnapshotBeforeUpdate !== \"function\" &&\n    (typeof instance.UNSAFE_componentWillMount === \"function\" ||\n      typeof instance.componentWillMount === \"function\")\n  ) {\n    callComponentWillMount(workInProgress, instance);\n    // If we had additional state updates during this life-cycle, let's\n    // process them now.\n    updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null) {\n      processUpdateQueue(\n        workInProgress,\n        updateQueue,\n        props,\n        instance,\n        renderExpirationTime\n      );\n      instance.state = workInProgress.memoizedState;\n    }\n  }\n\n  if (typeof instance.componentDidMount === \"function\") {\n    workInProgress.effectTag |= Update;\n  }\n}\n\nfunction resumeMountClassInstance(workInProgress, renderExpirationTime) {\n  var ctor = workInProgress.type;\n  var instance = workInProgress.stateNode;\n\n  var oldProps = workInProgress.memoizedProps;\n  var newProps = workInProgress.pendingProps;\n  instance.props = oldProps;\n\n  var oldContext = instance.context;\n  var newUnmaskedContext = getUnmaskedContext(workInProgress);\n  var newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  var hasNewLifecycles =\n    typeof getDerivedStateFromProps === \"function\" ||\n    typeof instance.getSnapshotBeforeUpdate === \"function\";\n\n  // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (\n    !hasNewLifecycles &&\n    (typeof instance.UNSAFE_componentWillReceiveProps === \"function\" ||\n      typeof instance.componentWillReceiveProps === \"function\")\n  ) {\n    if (oldProps !== newProps || oldContext !== newContext) {\n      callComponentWillReceiveProps(\n        workInProgress,\n        instance,\n        newProps,\n        newContext\n      );\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n\n  var oldState = workInProgress.memoizedState;\n  var newState = (instance.state = oldState);\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    processUpdateQueue(\n      workInProgress,\n      updateQueue,\n      newProps,\n      instance,\n      renderExpirationTime\n    );\n    newState = workInProgress.memoizedState;\n  }\n  if (\n    oldProps === newProps &&\n    oldState === newState &&\n    !hasContextChanged() &&\n    !checkHasForceUpdateAfterProcessing()\n  ) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === \"function\") {\n      workInProgress.effectTag |= Update;\n    }\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === \"function\") {\n    applyDerivedStateFromProps(\n      workInProgress,\n      getDerivedStateFromProps,\n      newProps\n    );\n    newState = workInProgress.memoizedState;\n  }\n\n  var shouldUpdate =\n    checkHasForceUpdateAfterProcessing() ||\n    checkShouldComponentUpdate(\n      workInProgress,\n      oldProps,\n      newProps,\n      oldState,\n      newState,\n      newContext\n    );\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (\n      !hasNewLifecycles &&\n      (typeof instance.UNSAFE_componentWillMount === \"function\" ||\n        typeof instance.componentWillMount === \"function\")\n    ) {\n      startPhaseTimer(workInProgress, \"componentWillMount\");\n      if (typeof instance.componentWillMount === \"function\") {\n        instance.componentWillMount();\n      }\n      if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n        instance.UNSAFE_componentWillMount();\n      }\n      stopPhaseTimer();\n    }\n    if (typeof instance.componentDidMount === \"function\") {\n      workInProgress.effectTag |= Update;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === \"function\") {\n      workInProgress.effectTag |= Update;\n    }\n\n    // If shouldComponentUpdate returned false, we should still update the\n    // memoized state to indicate that this work can be reused.\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  }\n\n  // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = newContext;\n\n  return shouldUpdate;\n}\n\n// Invokes the update life-cycles and returns false if it shouldn't rerender.\nfunction updateClassInstance(current, workInProgress, renderExpirationTime) {\n  var ctor = workInProgress.type;\n  var instance = workInProgress.stateNode;\n\n  var oldProps = workInProgress.memoizedProps;\n  var newProps = workInProgress.pendingProps;\n  instance.props = oldProps;\n\n  var oldContext = instance.context;\n  var newUnmaskedContext = getUnmaskedContext(workInProgress);\n  var newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  var hasNewLifecycles =\n    typeof getDerivedStateFromProps === \"function\" ||\n    typeof instance.getSnapshotBeforeUpdate === \"function\";\n\n  // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (\n    !hasNewLifecycles &&\n    (typeof instance.UNSAFE_componentWillReceiveProps === \"function\" ||\n      typeof instance.componentWillReceiveProps === \"function\")\n  ) {\n    if (oldProps !== newProps || oldContext !== newContext) {\n      callComponentWillReceiveProps(\n        workInProgress,\n        instance,\n        newProps,\n        newContext\n      );\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n\n  var oldState = workInProgress.memoizedState;\n  var newState = (instance.state = oldState);\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    processUpdateQueue(\n      workInProgress,\n      updateQueue,\n      newProps,\n      instance,\n      renderExpirationTime\n    );\n    newState = workInProgress.memoizedState;\n  }\n\n  if (\n    oldProps === newProps &&\n    oldState === newState &&\n    !hasContextChanged() &&\n    !checkHasForceUpdateAfterProcessing()\n  ) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === \"function\") {\n      if (\n        oldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.effectTag |= Update;\n      }\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n      if (\n        oldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.effectTag |= Snapshot;\n      }\n    }\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === \"function\") {\n    applyDerivedStateFromProps(\n      workInProgress,\n      getDerivedStateFromProps,\n      newProps\n    );\n    newState = workInProgress.memoizedState;\n  }\n\n  var shouldUpdate =\n    checkHasForceUpdateAfterProcessing() ||\n    checkShouldComponentUpdate(\n      workInProgress,\n      oldProps,\n      newProps,\n      oldState,\n      newState,\n      newContext\n    );\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (\n      !hasNewLifecycles &&\n      (typeof instance.UNSAFE_componentWillUpdate === \"function\" ||\n        typeof instance.componentWillUpdate === \"function\")\n    ) {\n      startPhaseTimer(workInProgress, \"componentWillUpdate\");\n      if (typeof instance.componentWillUpdate === \"function\") {\n        instance.componentWillUpdate(newProps, newState, newContext);\n      }\n      if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n        instance.UNSAFE_componentWillUpdate(newProps, newState, newContext);\n      }\n      stopPhaseTimer();\n    }\n    if (typeof instance.componentDidUpdate === \"function\") {\n      workInProgress.effectTag |= Update;\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n      workInProgress.effectTag |= Snapshot;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === \"function\") {\n      if (\n        oldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.effectTag |= Update;\n      }\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n      if (\n        oldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.effectTag |= Snapshot;\n      }\n    }\n\n    // If shouldComponentUpdate returned false, we should still update the\n    // memoized props/state to indicate that this work can be reused.\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  }\n\n  // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = newContext;\n\n  return shouldUpdate;\n}\n\nvar getCurrentFiberStackAddendum$2 =\n  ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar didWarnAboutMaps = void 0;\nvar didWarnAboutStringRefInStrictMode = void 0;\nvar ownerHasKeyUseWarning = void 0;\nvar ownerHasFunctionTypeWarning = void 0;\nvar warnForMissingKey = function(child) {};\n\n{\n  didWarnAboutMaps = false;\n  didWarnAboutStringRefInStrictMode = {};\n\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n  ownerHasKeyUseWarning = {};\n  ownerHasFunctionTypeWarning = {};\n\n  warnForMissingKey = function(child) {\n    if (child === null || typeof child !== \"object\") {\n      return;\n    }\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n    invariant(\n      typeof child._store === \"object\",\n      \"React Component in warnForMissingKey should have a _store. \" +\n        \"This error is likely caused by a bug in React. Please file an issue.\"\n    );\n    child._store.validated = true;\n\n    var currentComponentErrorInfo =\n      \"Each child in an array or iterator should have a unique \" +\n      '\"key\" prop. See https://fb.me/react-warning-keys for ' +\n      \"more information.\" +\n      (getCurrentFiberStackAddendum$2() || \"\");\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n    warning(\n      false,\n      \"Each child in an array or iterator should have a unique \" +\n        '\"key\" prop. See https://fb.me/react-warning-keys for ' +\n        \"more information.%s\",\n      getCurrentFiberStackAddendum$2()\n    );\n  };\n}\n\nvar isArray$1 = Array.isArray;\n\nfunction coerceRef(returnFiber, current, element) {\n  var mixedRef = element.ref;\n  if (\n    mixedRef !== null &&\n    typeof mixedRef !== \"function\" &&\n    typeof mixedRef !== \"object\"\n  ) {\n    {\n      if (returnFiber.mode & StrictMode) {\n        var componentName = getComponentName(returnFiber) || \"Component\";\n        if (!didWarnAboutStringRefInStrictMode[componentName]) {\n          warning(\n            false,\n            'A string ref, \"%s\",has been found within a strict mode tree. ' +\n              \"String refs are a source of potential bugs and should be avoided. \" +\n              \"We recommend using createRef() instead.\" +\n              \"\\n%s\" +\n              \"\\n\\nLearn more about using refs safely here:\" +\n              \"\\nhttps://fb.me/react-strict-mode-string-ref\",\n            mixedRef,\n            getStackAddendumByWorkInProgressFiber(returnFiber)\n          );\n          didWarnAboutStringRefInStrictMode[componentName] = true;\n        }\n      }\n    }\n\n    if (element._owner) {\n      var owner = element._owner;\n      var inst = void 0;\n      if (owner) {\n        var ownerFiber = owner;\n        invariant(\n          ownerFiber.tag === ClassComponent,\n          \"Stateless function components cannot have refs.\"\n        );\n        inst = ownerFiber.stateNode;\n      }\n      invariant(\n        inst,\n        \"Missing owner for string ref %s. This error is likely caused by a \" +\n          \"bug in React. Please file an issue.\",\n        mixedRef\n      );\n      var stringRef = \"\" + mixedRef;\n      // Check if previous string ref matches new string ref\n      if (\n        current !== null &&\n        current.ref !== null &&\n        typeof current.ref === \"function\" &&\n        current.ref._stringRef === stringRef\n      ) {\n        return current.ref;\n      }\n      var ref = function(value) {\n        var refs = inst.refs === emptyObject ? (inst.refs = {}) : inst.refs;\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      invariant(\n        typeof mixedRef === \"string\",\n        \"Expected ref to be a function or a string.\"\n      );\n      invariant(\n        element._owner,\n        \"Element ref was specified as a string (%s) but no owner was set. This could happen for one of\" +\n          \" the following reasons:\\n\" +\n          \"1. You may be adding a ref to a functional component\\n\" +\n          \"2. You may be adding a ref to a component that was not created inside a component's render method\\n\" +\n          \"3. You have multiple copies of React loaded\\n\" +\n          \"See https://fb.me/react-refs-must-have-owner for more information.\",\n        mixedRef\n      );\n    }\n  }\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  if (returnFiber.type !== \"textarea\") {\n    var addendum = \"\";\n    {\n      addendum =\n        \" If you meant to render a collection of children, use an array \" +\n        \"instead.\" +\n        (getCurrentFiberStackAddendum$2() || \"\");\n    }\n    invariant(\n      false,\n      \"Objects are not valid as a React child (found: %s).%s\",\n      Object.prototype.toString.call(newChild) === \"[object Object]\"\n        ? \"object with keys {\" + Object.keys(newChild).join(\", \") + \"}\"\n        : newChild,\n      addendum\n    );\n  }\n}\n\nfunction warnOnFunctionType() {\n  var currentComponentErrorInfo =\n    \"Functions are not valid as a React child. This may happen if \" +\n    \"you return a Component instead of <Component /> from render. \" +\n    \"Or maybe you meant to call this function rather than return it.\" +\n    (getCurrentFiberStackAddendum$2() || \"\");\n\n  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n\n  warning(\n    false,\n    \"Functions are not valid as a React child. This may happen if \" +\n      \"you return a Component instead of <Component /> from render. \" +\n      \"Or maybe you meant to call this function rather than return it.%s\",\n    getCurrentFiberStackAddendum$2() || \"\"\n  );\n}\n\n// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n    // Deletions are added in reversed order so we add it to the front.\n    // At this point, the return fiber's effect list is empty except for\n    // deletions, so we can just append the deletion to the list. The remaining\n    // effects aren't added until the complete phase. Once we implement\n    // resuming, this may not be true.\n    var last = returnFiber.lastEffect;\n    if (last !== null) {\n      last.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n    childToDelete.nextEffect = null;\n    childToDelete.effectTag = Deletion;\n  }\n\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    }\n\n    // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n    var childToDelete = currentFirstChild;\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n    return null;\n  }\n\n  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    var existingChildren = new Map();\n\n    var existingChild = currentFirstChild;\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n      existingChild = existingChild.sibling;\n    }\n    return existingChildren;\n  }\n\n  function useFiber(fiber, pendingProps, expirationTime) {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return lastPlacedIndex;\n    }\n    var current = newFiber.alternate;\n    if (current !== null) {\n      var oldIndex = current.index;\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.effectTag = Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.effectTag = Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber) {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.effectTag = Placement;\n    }\n    return newFiber;\n  }\n\n  function updateTextNode(returnFiber, current, textContent, expirationTime) {\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      var created = createFiberFromText(\n        textContent,\n        returnFiber.mode,\n        expirationTime\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, textContent, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(returnFiber, current, element, expirationTime) {\n    if (current !== null && current.type === element.type) {\n      // Move based on index\n      var existing = useFiber(current, element.props, expirationTime);\n      existing.ref = coerceRef(returnFiber, current, element);\n      existing.return = returnFiber;\n      {\n        existing._debugSource = element._source;\n        existing._debugOwner = element._owner;\n      }\n      return existing;\n    } else {\n      // Insert\n      var created = createFiberFromElement(\n        element,\n        returnFiber.mode,\n        expirationTime\n      );\n      created.ref = coerceRef(returnFiber, current, element);\n      created.return = returnFiber;\n      return created;\n    }\n  }\n\n  function updatePortal(returnFiber, current, portal, expirationTime) {\n    if (\n      current === null ||\n      current.tag !== HostPortal ||\n      current.stateNode.containerInfo !== portal.containerInfo ||\n      current.stateNode.implementation !== portal.implementation\n    ) {\n      // Insert\n      var created = createFiberFromPortal(\n        portal,\n        returnFiber.mode,\n        expirationTime\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, portal.children || [], expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(returnFiber, current, fragment, expirationTime, key) {\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      var created = createFiberFromFragment(\n        fragment,\n        returnFiber.mode,\n        expirationTime,\n        key\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, fragment, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(returnFiber, newChild, expirationTime) {\n    if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      var created = createFiberFromText(\n        \"\" + newChild,\n        returnFiber.mode,\n        expirationTime\n      );\n      created.return = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === \"object\" && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          var _created = createFiberFromElement(\n            newChild,\n            returnFiber.mode,\n            expirationTime\n          );\n          _created.ref = coerceRef(returnFiber, null, newChild);\n          _created.return = returnFiber;\n          return _created;\n        }\n        case REACT_PORTAL_TYPE: {\n          var _created2 = createFiberFromPortal(\n            newChild,\n            returnFiber.mode,\n            expirationTime\n          );\n          _created2.return = returnFiber;\n          return _created2;\n        }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _created3 = createFiberFromFragment(\n          newChild,\n          returnFiber.mode,\n          expirationTime,\n          null\n        );\n        _created3.return = returnFiber;\n        return _created3;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === \"function\") {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {\n    // Update the fiber if the keys match, otherwise return null.\n\n    var key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n      return updateTextNode(\n        returnFiber,\n        oldFiber,\n        \"\" + newChild,\n        expirationTime\n      );\n    }\n\n    if (typeof newChild === \"object\" && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          if (newChild.key === key) {\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              return updateFragment(\n                returnFiber,\n                oldFiber,\n                newChild.props.children,\n                expirationTime,\n                key\n              );\n            }\n            return updateElement(\n              returnFiber,\n              oldFiber,\n              newChild,\n              expirationTime\n            );\n          } else {\n            return null;\n          }\n        }\n        case REACT_PORTAL_TYPE: {\n          if (newChild.key === key) {\n            return updatePortal(\n              returnFiber,\n              oldFiber,\n              newChild,\n              expirationTime\n            );\n          } else {\n            return null;\n          }\n        }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(\n          returnFiber,\n          oldFiber,\n          newChild,\n          expirationTime,\n          null\n        );\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === \"function\") {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(\n    existingChildren,\n    returnFiber,\n    newIdx,\n    newChild,\n    expirationTime\n  ) {\n    if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      var matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(\n        returnFiber,\n        matchedFiber,\n        \"\" + newChild,\n        expirationTime\n      );\n    }\n\n    if (typeof newChild === \"object\" && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          var _matchedFiber =\n            existingChildren.get(\n              newChild.key === null ? newIdx : newChild.key\n            ) || null;\n          if (newChild.type === REACT_FRAGMENT_TYPE) {\n            return updateFragment(\n              returnFiber,\n              _matchedFiber,\n              newChild.props.children,\n              expirationTime,\n              newChild.key\n            );\n          }\n          return updateElement(\n            returnFiber,\n            _matchedFiber,\n            newChild,\n            expirationTime\n          );\n        }\n        case REACT_PORTAL_TYPE: {\n          var _matchedFiber2 =\n            existingChildren.get(\n              newChild.key === null ? newIdx : newChild.key\n            ) || null;\n          return updatePortal(\n            returnFiber,\n            _matchedFiber2,\n            newChild,\n            expirationTime\n          );\n        }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _matchedFiber3 = existingChildren.get(newIdx) || null;\n        return updateFragment(\n          returnFiber,\n          _matchedFiber3,\n          newChild,\n          expirationTime,\n          null\n        );\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === \"function\") {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n  function warnOnInvalidKey(child, knownKeys) {\n    {\n      if (typeof child !== \"object\" || child === null) {\n        return knownKeys;\n      }\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child);\n          var key = child.key;\n          if (typeof key !== \"string\") {\n            break;\n          }\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n          warning(\n            false,\n            \"Encountered two children with the same key, `%s`. \" +\n              \"Keys should be unique so that components maintain their identity \" +\n              \"across updates. Non-unique keys may cause children to be \" +\n              \"duplicated and/or omitted  the behavior is unsupported and \" +\n              \"could change in a future version.%s\",\n            key,\n            getCurrentFiberStackAddendum$2()\n          );\n          break;\n        default:\n          break;\n      }\n    }\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(\n    returnFiber,\n    currentFirstChild,\n    newChildren,\n    expirationTime\n  ) {\n    // This algorithm can't optimize by searching from boths ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n\n    {\n      // First, validate keys.\n      var knownKeys = null;\n      for (var i = 0; i < newChildren.length; i++) {\n        var child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys);\n      }\n    }\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        newChildren[newIdx],\n        expirationTime\n      );\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        var _newFiber = createChild(\n          returnFiber,\n          newChildren[newIdx],\n          expirationTime\n        );\n        if (!_newFiber) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber;\n        } else {\n          previousNewFiber.sibling = _newFiber;\n        }\n        previousNewFiber = _newFiber;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; newIdx < newChildren.length; newIdx++) {\n      var _newFiber2 = updateFromMap(\n        existingChildren,\n        returnFiber,\n        newIdx,\n        newChildren[newIdx],\n        expirationTime\n      );\n      if (_newFiber2) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber2.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(\n              _newFiber2.key === null ? newIdx : _newFiber2.key\n            );\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber2;\n        } else {\n          previousNewFiber.sibling = _newFiber2;\n        }\n        previousNewFiber = _newFiber2;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function(child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(\n    returnFiber,\n    currentFirstChild,\n    newChildrenIterable,\n    expirationTime\n  ) {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n\n    var iteratorFn = getIteratorFn(newChildrenIterable);\n    invariant(\n      typeof iteratorFn === \"function\",\n      \"An object is not an iterable. This error is likely caused by a bug in \" +\n        \"React. Please file an issue.\"\n    );\n\n    {\n      // Warn about using Maps as children\n      if (newChildrenIterable.entries === iteratorFn) {\n        !didWarnAboutMaps\n          ? warning(\n              false,\n              \"Using Maps as children is unsupported and will likely yield \" +\n                \"unexpected results. Convert it to a sequence/iterable of keyed \" +\n                \"ReactElements instead.%s\",\n              getCurrentFiberStackAddendum$2()\n            )\n          : void 0;\n        didWarnAboutMaps = true;\n      }\n\n      // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n      var _newChildren = iteratorFn.call(newChildrenIterable);\n      if (_newChildren) {\n        var knownKeys = null;\n        var _step = _newChildren.next();\n        for (; !_step.done; _step = _newChildren.next()) {\n          var child = _step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys);\n        }\n      }\n    }\n\n    var newChildren = iteratorFn.call(newChildrenIterable);\n    invariant(newChildren != null, \"An iterable object provided no iterator.\");\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n\n    var step = newChildren.next();\n    for (\n      ;\n      oldFiber !== null && !step.done;\n      newIdx++, step = newChildren.next()\n    ) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        step.value,\n        expirationTime\n      );\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (!oldFiber) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);\n        if (_newFiber3 === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber3;\n        } else {\n          previousNewFiber.sibling = _newFiber3;\n        }\n        previousNewFiber = _newFiber3;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      var _newFiber4 = updateFromMap(\n        existingChildren,\n        returnFiber,\n        newIdx,\n        step.value,\n        expirationTime\n      );\n      if (_newFiber4 !== null) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber4.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(\n              _newFiber4.key === null ? newIdx : _newFiber4.key\n            );\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber4;\n        } else {\n          previousNewFiber.sibling = _newFiber4;\n        }\n        previousNewFiber = _newFiber4;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function(child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(\n    returnFiber,\n    currentFirstChild,\n    textContent,\n    expirationTime\n  ) {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      var existing = useFiber(currentFirstChild, textContent, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n    // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    var created = createFiberFromText(\n      textContent,\n      returnFiber.mode,\n      expirationTime\n    );\n    created.return = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(\n    returnFiber,\n    currentFirstChild,\n    element,\n    expirationTime\n  ) {\n    var key = element.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (\n          child.tag === Fragment\n            ? element.type === REACT_FRAGMENT_TYPE\n            : child.type === element.type\n        ) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(\n            child,\n            element.type === REACT_FRAGMENT_TYPE\n              ? element.props.children\n              : element.props,\n            expirationTime\n          );\n          existing.ref = coerceRef(returnFiber, child, element);\n          existing.return = returnFiber;\n          {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      var created = createFiberFromFragment(\n        element.props.children,\n        returnFiber.mode,\n        expirationTime,\n        element.key\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      var _created4 = createFiberFromElement(\n        element,\n        returnFiber.mode,\n        expirationTime\n      );\n      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);\n      _created4.return = returnFiber;\n      return _created4;\n    }\n  }\n\n  function reconcileSinglePortal(\n    returnFiber,\n    currentFirstChild,\n    portal,\n    expirationTime\n  ) {\n    var key = portal.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (\n          child.tag === HostPortal &&\n          child.stateNode.containerInfo === portal.containerInfo &&\n          child.stateNode.implementation === portal.implementation\n        ) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, portal.children || [], expirationTime);\n          existing.return = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    var created = createFiberFromPortal(\n      portal,\n      returnFiber.mode,\n      expirationTime\n    );\n    created.return = returnFiber;\n    return created;\n  }\n\n  // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n  function reconcileChildFibers(\n    returnFiber,\n    currentFirstChild,\n    newChild,\n    expirationTime\n  ) {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    var isUnkeyedTopLevelFragment =\n      typeof newChild === \"object\" &&\n      newChild !== null &&\n      newChild.type === REACT_FRAGMENT_TYPE &&\n      newChild.key === null;\n    if (isUnkeyedTopLevelFragment) {\n      newChild = newChild.props.children;\n    }\n\n    // Handle object types\n    var isObject = typeof newChild === \"object\" && newChild !== null;\n\n    if (isObject) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(\n            reconcileSingleElement(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              expirationTime\n            )\n          );\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(\n            reconcileSinglePortal(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              expirationTime\n            )\n          );\n      }\n    }\n\n    if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n      return placeSingleChild(\n        reconcileSingleTextNode(\n          returnFiber,\n          currentFirstChild,\n          \"\" + newChild,\n          expirationTime\n        )\n      );\n    }\n\n    if (isArray$1(newChild)) {\n      return reconcileChildrenArray(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        expirationTime\n      );\n    }\n\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        expirationTime\n      );\n    }\n\n    if (isObject) {\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === \"function\") {\n        warnOnFunctionType();\n      }\n    }\n    if (typeof newChild === \"undefined\" && !isUnkeyedTopLevelFragment) {\n      // If the new child is undefined, and the return fiber is a composite\n      // component, throw an error. If Fiber return types are disabled,\n      // we already threw above.\n      switch (returnFiber.tag) {\n        case ClassComponent: {\n          {\n            var instance = returnFiber.stateNode;\n            if (instance.render._isMockFunction) {\n              // We allow auto-mocks to proceed as if they're returning null.\n              break;\n            }\n          }\n        }\n        // Intentionally fall through to the next case, which handles both\n        // functions and classes\n        // eslint-disable-next-lined no-fallthrough\n        case FunctionalComponent: {\n          var Component = returnFiber.type;\n          invariant(\n            false,\n            \"%s(...): Nothing was returned from render. This usually means a \" +\n              \"return statement is missing. Or, to render nothing, \" +\n              \"return null.\",\n            Component.displayName || Component.name || \"Component\"\n          );\n        }\n      }\n    }\n\n    // Remaining cases are all treated as empty.\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nvar reconcileChildFibers = ChildReconciler(true);\nvar mountChildFibers = ChildReconciler(false);\n\nfunction cloneChildFibers(current, workInProgress) {\n  invariant(\n    current === null || workInProgress.child === current.child,\n    \"Resuming work not yet implemented.\"\n  );\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  var currentChild = workInProgress.child;\n  var newChild = createWorkInProgress(\n    currentChild,\n    currentChild.pendingProps,\n    currentChild.expirationTime\n  );\n  workInProgress.child = newChild;\n\n  newChild.return = workInProgress;\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(\n      currentChild,\n      currentChild.pendingProps,\n      currentChild.expirationTime\n    );\n    newChild.return = workInProgress;\n  }\n  newChild.sibling = null;\n}\n\n// The deepest Fiber on the stack involved in a hydration context.\n// This may have been an insertion or a hydration.\nvar hydrationParentFiber = null;\nvar nextHydratableInstance = null;\nvar isHydrating = false;\n\nfunction enterHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  var parentInstance = fiber.stateNode.containerInfo;\n  nextHydratableInstance = getFirstHydratableChild(parentInstance);\n  hydrationParentFiber = fiber;\n  isHydrating = true;\n  return true;\n}\n\nfunction deleteHydratableInstance(returnFiber, instance) {\n  {\n    switch (returnFiber.tag) {\n      case HostRoot:\n        didNotHydrateContainerInstance(\n          returnFiber.stateNode.containerInfo,\n          instance\n        );\n        break;\n      case HostComponent:\n        didNotHydrateInstance(\n          returnFiber.type,\n          returnFiber.memoizedProps,\n          returnFiber.stateNode,\n          instance\n        );\n        break;\n    }\n  }\n\n  var childToDelete = createFiberFromHostInstanceForDeletion();\n  childToDelete.stateNode = instance;\n  childToDelete.return = returnFiber;\n  childToDelete.effectTag = Deletion;\n\n  // This might seem like it belongs on progressedFirstDeletion. However,\n  // these children are not part of the reconciliation list of children.\n  // Even if we abort and rereconcile the children, that will try to hydrate\n  // again and the nodes are still in the host tree so these will be\n  // recreated.\n  if (returnFiber.lastEffect !== null) {\n    returnFiber.lastEffect.nextEffect = childToDelete;\n    returnFiber.lastEffect = childToDelete;\n  } else {\n    returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n  }\n}\n\nfunction insertNonHydratedInstance(returnFiber, fiber) {\n  fiber.effectTag |= Placement;\n  {\n    switch (returnFiber.tag) {\n      case HostRoot: {\n        var parentContainer = returnFiber.stateNode.containerInfo;\n        switch (fiber.tag) {\n          case HostComponent:\n            var type = fiber.type;\n            var props = fiber.pendingProps;\n            didNotFindHydratableContainerInstance(parentContainer, type, props);\n            break;\n          case HostText:\n            var text = fiber.pendingProps;\n            didNotFindHydratableContainerTextInstance(parentContainer, text);\n            break;\n        }\n        break;\n      }\n      case HostComponent: {\n        var parentType = returnFiber.type;\n        var parentProps = returnFiber.memoizedProps;\n        var parentInstance = returnFiber.stateNode;\n        switch (fiber.tag) {\n          case HostComponent:\n            var _type = fiber.type;\n            var _props = fiber.pendingProps;\n            didNotFindHydratableInstance(\n              parentType,\n              parentProps,\n              parentInstance,\n              _type,\n              _props\n            );\n            break;\n          case HostText:\n            var _text = fiber.pendingProps;\n            didNotFindHydratableTextInstance(\n              parentType,\n              parentProps,\n              parentInstance,\n              _text\n            );\n            break;\n        }\n        break;\n      }\n      default:\n        return;\n    }\n  }\n}\n\nfunction tryHydrate(fiber, nextInstance) {\n  switch (fiber.tag) {\n    case HostComponent: {\n      var type = fiber.type;\n      var props = fiber.pendingProps;\n      var instance = canHydrateInstance(nextInstance, type, props);\n      if (instance !== null) {\n        fiber.stateNode = instance;\n        return true;\n      }\n      return false;\n    }\n    case HostText: {\n      var text = fiber.pendingProps;\n      var textInstance = canHydrateTextInstance(nextInstance, text);\n      if (textInstance !== null) {\n        fiber.stateNode = textInstance;\n        return true;\n      }\n      return false;\n    }\n    default:\n      return false;\n  }\n}\n\nfunction tryToClaimNextHydratableInstance(fiber) {\n  if (!isHydrating) {\n    return;\n  }\n  var nextInstance = nextHydratableInstance;\n  if (!nextInstance) {\n    // Nothing to hydrate. Make it an insertion.\n    insertNonHydratedInstance(hydrationParentFiber, fiber);\n    isHydrating = false;\n    hydrationParentFiber = fiber;\n    return;\n  }\n  var firstAttemptedInstance = nextInstance;\n  if (!tryHydrate(fiber, nextInstance)) {\n    // If we can't hydrate this instance let's try the next one.\n    // We use this as a heuristic. It's based on intuition and not data so it\n    // might be flawed or unnecessary.\n    nextInstance = getNextHydratableSibling(firstAttemptedInstance);\n    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance(hydrationParentFiber, fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    }\n    // We matched the next one, we'll now assume that the first one was\n    // superfluous and we'll delete it. Since we can't eagerly delete it\n    // we'll have to schedule a deletion. To do that, this node needs a dummy\n    // fiber associated with it.\n    deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);\n  }\n  hydrationParentFiber = fiber;\n  nextHydratableInstance = getFirstHydratableChild(nextInstance);\n}\n\nfunction prepareToHydrateHostInstance(\n  fiber,\n  rootContainerInstance,\n  hostContext\n) {\n  if (!supportsHydration) {\n    invariant(\n      false,\n      \"Expected prepareToHydrateHostInstance() to never be called. \" +\n        \"This error is likely caused by a bug in React. Please file an issue.\"\n    );\n  }\n\n  var instance = fiber.stateNode;\n  var updatePayload = hydrateInstance(\n    instance,\n    fiber.type,\n    fiber.memoizedProps,\n    rootContainerInstance,\n    hostContext,\n    fiber\n  );\n  // TODO: Type this specific to this type of component.\n  fiber.updateQueue = updatePayload;\n  // If the update payload indicates that there is a change or if there\n  // is a new ref we mark this as an update.\n  if (updatePayload !== null) {\n    return true;\n  }\n  return false;\n}\n\nfunction prepareToHydrateHostTextInstance(fiber) {\n  if (!supportsHydration) {\n    invariant(\n      false,\n      \"Expected prepareToHydrateHostTextInstance() to never be called. \" +\n        \"This error is likely caused by a bug in React. Please file an issue.\"\n    );\n  }\n\n  var textInstance = fiber.stateNode;\n  var textContent = fiber.memoizedProps;\n  var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n  {\n    if (shouldUpdate) {\n      // We assume that prepareToHydrateHostTextInstance is called in a context where the\n      // hydration parent is the parent host component of this host text.\n      var returnFiber = hydrationParentFiber;\n      if (returnFiber !== null) {\n        switch (returnFiber.tag) {\n          case HostRoot: {\n            var parentContainer = returnFiber.stateNode.containerInfo;\n            didNotMatchHydratedContainerTextInstance(\n              parentContainer,\n              textInstance,\n              textContent\n            );\n            break;\n          }\n          case HostComponent: {\n            var parentType = returnFiber.type;\n            var parentProps = returnFiber.memoizedProps;\n            var parentInstance = returnFiber.stateNode;\n            didNotMatchHydratedTextInstance(\n              parentType,\n              parentProps,\n              parentInstance,\n              textInstance,\n              textContent\n            );\n            break;\n          }\n        }\n      }\n    }\n  }\n  return shouldUpdate;\n}\n\nfunction popToNextHostParent(fiber) {\n  var parent = fiber.return;\n  while (\n    parent !== null &&\n    parent.tag !== HostComponent &&\n    parent.tag !== HostRoot\n  ) {\n    parent = parent.return;\n  }\n  hydrationParentFiber = parent;\n}\n\nfunction popHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n  if (fiber !== hydrationParentFiber) {\n    // We're deeper than the current hydration context, inside an inserted\n    // tree.\n    return false;\n  }\n  if (!isHydrating) {\n    // If we're not currently hydrating but we're in a hydration context, then\n    // we were an insertion and now need to pop up reenter hydration of our\n    // siblings.\n    popToNextHostParent(fiber);\n    isHydrating = true;\n    return false;\n  }\n\n  var type = fiber.type;\n\n  // If we have any remaining hydratable nodes, we need to delete them now.\n  // We only do this deeper than head and body since they tend to have random\n  // other nodes in them. We also ignore components with pure text content in\n  // side of them.\n  // TODO: Better heuristic.\n  if (\n    fiber.tag !== HostComponent ||\n    (type !== \"head\" &&\n      type !== \"body\" &&\n      !shouldSetTextContent(type, fiber.memoizedProps))\n  ) {\n    var nextInstance = nextHydratableInstance;\n    while (nextInstance) {\n      deleteHydratableInstance(fiber, nextInstance);\n      nextInstance = getNextHydratableSibling(nextInstance);\n    }\n  }\n\n  popToNextHostParent(fiber);\n  nextHydratableInstance = hydrationParentFiber\n    ? getNextHydratableSibling(fiber.stateNode)\n    : null;\n  return true;\n}\n\nfunction resetHydrationState() {\n  if (!supportsHydration) {\n    return;\n  }\n\n  hydrationParentFiber = null;\n  nextHydratableInstance = null;\n  isHydrating = false;\n}\n\nvar getCurrentFiberStackAddendum$1 =\n  ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar didWarnAboutBadClass = void 0;\nvar didWarnAboutGetDerivedStateOnFunctionalComponent = void 0;\nvar didWarnAboutStatelessRefs = void 0;\n\n{\n  didWarnAboutBadClass = {};\n  didWarnAboutGetDerivedStateOnFunctionalComponent = {};\n  didWarnAboutStatelessRefs = {};\n}\n\n// TODO: Remove this and use reconcileChildrenAtExpirationTime directly.\nfunction reconcileChildren(current, workInProgress, nextChildren) {\n  reconcileChildrenAtExpirationTime(\n    current,\n    workInProgress,\n    nextChildren,\n    workInProgress.expirationTime\n  );\n}\n\nfunction reconcileChildrenAtExpirationTime(\n  current,\n  workInProgress,\n  nextChildren,\n  renderExpirationTime\n) {\n  if (current === null) {\n    // If this is a fresh new component that hasn't been rendered yet, we\n    // won't update its child set by applying minimal side-effects. Instead,\n    // we will add them all to the child before it gets rendered. That means\n    // we can optimize this reconciliation pass by not tracking side-effects.\n    workInProgress.child = mountChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderExpirationTime\n    );\n  } else {\n    // If the current child is the same as the work in progress, it means that\n    // we haven't yet started any work on these children. Therefore, we use\n    // the clone algorithm to create a copy of all the current children.\n\n    // If we had any progressed work already, that is invalid at this point so\n    // let's throw it out.\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      current.child,\n      nextChildren,\n      renderExpirationTime\n    );\n  }\n}\n\nfunction updateForwardRef(current, workInProgress) {\n  var render = workInProgress.type.render;\n  var nextProps = workInProgress.pendingProps;\n  var ref = workInProgress.ref;\n  if (hasContextChanged()) {\n    // Normally we can bail out on props equality but if context has changed\n    // we don't do the bailout and we have to reuse existing props instead.\n  } else if (workInProgress.memoizedProps === nextProps) {\n    var currentRef = current !== null ? current.ref : null;\n    if (ref === currentRef) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n  }\n\n  var nextChildren = void 0;\n  {\n    ReactCurrentOwner.current = workInProgress;\n    ReactDebugCurrentFiber.setCurrentPhase(\"render\");\n    nextChildren = render(nextProps, ref);\n    ReactDebugCurrentFiber.setCurrentPhase(null);\n  }\n\n  reconcileChildren(current, workInProgress, nextChildren);\n  memoizeProps(workInProgress, nextProps);\n  return workInProgress.child;\n}\n\nfunction updateFragment(current, workInProgress) {\n  var nextChildren = workInProgress.pendingProps;\n  if (hasContextChanged()) {\n    // Normally we can bail out on props equality but if context has changed\n    // we don't do the bailout and we have to reuse existing props instead.\n  } else if (workInProgress.memoizedProps === nextChildren) {\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n  reconcileChildren(current, workInProgress, nextChildren);\n  memoizeProps(workInProgress, nextChildren);\n  return workInProgress.child;\n}\n\nfunction updateMode(current, workInProgress) {\n  var nextChildren = workInProgress.pendingProps.children;\n  if (hasContextChanged()) {\n    // Normally we can bail out on props equality but if context has changed\n    // we don't do the bailout and we have to reuse existing props instead.\n  } else if (\n    nextChildren === null ||\n    workInProgress.memoizedProps === nextChildren\n  ) {\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n  reconcileChildren(current, workInProgress, nextChildren);\n  memoizeProps(workInProgress, nextChildren);\n  return workInProgress.child;\n}\n\nfunction updateProfiler(current, workInProgress) {\n  var nextProps = workInProgress.pendingProps;\n  if (enableProfilerTimer) {\n    workInProgress.effectTag |= Update;\n  }\n  if (workInProgress.memoizedProps === nextProps) {\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n  var nextChildren = nextProps.children;\n  reconcileChildren(current, workInProgress, nextChildren);\n  memoizeProps(workInProgress, nextProps);\n  return workInProgress.child;\n}\n\nfunction markRef(current, workInProgress) {\n  var ref = workInProgress.ref;\n  if (\n    (current === null && ref !== null) ||\n    (current !== null && current.ref !== ref)\n  ) {\n    // Schedule a Ref effect\n    workInProgress.effectTag |= Ref;\n  }\n}\n\nfunction updateFunctionalComponent(current, workInProgress) {\n  var fn = workInProgress.type;\n  var nextProps = workInProgress.pendingProps;\n\n  if (hasContextChanged()) {\n    // Normally we can bail out on props equality but if context has changed\n    // we don't do the bailout and we have to reuse existing props instead.\n  } else {\n    if (workInProgress.memoizedProps === nextProps) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    // TODO: consider bringing fn.shouldComponentUpdate() back.\n    // It used to be here.\n  }\n\n  var unmaskedContext = getUnmaskedContext(workInProgress);\n  var context = getMaskedContext(workInProgress, unmaskedContext);\n\n  var nextChildren = void 0;\n\n  {\n    ReactCurrentOwner.current = workInProgress;\n    ReactDebugCurrentFiber.setCurrentPhase(\"render\");\n    nextChildren = fn(nextProps, context);\n    ReactDebugCurrentFiber.setCurrentPhase(null);\n  }\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren);\n  memoizeProps(workInProgress, nextProps);\n  return workInProgress.child;\n}\n\nfunction updateClassComponent(current, workInProgress, renderExpirationTime) {\n  // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n  var hasContext = pushContextProvider(workInProgress);\n  var shouldUpdate = void 0;\n  if (current === null) {\n    if (workInProgress.stateNode === null) {\n      // In the initial pass we might need to construct the instance.\n      constructClassInstance(\n        workInProgress,\n        workInProgress.pendingProps,\n        renderExpirationTime\n      );\n      mountClassInstance(workInProgress, renderExpirationTime);\n\n      shouldUpdate = true;\n    } else {\n      // In a resume, we'll already have an instance we can reuse.\n      shouldUpdate = resumeMountClassInstance(\n        workInProgress,\n        renderExpirationTime\n      );\n    }\n  } else {\n    shouldUpdate = updateClassInstance(\n      current,\n      workInProgress,\n      renderExpirationTime\n    );\n  }\n  return finishClassComponent(\n    current,\n    workInProgress,\n    shouldUpdate,\n    hasContext,\n    renderExpirationTime\n  );\n}\n\nfunction finishClassComponent(\n  current,\n  workInProgress,\n  shouldUpdate,\n  hasContext,\n  renderExpirationTime\n) {\n  // Refs should update even if shouldComponentUpdate returns false\n  markRef(current, workInProgress);\n\n  var didCaptureError = (workInProgress.effectTag & DidCapture) !== NoEffect;\n\n  if (!shouldUpdate && !didCaptureError) {\n    // Context providers should defer to sCU for rendering\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, false);\n    }\n\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n\n  var ctor = workInProgress.type;\n  var instance = workInProgress.stateNode;\n\n  // Rerender\n  ReactCurrentOwner.current = workInProgress;\n  var nextChildren = void 0;\n  if (\n    didCaptureError &&\n    (!enableGetDerivedStateFromCatch ||\n      typeof ctor.getDerivedStateFromCatch !== \"function\")\n  ) {\n    // If we captured an error, but getDerivedStateFrom catch is not defined,\n    // unmount all the children. componentDidCatch will schedule an update to\n    // re-render a fallback. This is temporary until we migrate everyone to\n    // the new API.\n    // TODO: Warn in a future release.\n    nextChildren = null;\n\n    if (enableProfilerTimer) {\n      stopBaseRenderTimerIfRunning();\n    }\n  } else {\n    {\n      ReactDebugCurrentFiber.setCurrentPhase(\"render\");\n      nextChildren = instance.render();\n      if (\n        debugRenderPhaseSideEffects ||\n        (debugRenderPhaseSideEffectsForStrictMode &&\n          workInProgress.mode & StrictMode)\n      ) {\n        instance.render();\n      }\n      ReactDebugCurrentFiber.setCurrentPhase(null);\n    }\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  if (didCaptureError) {\n    // If we're recovering from an error, reconcile twice: first to delete\n    // all the existing children.\n    reconcileChildrenAtExpirationTime(\n      current,\n      workInProgress,\n      null,\n      renderExpirationTime\n    );\n    workInProgress.child = null;\n    // Now we can continue reconciling like normal. This has the effect of\n    // remounting all children regardless of whether their their\n    // identity matches.\n  }\n  reconcileChildrenAtExpirationTime(\n    current,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime\n  );\n  // Memoize props and state using the values we just used to render.\n  // TODO: Restructure so we never read values from the instance.\n  memoizeState(workInProgress, instance.state);\n  memoizeProps(workInProgress, instance.props);\n\n  // The context might have changed so we need to recalculate it.\n  if (hasContext) {\n    invalidateContextProvider(workInProgress, true);\n  }\n\n  return workInProgress.child;\n}\n\nfunction pushHostRootContext(workInProgress) {\n  var root = workInProgress.stateNode;\n  if (root.pendingContext) {\n    pushTopLevelContextObject(\n      workInProgress,\n      root.pendingContext,\n      root.pendingContext !== root.context\n    );\n  } else if (root.context) {\n    // Should always be set\n    pushTopLevelContextObject(workInProgress, root.context, false);\n  }\n  pushHostContainer(workInProgress, root.containerInfo);\n}\n\nfunction updateHostRoot(current, workInProgress, renderExpirationTime) {\n  pushHostRootContext(workInProgress);\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    var nextProps = workInProgress.pendingProps;\n    var prevState = workInProgress.memoizedState;\n    var prevChildren = prevState !== null ? prevState.element : null;\n    processUpdateQueue(\n      workInProgress,\n      updateQueue,\n      nextProps,\n      null,\n      renderExpirationTime\n    );\n    var nextState = workInProgress.memoizedState;\n    // Caution: React DevTools currently depends on this property\n    // being called \"element\".\n    var nextChildren = nextState.element;\n\n    if (nextChildren === prevChildren) {\n      // If the state is the same as before, that's a bailout because we had\n      // no work that expires at this time.\n      resetHydrationState();\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    var root = workInProgress.stateNode;\n    if (\n      (current === null || current.child === null) &&\n      root.hydrate &&\n      enterHydrationState(workInProgress)\n    ) {\n      // If we don't have any current children this might be the first pass.\n      // We always try to hydrate. If this isn't a hydration pass there won't\n      // be any children to hydrate which is effectively the same thing as\n      // not hydrating.\n\n      // This is a bit of a hack. We track the host root as a placement to\n      // know that we're currently in a mounting state. That way isMounted\n      // works as expected. We must reset this before committing.\n      // TODO: Delete this when we delete isMounted and findDOMNode.\n      workInProgress.effectTag |= Placement;\n\n      // Ensure that children mount into this root without tracking\n      // side-effects. This ensures that we don't store Placement effects on\n      // nodes that will be hydrated.\n      workInProgress.child = mountChildFibers(\n        workInProgress,\n        null,\n        nextChildren,\n        renderExpirationTime\n      );\n    } else {\n      // Otherwise reset hydration state in case we aborted and resumed another\n      // root.\n      resetHydrationState();\n      reconcileChildren(current, workInProgress, nextChildren);\n    }\n    return workInProgress.child;\n  }\n  resetHydrationState();\n  // If there is no update queue, that's a bailout because the root has no props.\n  return bailoutOnAlreadyFinishedWork(current, workInProgress);\n}\n\nfunction updateHostComponent(current, workInProgress, renderExpirationTime) {\n  pushHostContext(workInProgress);\n\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n\n  var type = workInProgress.type;\n  var memoizedProps = workInProgress.memoizedProps;\n  var nextProps = workInProgress.pendingProps;\n  var prevProps = current !== null ? current.memoizedProps : null;\n\n  if (hasContextChanged()) {\n    // Normally we can bail out on props equality but if context has changed\n    // we don't do the bailout and we have to reuse existing props instead.\n  } else if (memoizedProps === nextProps) {\n    var isHidden =\n      workInProgress.mode & AsyncMode &&\n      shouldDeprioritizeSubtree(type, nextProps);\n    if (isHidden) {\n      // Before bailing out, make sure we've deprioritized a hidden component.\n      workInProgress.expirationTime = Never;\n    }\n    if (!isHidden || renderExpirationTime !== Never) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    // If we're rendering a hidden node at hidden priority, don't bailout. The\n    // parent is complete, but the children may not be.\n  }\n\n  var nextChildren = nextProps.children;\n  var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n  if (isDirectTextChild) {\n    // We special case a direct text child of a host node. This is a common\n    // case. We won't handle it as a reified child. We will instead handle\n    // this in the host environment that also have access to this prop. That\n    // avoids allocating another HostText fiber and traversing it.\n    nextChildren = null;\n  } else if (prevProps && shouldSetTextContent(type, prevProps)) {\n    // If we're switching from a direct text child to a normal child, or to\n    // empty, we need to schedule the text content to be reset.\n    workInProgress.effectTag |= ContentReset;\n  }\n\n  markRef(current, workInProgress);\n\n  // Check the host config to see if the children are offscreen/hidden.\n  if (\n    renderExpirationTime !== Never &&\n    workInProgress.mode & AsyncMode &&\n    shouldDeprioritizeSubtree(type, nextProps)\n  ) {\n    // Down-prioritize the children.\n    workInProgress.expirationTime = Never;\n    // Bailout and come back to this fiber later.\n    workInProgress.memoizedProps = nextProps;\n    return null;\n  }\n\n  reconcileChildren(current, workInProgress, nextChildren);\n  memoizeProps(workInProgress, nextProps);\n  return workInProgress.child;\n}\n\nfunction updateHostText(current, workInProgress) {\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n  var nextProps = workInProgress.pendingProps;\n  memoizeProps(workInProgress, nextProps);\n  // Nothing to do here. This is terminal. We'll do the completion step\n  // immediately after.\n  return null;\n}\n\nfunction mountIndeterminateComponent(\n  current,\n  workInProgress,\n  renderExpirationTime\n) {\n  invariant(\n    current === null,\n    \"An indeterminate component should never have mounted. This error is \" +\n      \"likely caused by a bug in React. Please file an issue.\"\n  );\n  var fn = workInProgress.type;\n  var props = workInProgress.pendingProps;\n  var unmaskedContext = getUnmaskedContext(workInProgress);\n  var context = getMaskedContext(workInProgress, unmaskedContext);\n\n  var value = void 0;\n\n  {\n    if (fn.prototype && typeof fn.prototype.render === \"function\") {\n      var componentName = getComponentName(workInProgress) || \"Unknown\";\n\n      if (!didWarnAboutBadClass[componentName]) {\n        warning(\n          false,\n          \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" +\n            \"This is likely to cause errors. Change %s to extend React.Component instead.\",\n          componentName,\n          componentName\n        );\n        didWarnAboutBadClass[componentName] = true;\n      }\n    }\n\n    if (workInProgress.mode & StrictMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n    }\n\n    ReactCurrentOwner.current = workInProgress;\n    value = fn(props, context);\n  }\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n\n  if (\n    typeof value === \"object\" &&\n    value !== null &&\n    typeof value.render === \"function\" &&\n    value.$$typeof === undefined\n  ) {\n    var Component = workInProgress.type;\n\n    // Proceed under the assumption that this is a class instance\n    workInProgress.tag = ClassComponent;\n\n    workInProgress.memoizedState =\n      value.state !== null && value.state !== undefined ? value.state : null;\n\n    var getDerivedStateFromProps = Component.getDerivedStateFromProps;\n    if (typeof getDerivedStateFromProps === \"function\") {\n      applyDerivedStateFromProps(\n        workInProgress,\n        getDerivedStateFromProps,\n        props\n      );\n    }\n\n    // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n    var hasContext = pushContextProvider(workInProgress);\n    adoptClassInstance(workInProgress, value);\n    mountClassInstance(workInProgress, renderExpirationTime);\n    return finishClassComponent(\n      current,\n      workInProgress,\n      true,\n      hasContext,\n      renderExpirationTime\n    );\n  } else {\n    // Proceed under the assumption that this is a functional component\n    workInProgress.tag = FunctionalComponent;\n    {\n      var _Component = workInProgress.type;\n\n      if (_Component) {\n        !!_Component.childContextTypes\n          ? warning(\n              false,\n              \"%s(...): childContextTypes cannot be defined on a functional component.\",\n              _Component.displayName || _Component.name || \"Component\"\n            )\n          : void 0;\n      }\n      if (workInProgress.ref !== null) {\n        var info = \"\";\n        var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();\n        if (ownerName) {\n          info += \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n        }\n\n        var warningKey = ownerName || workInProgress._debugID || \"\";\n        var debugSource = workInProgress._debugSource;\n        if (debugSource) {\n          warningKey = debugSource.fileName + \":\" + debugSource.lineNumber;\n        }\n        if (!didWarnAboutStatelessRefs[warningKey]) {\n          didWarnAboutStatelessRefs[warningKey] = true;\n          warning(\n            false,\n            \"Stateless function components cannot be given refs. \" +\n              \"Attempts to access this ref will fail.%s%s\",\n            info,\n            ReactDebugCurrentFiber.getCurrentFiberStackAddendum()\n          );\n        }\n      }\n\n      if (typeof fn.getDerivedStateFromProps === \"function\") {\n        var _componentName = getComponentName(workInProgress) || \"Unknown\";\n\n        if (!didWarnAboutGetDerivedStateOnFunctionalComponent[_componentName]) {\n          warning(\n            false,\n            \"%s: Stateless functional components do not support getDerivedStateFromProps.\",\n            _componentName\n          );\n          didWarnAboutGetDerivedStateOnFunctionalComponent[\n            _componentName\n          ] = true;\n        }\n      }\n    }\n    reconcileChildren(current, workInProgress, value);\n    memoizeProps(workInProgress, props);\n    return workInProgress.child;\n  }\n}\n\nfunction updateTimeoutComponent(current, workInProgress, renderExpirationTime) {\n  if (enableSuspense) {\n    var nextProps = workInProgress.pendingProps;\n    var prevProps = workInProgress.memoizedProps;\n\n    var prevDidTimeout = workInProgress.memoizedState;\n\n    // Check if we already attempted to render the normal state. If we did,\n    // and we timed out, render the placeholder state.\n    var alreadyCaptured = (workInProgress.effectTag & DidCapture) === NoEffect;\n    var nextDidTimeout = !alreadyCaptured;\n\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (nextProps === prevProps && nextDidTimeout === prevDidTimeout) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var render = nextProps.children;\n    var nextChildren = render(nextDidTimeout);\n    workInProgress.memoizedProps = nextProps;\n    workInProgress.memoizedState = nextDidTimeout;\n    reconcileChildren(current, workInProgress, nextChildren);\n    return workInProgress.child;\n  } else {\n    return null;\n  }\n}\n\nfunction updatePortalComponent(current, workInProgress, renderExpirationTime) {\n  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n  var nextChildren = workInProgress.pendingProps;\n  if (hasContextChanged()) {\n    // Normally we can bail out on props equality but if context has changed\n    // we don't do the bailout and we have to reuse existing props instead.\n  } else if (workInProgress.memoizedProps === nextChildren) {\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n\n  if (current === null) {\n    // Portals are special because we don't append the children during mount\n    // but at commit. Therefore we need to track insertions which the normal\n    // flow doesn't do during mount. This doesn't happen at the root because\n    // the root always starts with a \"current\" with a null child.\n    // TODO: Consider unifying this with how the root works.\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderExpirationTime\n    );\n    memoizeProps(workInProgress, nextChildren);\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextChildren);\n  }\n  return workInProgress.child;\n}\n\nfunction propagateContextChange(\n  workInProgress,\n  context,\n  changedBits,\n  renderExpirationTime\n) {\n  var fiber = workInProgress.child;\n  if (fiber !== null) {\n    // Set the return pointer of the child to the work-in-progress fiber.\n    fiber.return = workInProgress;\n  }\n  while (fiber !== null) {\n    var nextFiber = void 0;\n    // Visit this fiber.\n    switch (fiber.tag) {\n      case ContextConsumer:\n        // Check if the context matches.\n        var observedBits = fiber.stateNode | 0;\n        if (fiber.type === context && (observedBits & changedBits) !== 0) {\n          // Update the expiration time of all the ancestors, including\n          // the alternates.\n          var node = fiber;\n          while (node !== null) {\n            var alternate = node.alternate;\n            if (\n              node.expirationTime === NoWork ||\n              node.expirationTime > renderExpirationTime\n            ) {\n              node.expirationTime = renderExpirationTime;\n              if (\n                alternate !== null &&\n                (alternate.expirationTime === NoWork ||\n                  alternate.expirationTime > renderExpirationTime)\n              ) {\n                alternate.expirationTime = renderExpirationTime;\n              }\n            } else if (\n              alternate !== null &&\n              (alternate.expirationTime === NoWork ||\n                alternate.expirationTime > renderExpirationTime)\n            ) {\n              alternate.expirationTime = renderExpirationTime;\n            } else {\n              // Neither alternate was updated, which means the rest of the\n              // ancestor path already has sufficient priority.\n              break;\n            }\n            node = node.return;\n          }\n          // Don't scan deeper than a matching consumer. When we render the\n          // consumer, we'll continue scanning from that point. This way the\n          // scanning work is time-sliced.\n          nextFiber = null;\n        } else {\n          // Traverse down.\n          nextFiber = fiber.child;\n        }\n        break;\n      case ContextProvider:\n        // Don't scan deeper if this is a matching provider\n        nextFiber = fiber.type === workInProgress.type ? null : fiber.child;\n        break;\n      default:\n        // Traverse down.\n        nextFiber = fiber.child;\n        break;\n    }\n    if (nextFiber !== null) {\n      // Set the return pointer of the child to the work-in-progress fiber.\n      nextFiber.return = fiber;\n    } else {\n      // No child. Traverse to next sibling.\n      nextFiber = fiber;\n      while (nextFiber !== null) {\n        if (nextFiber === workInProgress) {\n          // We're back to the root of this subtree. Exit.\n          nextFiber = null;\n          break;\n        }\n        var sibling = nextFiber.sibling;\n        if (sibling !== null) {\n          // Set the return pointer of the sibling to the work-in-progress fiber.\n          sibling.return = nextFiber.return;\n          nextFiber = sibling;\n          break;\n        }\n        // No more siblings. Traverse up.\n        nextFiber = nextFiber.return;\n      }\n    }\n    fiber = nextFiber;\n  }\n}\n\nfunction updateContextProvider(current, workInProgress, renderExpirationTime) {\n  var providerType = workInProgress.type;\n  var context = providerType._context;\n\n  var newProps = workInProgress.pendingProps;\n  var oldProps = workInProgress.memoizedProps;\n  var canBailOnProps = true;\n\n  if (hasContextChanged()) {\n    canBailOnProps = false;\n    // Normally we can bail out on props equality but if context has changed\n    // we don't do the bailout and we have to reuse existing props instead.\n  } else if (oldProps === newProps) {\n    workInProgress.stateNode = 0;\n    pushProvider(workInProgress);\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n\n  var newValue = newProps.value;\n  workInProgress.memoizedProps = newProps;\n\n  {\n    var providerPropTypes = workInProgress.type.propTypes;\n\n    if (providerPropTypes) {\n      checkPropTypes(\n        providerPropTypes,\n        newProps,\n        \"prop\",\n        \"Context.Provider\",\n        getCurrentFiberStackAddendum$1\n      );\n    }\n  }\n\n  var changedBits = void 0;\n  if (oldProps === null) {\n    // Initial render\n    changedBits = MAX_SIGNED_31_BIT_INT;\n  } else {\n    if (oldProps.value === newProps.value) {\n      // No change. Bailout early if children are the same.\n      if (oldProps.children === newProps.children && canBailOnProps) {\n        workInProgress.stateNode = 0;\n        pushProvider(workInProgress);\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      changedBits = 0;\n    } else {\n      var oldValue = oldProps.value;\n      // Use Object.is to compare the new context value to the old value.\n      // Inlined Object.is polyfill.\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n      if (\n        (oldValue === newValue &&\n          (oldValue !== 0 || 1 / oldValue === 1 / newValue)) ||\n        (oldValue !== oldValue && newValue !== newValue) // eslint-disable-line no-self-compare\n      ) {\n        // No change. Bailout early if children are the same.\n        if (oldProps.children === newProps.children && canBailOnProps) {\n          workInProgress.stateNode = 0;\n          pushProvider(workInProgress);\n          return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n        changedBits = 0;\n      } else {\n        changedBits =\n          typeof context._calculateChangedBits === \"function\"\n            ? context._calculateChangedBits(oldValue, newValue)\n            : MAX_SIGNED_31_BIT_INT;\n        {\n          !((changedBits & MAX_SIGNED_31_BIT_INT) === changedBits)\n            ? warning(\n                false,\n                \"calculateChangedBits: Expected the return value to be a \" +\n                  \"31-bit integer. Instead received: %s\",\n                changedBits\n              )\n            : void 0;\n        }\n        changedBits |= 0;\n\n        if (changedBits === 0) {\n          // No change. Bailout early if children are the same.\n          if (oldProps.children === newProps.children && canBailOnProps) {\n            workInProgress.stateNode = 0;\n            pushProvider(workInProgress);\n            return bailoutOnAlreadyFinishedWork(current, workInProgress);\n          }\n        } else {\n          propagateContextChange(\n            workInProgress,\n            context,\n            changedBits,\n            renderExpirationTime\n          );\n        }\n      }\n    }\n  }\n\n  workInProgress.stateNode = changedBits;\n  pushProvider(workInProgress);\n\n  var newChildren = newProps.children;\n  reconcileChildren(current, workInProgress, newChildren);\n  return workInProgress.child;\n}\n\nfunction updateContextConsumer(current, workInProgress, renderExpirationTime) {\n  var context = workInProgress.type;\n  var newProps = workInProgress.pendingProps;\n  var oldProps = workInProgress.memoizedProps;\n\n  var newValue = getContextCurrentValue(context);\n  var changedBits = getContextChangedBits(context);\n\n  if (hasContextChanged()) {\n    // Normally we can bail out on props equality but if context has changed\n    // we don't do the bailout and we have to reuse existing props instead.\n  } else if (changedBits === 0 && oldProps === newProps) {\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n  workInProgress.memoizedProps = newProps;\n\n  var observedBits = newProps.unstable_observedBits;\n  if (observedBits === undefined || observedBits === null) {\n    // Subscribe to all changes by default\n    observedBits = MAX_SIGNED_31_BIT_INT;\n  }\n  // Store the observedBits on the fiber's stateNode for quick access.\n  workInProgress.stateNode = observedBits;\n\n  if ((changedBits & observedBits) !== 0) {\n    // Context change propagation stops at matching consumers, for time-\n    // slicing. Continue the propagation here.\n    propagateContextChange(\n      workInProgress,\n      context,\n      changedBits,\n      renderExpirationTime\n    );\n  } else if (oldProps === newProps) {\n    // Skip over a memoized parent with a bitmask bailout even\n    // if we began working on it because of a deeper matching child.\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n  // There is no bailout on `children` equality because we expect people\n  // to often pass a bound method as a child, but it may reference\n  // `this.state` or `this.props` (and thus needs to re-render on `setState`).\n\n  var render = newProps.children;\n\n  {\n    !(typeof render === \"function\")\n      ? warning(\n          false,\n          \"A context consumer was rendered with multiple children, or a child \" +\n            \"that isn't a function. A context consumer expects a single child \" +\n            \"that is a function. If you did pass a function, make sure there \" +\n            \"is no trailing or leading whitespace around it.\"\n        )\n      : void 0;\n  }\n\n  var newChildren = void 0;\n  {\n    ReactCurrentOwner.current = workInProgress;\n    ReactDebugCurrentFiber.setCurrentPhase(\"render\");\n    newChildren = render(newValue);\n    ReactDebugCurrentFiber.setCurrentPhase(null);\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(current, workInProgress, newChildren);\n  return workInProgress.child;\n}\n\n/*\n  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {\n    let child = firstChild;\n    do {\n      // Ensure that the first and last effect of the parent corresponds\n      // to the children's first and last effect.\n      if (!returnFiber.firstEffect) {\n        returnFiber.firstEffect = child.firstEffect;\n      }\n      if (child.lastEffect) {\n        if (returnFiber.lastEffect) {\n          returnFiber.lastEffect.nextEffect = child.firstEffect;\n        }\n        returnFiber.lastEffect = child.lastEffect;\n      }\n    } while (child = child.sibling);\n  }\n  */\n\nfunction bailoutOnAlreadyFinishedWork(current, workInProgress) {\n  cancelWorkTimer(workInProgress);\n\n  if (enableProfilerTimer) {\n    // Don't update \"base\" render times for bailouts.\n    stopBaseRenderTimerIfRunning();\n  }\n\n  // TODO: We should ideally be able to bail out early if the children have no\n  // more work to do. However, since we don't have a separation of this\n  // Fiber's priority and its children yet - we don't know without doing lots\n  // of the same work we do anyway. Once we have that separation we can just\n  // bail out here if the children has no more work at this priority level.\n  // if (workInProgress.priorityOfChildren <= priorityLevel) {\n  //   // If there are side-effects in these children that have not yet been\n  //   // committed we need to ensure that they get properly transferred up.\n  //   if (current && current.child !== workInProgress.child) {\n  //     reuseChildrenEffects(workInProgress, child);\n  //   }\n  //   return null;\n  // }\n\n  cloneChildFibers(current, workInProgress);\n  return workInProgress.child;\n}\n\nfunction bailoutOnLowPriority(current, workInProgress) {\n  cancelWorkTimer(workInProgress);\n\n  if (enableProfilerTimer) {\n    // Don't update \"base\" render times for bailouts.\n    stopBaseRenderTimerIfRunning();\n  }\n\n  // TODO: Handle HostComponent tags here as well and call pushHostContext()?\n  // See PR 8590 discussion for context\n  switch (workInProgress.tag) {\n    case HostRoot:\n      pushHostRootContext(workInProgress);\n      break;\n    case ClassComponent:\n      pushContextProvider(workInProgress);\n      break;\n    case HostPortal:\n      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n      break;\n    case ContextProvider:\n      pushProvider(workInProgress);\n      break;\n  }\n  // TODO: What if this is currently in progress?\n  // How can that happen? How is this not being cloned?\n  return null;\n}\n\n// TODO: Delete memoizeProps/State and move to reconcile/bailout instead\nfunction memoizeProps(workInProgress, nextProps) {\n  workInProgress.memoizedProps = nextProps;\n}\n\nfunction memoizeState(workInProgress, nextState) {\n  workInProgress.memoizedState = nextState;\n  // Don't reset the updateQueue, in case there are pending updates. Resetting\n  // is handled by processUpdateQueue.\n}\n\nfunction beginWork(current, workInProgress, renderExpirationTime) {\n  if (enableProfilerTimer) {\n    if (workInProgress.mode & ProfileMode) {\n      markActualRenderTimeStarted(workInProgress);\n    }\n  }\n\n  if (\n    workInProgress.expirationTime === NoWork ||\n    workInProgress.expirationTime > renderExpirationTime\n  ) {\n    return bailoutOnLowPriority(current, workInProgress);\n  }\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n      return mountIndeterminateComponent(\n        current,\n        workInProgress,\n        renderExpirationTime\n      );\n    case FunctionalComponent:\n      return updateFunctionalComponent(current, workInProgress);\n    case ClassComponent:\n      return updateClassComponent(\n        current,\n        workInProgress,\n        renderExpirationTime\n      );\n    case HostRoot:\n      return updateHostRoot(current, workInProgress, renderExpirationTime);\n    case HostComponent:\n      return updateHostComponent(current, workInProgress, renderExpirationTime);\n    case HostText:\n      return updateHostText(current, workInProgress);\n    case TimeoutComponent:\n      return updateTimeoutComponent(\n        current,\n        workInProgress,\n        renderExpirationTime\n      );\n    case HostPortal:\n      return updatePortalComponent(\n        current,\n        workInProgress,\n        renderExpirationTime\n      );\n    case ForwardRef:\n      return updateForwardRef(current, workInProgress);\n    case Fragment:\n      return updateFragment(current, workInProgress);\n    case Mode:\n      return updateMode(current, workInProgress);\n    case Profiler:\n      return updateProfiler(current, workInProgress);\n    case ContextProvider:\n      return updateContextProvider(\n        current,\n        workInProgress,\n        renderExpirationTime\n      );\n    case ContextConsumer:\n      return updateContextConsumer(\n        current,\n        workInProgress,\n        renderExpirationTime\n      );\n    default:\n      invariant(\n        false,\n        \"Unknown unit of work tag. This error is likely caused by a bug in \" +\n          \"React. Please file an issue.\"\n      );\n  }\n}\n\nfunction markUpdate(workInProgress) {\n  // Tag the fiber with an update effect. This turns a Placement into\n  // a PlacementAndUpdate.\n  workInProgress.effectTag |= Update;\n}\n\nfunction markRef$1(workInProgress) {\n  workInProgress.effectTag |= Ref;\n}\n\nfunction appendAllChildren(parent, workInProgress) {\n  // We only have the top Fiber that was created but we need recurse down its\n  // children to find all the terminal nodes.\n  var node = workInProgress.child;\n  while (node !== null) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      appendInitialChild(parent, node.stateNode);\n    } else if (node.tag === HostPortal) {\n      // If we have a portal child, then we don't want to traverse\n      // down its children. Instead, we'll get insertions from each child in\n      // the portal directly.\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === workInProgress) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === workInProgress) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nvar updateHostContainer = void 0;\nvar updateHostComponent$1 = void 0;\nvar updateHostText$1 = void 0;\nif (supportsMutation) {\n  // Mutation mode\n\n  updateHostContainer = function(workInProgress) {\n    // Noop\n  };\n  updateHostComponent$1 = function(\n    current,\n    workInProgress,\n    updatePayload,\n    type,\n    oldProps,\n    newProps,\n    rootContainerInstance,\n    currentHostContext\n  ) {\n    // TODO: Type this specific to this type of component.\n    workInProgress.updateQueue = updatePayload;\n    // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update. All the work is done in commitWork.\n    if (updatePayload) {\n      markUpdate(workInProgress);\n    }\n  };\n  updateHostText$1 = function(current, workInProgress, oldText, newText) {\n    // If the text differs, mark it as an update. All the work in done in commitWork.\n    if (oldText !== newText) {\n      markUpdate(workInProgress);\n    }\n  };\n} else if (supportsPersistence) {\n  // Persistent host tree mode\n\n  // An unfortunate fork of appendAllChildren because we have two different parent types.\n  var appendAllChildrenToContainer = function(\n    containerChildSet,\n    workInProgress\n  ) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendChildToContainerChildSet(containerChildSet, node.stateNode);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n  updateHostContainer = function(workInProgress) {\n    var portalOrRoot = workInProgress.stateNode;\n    var childrenUnchanged = workInProgress.firstEffect === null;\n    if (childrenUnchanged) {\n      // No changes, just reuse the existing instance.\n    } else {\n      var container = portalOrRoot.containerInfo;\n      var newChildSet = createContainerChildSet(container);\n      // If children might have changed, we have to add them all to the set.\n      appendAllChildrenToContainer(newChildSet, workInProgress);\n      portalOrRoot.pendingChildren = newChildSet;\n      // Schedule an update on the container to swap out the container.\n      markUpdate(workInProgress);\n      finalizeContainerChildren(container, newChildSet);\n    }\n  };\n  updateHostComponent$1 = function(\n    current,\n    workInProgress,\n    updatePayload,\n    type,\n    oldProps,\n    newProps,\n    rootContainerInstance,\n    currentHostContext\n  ) {\n    // If there are no effects associated with this node, then none of our children had any updates.\n    // This guarantees that we can reuse all of them.\n    var childrenUnchanged = workInProgress.firstEffect === null;\n    var currentInstance = current.stateNode;\n    if (childrenUnchanged && updatePayload === null) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n    } else {\n      var recyclableInstance = workInProgress.stateNode;\n      var newInstance = cloneInstance(\n        currentInstance,\n        updatePayload,\n        type,\n        oldProps,\n        newProps,\n        workInProgress,\n        childrenUnchanged,\n        recyclableInstance\n      );\n      if (\n        finalizeInitialChildren(\n          newInstance,\n          type,\n          newProps,\n          rootContainerInstance,\n          currentHostContext\n        )\n      ) {\n        markUpdate(workInProgress);\n      }\n      workInProgress.stateNode = newInstance;\n      if (childrenUnchanged) {\n        // If there are no other effects in this tree, we need to flag this node as having one.\n        // Even though we're not going to use it for anything.\n        // Otherwise parents won't know that there are new children to propagate upwards.\n        markUpdate(workInProgress);\n      } else {\n        // If children might have changed, we have to add them all to the set.\n        appendAllChildren(newInstance, workInProgress);\n      }\n    }\n  };\n  updateHostText$1 = function(current, workInProgress, oldText, newText) {\n    if (oldText !== newText) {\n      // If the text content differs, we'll create a new text instance for it.\n      var rootContainerInstance = getRootHostContainer();\n      var currentHostContext = getHostContext();\n      workInProgress.stateNode = createTextInstance(\n        newText,\n        rootContainerInstance,\n        currentHostContext,\n        workInProgress\n      );\n      // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n      // This lets the parents know that at least one of their children has changed.\n      markUpdate(workInProgress);\n    }\n  };\n} else {\n  // No host operations\n  updateHostContainer = function(workInProgress) {\n    // Noop\n  };\n  updateHostComponent$1 = function(\n    current,\n    workInProgress,\n    updatePayload,\n    type,\n    oldProps,\n    newProps,\n    rootContainerInstance,\n    currentHostContext\n  ) {\n    // Noop\n  };\n  updateHostText$1 = function(current, workInProgress, oldText, newText) {\n    // Noop\n  };\n}\n\nfunction completeWork(current, workInProgress, renderExpirationTime) {\n  var newProps = workInProgress.pendingProps;\n\n  if (enableProfilerTimer) {\n    if (workInProgress.mode & ProfileMode) {\n      recordElapsedActualRenderTime(workInProgress);\n    }\n  }\n\n  switch (workInProgress.tag) {\n    case FunctionalComponent:\n      return null;\n    case ClassComponent: {\n      // We are leaving this subtree, so pop context if any.\n      popContextProvider(workInProgress);\n      return null;\n    }\n    case HostRoot: {\n      popHostContainer(workInProgress);\n      popTopLevelContextObject(workInProgress);\n      var fiberRoot = workInProgress.stateNode;\n      if (fiberRoot.pendingContext) {\n        fiberRoot.context = fiberRoot.pendingContext;\n        fiberRoot.pendingContext = null;\n      }\n      if (current === null || current.child === null) {\n        // If we hydrated, pop so that we can delete any remaining children\n        // that weren't hydrated.\n        popHydrationState(workInProgress);\n        // This resets the hacky state to fix isMounted before committing.\n        // TODO: Delete this when we delete isMounted and findDOMNode.\n        workInProgress.effectTag &= ~Placement;\n      }\n      updateHostContainer(workInProgress);\n      return null;\n    }\n    case HostComponent: {\n      popHostContext(workInProgress);\n      var rootContainerInstance = getRootHostContainer();\n      var type = workInProgress.type;\n      if (current !== null && workInProgress.stateNode != null) {\n        // If we have an alternate, that means this is an update and we need to\n        // schedule a side-effect to do the updates.\n        var oldProps = current.memoizedProps;\n        // If we get updated because one of our children updated, we don't\n        // have newProps so we'll have to reuse them.\n        // TODO: Split the update API as separate for the props vs. children.\n        // Even better would be if children weren't special cased at all tho.\n        var instance = workInProgress.stateNode;\n        var currentHostContext = getHostContext();\n        // TODO: Experiencing an error where oldProps is null. Suggests a host\n        // component is hitting the resume path. Figure out why. Possibly\n        // related to `hidden`.\n        var updatePayload = prepareUpdate(\n          instance,\n          type,\n          oldProps,\n          newProps,\n          rootContainerInstance,\n          currentHostContext\n        );\n\n        updateHostComponent$1(\n          current,\n          workInProgress,\n          updatePayload,\n          type,\n          oldProps,\n          newProps,\n          rootContainerInstance,\n          currentHostContext\n        );\n\n        if (current.ref !== workInProgress.ref) {\n          markRef$1(workInProgress);\n        }\n      } else {\n        if (!newProps) {\n          invariant(\n            workInProgress.stateNode !== null,\n            \"We must have new props for new mounts. This error is likely \" +\n              \"caused by a bug in React. Please file an issue.\"\n          );\n          // This can happen when we abort work.\n          return null;\n        }\n\n        var _currentHostContext = getHostContext();\n        // TODO: Move createInstance to beginWork and keep it on a context\n        // \"stack\" as the parent. Then append children as we go in beginWork\n        // or completeWork depending on we want to add then top->down or\n        // bottom->up. Top->down is faster in IE11.\n        var wasHydrated = popHydrationState(workInProgress);\n        if (wasHydrated) {\n          // TODO: Move this and createInstance step into the beginPhase\n          // to consolidate.\n          if (\n            prepareToHydrateHostInstance(\n              workInProgress,\n              rootContainerInstance,\n              _currentHostContext\n            )\n          ) {\n            // If changes to the hydrated node needs to be applied at the\n            // commit-phase we mark this as such.\n            markUpdate(workInProgress);\n          }\n        } else {\n          var _instance = createInstance(\n            type,\n            newProps,\n            rootContainerInstance,\n            _currentHostContext,\n            workInProgress\n          );\n\n          appendAllChildren(_instance, workInProgress);\n\n          // Certain renderers require commit-time effects for initial mount.\n          // (eg DOM renderer supports auto-focus for certain elements).\n          // Make sure such renderers get scheduled for later work.\n          if (\n            finalizeInitialChildren(\n              _instance,\n              type,\n              newProps,\n              rootContainerInstance,\n              _currentHostContext\n            )\n          ) {\n            markUpdate(workInProgress);\n          }\n          workInProgress.stateNode = _instance;\n        }\n\n        if (workInProgress.ref !== null) {\n          // If there is a ref on a host node we need to schedule a callback\n          markRef$1(workInProgress);\n        }\n      }\n      return null;\n    }\n    case HostText: {\n      var newText = newProps;\n      if (current && workInProgress.stateNode != null) {\n        var oldText = current.memoizedProps;\n        // If we have an alternate, that means this is an update and we need\n        // to schedule a side-effect to do the updates.\n        updateHostText$1(current, workInProgress, oldText, newText);\n      } else {\n        if (typeof newText !== \"string\") {\n          invariant(\n            workInProgress.stateNode !== null,\n            \"We must have new props for new mounts. This error is likely \" +\n              \"caused by a bug in React. Please file an issue.\"\n          );\n          // This can happen when we abort work.\n          return null;\n        }\n        var _rootContainerInstance = getRootHostContainer();\n        var _currentHostContext2 = getHostContext();\n        var _wasHydrated = popHydrationState(workInProgress);\n        if (_wasHydrated) {\n          if (prepareToHydrateHostTextInstance(workInProgress)) {\n            markUpdate(workInProgress);\n          }\n        } else {\n          workInProgress.stateNode = createTextInstance(\n            newText,\n            _rootContainerInstance,\n            _currentHostContext2,\n            workInProgress\n          );\n        }\n      }\n      return null;\n    }\n    case ForwardRef:\n      return null;\n    case TimeoutComponent:\n      return null;\n    case Fragment:\n      return null;\n    case Mode:\n      return null;\n    case Profiler:\n      return null;\n    case HostPortal:\n      popHostContainer(workInProgress);\n      updateHostContainer(workInProgress);\n      return null;\n    case ContextProvider:\n      // Pop provider fiber\n      popProvider(workInProgress);\n      return null;\n    case ContextConsumer:\n      return null;\n    // Error cases\n    case IndeterminateComponent:\n      invariant(\n        false,\n        \"An indeterminate component should have become determinate before \" +\n          \"completing. This error is likely caused by a bug in React. Please \" +\n          \"file an issue.\"\n      );\n    // eslint-disable-next-line no-fallthrough\n    default:\n      invariant(\n        false,\n        \"Unknown unit of work tag. This error is likely caused by a bug in \" +\n          \"React. Please file an issue.\"\n      );\n  }\n}\n\n// Module provided by RN:\n/**\n * Intercept lifecycle errors and ensure they are shown with the correct stack\n * trace within the native redbox component.\n */\nfunction showErrorDialog(capturedError) {\n  var componentStack = capturedError.componentStack,\n    error = capturedError.error;\n\n  var errorToHandle = void 0;\n\n  // Typically Errors are thrown but eg strings or null can be thrown as well.\n  if (error instanceof Error) {\n    var message = error.message,\n      name = error.name;\n\n    var summary = message ? name + \": \" + message : name;\n\n    errorToHandle = error;\n\n    try {\n      errorToHandle.message =\n        summary + \"\\n\\nThis error is located at:\" + componentStack;\n    } catch (e) {}\n  } else if (typeof error === \"string\") {\n    errorToHandle = new Error(\n      error + \"\\n\\nThis error is located at:\" + componentStack\n    );\n  } else {\n    errorToHandle = new Error(\"Unspecified error at:\" + componentStack);\n  }\n\n  ExceptionsManager.handleException(errorToHandle, false);\n\n  // Return false here to prevent ReactFiberErrorLogger default behavior of\n  // logging error details to console.error. Calls to console.error are\n  // automatically routed to the native redbox controller, which we've already\n  // done above by calling ExceptionsManager.\n  return false;\n}\n\nfunction logCapturedError(capturedError) {\n  var logError = showErrorDialog(capturedError);\n\n  // Allow injected showErrorDialog() to prevent default console.error logging.\n  // This enables renderers like ReactNative to better manage redbox behavior.\n  if (logError === false) {\n    return;\n  }\n\n  var error = capturedError.error;\n  var suppressLogging = error && error.suppressReactErrorLogging;\n  if (suppressLogging) {\n    return;\n  }\n\n  {\n    var componentName = capturedError.componentName,\n      componentStack = capturedError.componentStack,\n      errorBoundaryName = capturedError.errorBoundaryName,\n      errorBoundaryFound = capturedError.errorBoundaryFound,\n      willRetry = capturedError.willRetry;\n\n    var componentNameMessage = componentName\n      ? \"The above error occurred in the <\" + componentName + \"> component:\"\n      : \"The above error occurred in one of your React components:\";\n\n    var errorBoundaryMessage = void 0;\n    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.\n    if (errorBoundaryFound && errorBoundaryName) {\n      if (willRetry) {\n        errorBoundaryMessage =\n          \"React will try to recreate this component tree from scratch \" +\n          (\"using the error boundary you provided, \" + errorBoundaryName + \".\");\n      } else {\n        errorBoundaryMessage =\n          \"This error was initially handled by the error boundary \" +\n          errorBoundaryName +\n          \".\\n\" +\n          \"Recreating the tree from scratch failed so React will unmount the tree.\";\n      }\n    } else {\n      errorBoundaryMessage =\n        \"Consider adding an error boundary to your tree to customize error handling behavior.\\n\" +\n        \"Visit https://fb.me/react-error-boundaries to learn more about error boundaries.\";\n    }\n    var combinedMessage =\n      \"\" +\n      componentNameMessage +\n      componentStack +\n      \"\\n\\n\" +\n      (\"\" + errorBoundaryMessage);\n\n    // In development, we provide our own message with just the component stack.\n    // We don't include the original error message and JS stack because the browser\n    // has already printed it. Even if the application swallows the error, it is still\n    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n    console.error(combinedMessage);\n  }\n}\n\nvar invokeGuardedCallback$3 = ReactErrorUtils.invokeGuardedCallback;\nvar hasCaughtError$1 = ReactErrorUtils.hasCaughtError;\nvar clearCaughtError$1 = ReactErrorUtils.clearCaughtError;\n\nvar didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n{\n  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n}\n\nfunction logError(boundary, errorInfo) {\n  var source = errorInfo.source;\n  var stack = errorInfo.stack;\n  if (stack === null && source !== null) {\n    stack = getStackAddendumByWorkInProgressFiber(source);\n  }\n\n  var capturedError = {\n    componentName: source !== null ? getComponentName(source) : null,\n    componentStack: stack !== null ? stack : \"\",\n    error: errorInfo.value,\n    errorBoundary: null,\n    errorBoundaryName: null,\n    errorBoundaryFound: false,\n    willRetry: false\n  };\n\n  if (boundary !== null && boundary.tag === ClassComponent) {\n    capturedError.errorBoundary = boundary.stateNode;\n    capturedError.errorBoundaryName = getComponentName(boundary);\n    capturedError.errorBoundaryFound = true;\n    capturedError.willRetry = true;\n  }\n\n  try {\n    logCapturedError(capturedError);\n  } catch (e) {\n    // Prevent cycle if logCapturedError() throws.\n    // A cycle may still occur if logCapturedError renders a component that throws.\n    var suppressLogging = e && e.suppressReactErrorLogging;\n    if (!suppressLogging) {\n      console.error(e);\n    }\n  }\n}\n\nvar callComponentWillUnmountWithTimer = function(current, instance) {\n  startPhaseTimer(current, \"componentWillUnmount\");\n  instance.props = current.memoizedProps;\n  instance.state = current.memoizedState;\n  instance.componentWillUnmount();\n  stopPhaseTimer();\n};\n\n// Capture errors so they don't interrupt unmounting.\nfunction safelyCallComponentWillUnmount(current, instance) {\n  {\n    invokeGuardedCallback$3(\n      null,\n      callComponentWillUnmountWithTimer,\n      null,\n      current,\n      instance\n    );\n    if (hasCaughtError$1()) {\n      var unmountError = clearCaughtError$1();\n      captureCommitPhaseError(current, unmountError);\n    }\n  }\n}\n\nfunction safelyDetachRef(current) {\n  var ref = current.ref;\n  if (ref !== null) {\n    if (typeof ref === \"function\") {\n      {\n        invokeGuardedCallback$3(null, ref, null, null);\n        if (hasCaughtError$1()) {\n          var refError = clearCaughtError$1();\n          captureCommitPhaseError(current, refError);\n        }\n      }\n    } else {\n      ref.current = null;\n    }\n  }\n}\n\nfunction commitBeforeMutationLifeCycles(current, finishedWork) {\n  switch (finishedWork.tag) {\n    case ClassComponent: {\n      if (finishedWork.effectTag & Snapshot) {\n        if (current !== null) {\n          var prevProps = current.memoizedProps;\n          var prevState = current.memoizedState;\n          startPhaseTimer(finishedWork, \"getSnapshotBeforeUpdate\");\n          var instance = finishedWork.stateNode;\n          instance.props = finishedWork.memoizedProps;\n          instance.state = finishedWork.memoizedState;\n          var snapshot = instance.getSnapshotBeforeUpdate(prevProps, prevState);\n          {\n            var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n            if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n              didWarnSet.add(finishedWork.type);\n              warning(\n                false,\n                \"%s.getSnapshotBeforeUpdate(): A snapshot value (or null) \" +\n                  \"must be returned. You have returned undefined.\",\n                getComponentName(finishedWork)\n              );\n            }\n          }\n          instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n          stopPhaseTimer();\n        }\n      }\n      return;\n    }\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n      // Nothing to do for these component types\n      return;\n    default: {\n      invariant(\n        false,\n        \"This unit of work tag should not have side-effects. This error is \" +\n          \"likely caused by a bug in React. Please file an issue.\"\n      );\n    }\n  }\n}\n\nfunction commitLifeCycles(\n  finishedRoot,\n  current,\n  finishedWork,\n  currentTime,\n  committedExpirationTime\n) {\n  switch (finishedWork.tag) {\n    case ClassComponent: {\n      var instance = finishedWork.stateNode;\n      if (finishedWork.effectTag & Update) {\n        if (current === null) {\n          startPhaseTimer(finishedWork, \"componentDidMount\");\n          instance.props = finishedWork.memoizedProps;\n          instance.state = finishedWork.memoizedState;\n          instance.componentDidMount();\n          stopPhaseTimer();\n        } else {\n          var prevProps = current.memoizedProps;\n          var prevState = current.memoizedState;\n          startPhaseTimer(finishedWork, \"componentDidUpdate\");\n          instance.props = finishedWork.memoizedProps;\n          instance.state = finishedWork.memoizedState;\n          instance.componentDidUpdate(\n            prevProps,\n            prevState,\n            instance.__reactInternalSnapshotBeforeUpdate\n          );\n          stopPhaseTimer();\n        }\n      }\n      var updateQueue = finishedWork.updateQueue;\n      if (updateQueue !== null) {\n        instance.props = finishedWork.memoizedProps;\n        instance.state = finishedWork.memoizedState;\n        commitUpdateQueue(\n          finishedWork,\n          updateQueue,\n          instance,\n          committedExpirationTime\n        );\n      }\n      return;\n    }\n    case HostRoot: {\n      var _updateQueue = finishedWork.updateQueue;\n      if (_updateQueue !== null) {\n        var _instance = null;\n        if (finishedWork.child !== null) {\n          switch (finishedWork.child.tag) {\n            case HostComponent:\n              _instance = getPublicInstance(finishedWork.child.stateNode);\n              break;\n            case ClassComponent:\n              _instance = finishedWork.child.stateNode;\n              break;\n          }\n        }\n        commitUpdateQueue(\n          finishedWork,\n          _updateQueue,\n          _instance,\n          committedExpirationTime\n        );\n      }\n      return;\n    }\n    case HostComponent: {\n      var _instance2 = finishedWork.stateNode;\n\n      // Renderers may schedule work to be done after host components are mounted\n      // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n      // These effects should only be committed when components are first mounted,\n      // aka when there is no current/alternate.\n      if (current === null && finishedWork.effectTag & Update) {\n        var type = finishedWork.type;\n        var props = finishedWork.memoizedProps;\n      }\n\n      return;\n    }\n    case HostText: {\n      // We have no life-cycles associated with text.\n      return;\n    }\n    case HostPortal: {\n      // We have no life-cycles associated with portals.\n      return;\n    }\n    case Profiler: {\n      // We have no life-cycles associated with Profiler.\n      return;\n    }\n    case TimeoutComponent: {\n      // We have no life-cycles associated with Timeouts.\n      return;\n    }\n    default: {\n      invariant(\n        false,\n        \"This unit of work tag should not have side-effects. This error is \" +\n          \"likely caused by a bug in React. Please file an issue.\"\n      );\n    }\n  }\n}\n\nfunction commitAttachRef(finishedWork) {\n  var ref = finishedWork.ref;\n  if (ref !== null) {\n    var instance = finishedWork.stateNode;\n    var instanceToUse = void 0;\n    switch (finishedWork.tag) {\n      case HostComponent:\n        instanceToUse = getPublicInstance(instance);\n        break;\n      default:\n        instanceToUse = instance;\n    }\n    if (typeof ref === \"function\") {\n      ref(instanceToUse);\n    } else {\n      {\n        if (!ref.hasOwnProperty(\"current\")) {\n          warning(\n            false,\n            \"Unexpected ref object provided for %s. \" +\n              \"Use either a ref-setter function or React.createRef().%s\",\n            getComponentName(finishedWork),\n            getStackAddendumByWorkInProgressFiber(finishedWork)\n          );\n        }\n      }\n\n      ref.current = instanceToUse;\n    }\n  }\n}\n\nfunction commitDetachRef(current) {\n  var currentRef = current.ref;\n  if (currentRef !== null) {\n    if (typeof currentRef === \"function\") {\n      currentRef(null);\n    } else {\n      currentRef.current = null;\n    }\n  }\n}\n\n// User-originating errors (lifecycles and refs) should not interrupt\n// deletion, so don't let them throw. Host-originating errors should\n// interrupt deletion, so it's okay\nfunction commitUnmount(current) {\n  if (typeof onCommitUnmount === \"function\") {\n    onCommitUnmount(current);\n  }\n\n  switch (current.tag) {\n    case ClassComponent: {\n      safelyDetachRef(current);\n      var instance = current.stateNode;\n      if (typeof instance.componentWillUnmount === \"function\") {\n        safelyCallComponentWillUnmount(current, instance);\n      }\n      return;\n    }\n    case HostComponent: {\n      safelyDetachRef(current);\n      return;\n    }\n    case HostPortal: {\n      // TODO: this is recursive.\n      // We are also not using this parent because\n      // the portal will get pushed immediately.\n      if (supportsMutation) {\n        unmountHostComponents(current);\n      } else if (supportsPersistence) {\n        emptyPortalContainer(current);\n      }\n      return;\n    }\n  }\n}\n\nfunction commitNestedUnmounts(root) {\n  // While we're inside a removed host node we don't want to call\n  // removeChild on the inner nodes because they're removed by the top\n  // call anyway. We also want to call componentWillUnmount on all\n  // composites before this host node is removed from the tree. Therefore\n  var node = root;\n  while (true) {\n    commitUnmount(node);\n    // Visit children because they may contain more composite or host nodes.\n    // Skip portals because commitUnmount() currently visits them recursively.\n    if (\n      node.child !== null &&\n      // If we use mutation we drill down into portals using commitUnmount above.\n      // If we don't use mutation we drill down into portals here instead.\n      (!supportsMutation || node.tag !== HostPortal)\n    ) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === root) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === root) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction detachFiber(current) {\n  // Cut off the return pointers to disconnect it from the tree. Ideally, we\n  // should clear the child pointer of the parent alternate to let this\n  // get GC:ed but we don't know which for sure which parent is the current\n  // one so we'll settle for GC:ing the subtree of this child. This child\n  // itself will be GC:ed when the parent updates the next time.\n  current.return = null;\n  current.child = null;\n  if (current.alternate) {\n    current.alternate.child = null;\n    current.alternate.return = null;\n  }\n}\n\nfunction emptyPortalContainer(current) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  var portal = current.stateNode;\n  var containerInfo = portal.containerInfo;\n\n  var emptyChildSet = createContainerChildSet(containerInfo);\n  replaceContainerChildren(containerInfo, emptyChildSet);\n}\n\nfunction commitContainer(finishedWork) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case ClassComponent: {\n      return;\n    }\n    case HostComponent: {\n      return;\n    }\n    case HostText: {\n      return;\n    }\n    case HostRoot:\n    case HostPortal: {\n      var portalOrRoot = finishedWork.stateNode;\n      var containerInfo = portalOrRoot.containerInfo,\n        _pendingChildren = portalOrRoot.pendingChildren;\n\n      replaceContainerChildren(containerInfo, _pendingChildren);\n      return;\n    }\n    default: {\n      invariant(\n        false,\n        \"This unit of work tag should not have side-effects. This error is \" +\n          \"likely caused by a bug in React. Please file an issue.\"\n      );\n    }\n  }\n}\n\nfunction getHostParentFiber(fiber) {\n  var parent = fiber.return;\n  while (parent !== null) {\n    if (isHostParent(parent)) {\n      return parent;\n    }\n    parent = parent.return;\n  }\n  invariant(\n    false,\n    \"Expected to find a host parent. This error is likely caused by a bug \" +\n      \"in React. Please file an issue.\"\n  );\n}\n\nfunction isHostParent(fiber) {\n  return (\n    fiber.tag === HostComponent ||\n    fiber.tag === HostRoot ||\n    fiber.tag === HostPortal\n  );\n}\n\nfunction getHostSibling(fiber) {\n  // We're going to search forward into the tree until we find a sibling host\n  // node. Unfortunately, if multiple insertions are done in a row we have to\n  // search past them. This leads to exponential search for the next sibling.\n  var node = fiber;\n  siblings: while (true) {\n    // If we didn't find anything, let's try the next sibling.\n    while (node.sibling === null) {\n      if (node.return === null || isHostParent(node.return)) {\n        // If we pop out of the root or hit the parent the fiber we are the\n        // last sibling.\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n    while (node.tag !== HostComponent && node.tag !== HostText) {\n      // If it is not host node and, we might have a host node inside it.\n      // Try to search down until we find one.\n      if (node.effectTag & Placement) {\n        // If we don't have a child, try the siblings instead.\n        continue siblings;\n      }\n      // If we don't have a child, try the siblings instead.\n      // We also skip portals because they are not part of this host tree.\n      if (node.child === null || node.tag === HostPortal) {\n        continue siblings;\n      } else {\n        node.child.return = node;\n        node = node.child;\n      }\n    }\n    // Check if this host node is stable or about to be placed.\n    if (!(node.effectTag & Placement)) {\n      // Found it!\n      return node.stateNode;\n    }\n  }\n}\n\nfunction commitPlacement(finishedWork) {\n  if (!supportsMutation) {\n    return;\n  }\n\n  // Recursively insert all host nodes into the parent.\n  var parentFiber = getHostParentFiber(finishedWork);\n  var parent = void 0;\n  var isContainer = void 0;\n  switch (parentFiber.tag) {\n    case HostComponent:\n      parent = parentFiber.stateNode;\n      isContainer = false;\n      break;\n    case HostRoot:\n      parent = parentFiber.stateNode.containerInfo;\n      isContainer = true;\n      break;\n    case HostPortal:\n      parent = parentFiber.stateNode.containerInfo;\n      isContainer = true;\n      break;\n    default:\n      invariant(\n        false,\n        \"Invalid host parent fiber. This error is likely caused by a bug \" +\n          \"in React. Please file an issue.\"\n      );\n  }\n  if (parentFiber.effectTag & ContentReset) {\n    // Reset the text content of the parent before doing any insertions\n    parentFiber.effectTag &= ~ContentReset;\n  }\n\n  var before = getHostSibling(finishedWork);\n  // We only have the top Fiber that was inserted but we need recurse down its\n  // children to find all the terminal nodes.\n  var node = finishedWork;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      if (before) {\n        if (isContainer) {\n          insertInContainerBefore(parent, node.stateNode, before);\n        } else {\n          insertBefore(parent, node.stateNode, before);\n        }\n      } else {\n        if (isContainer) {\n          appendChildToContainer(parent, node.stateNode);\n        } else {\n          appendChild(parent, node.stateNode);\n        }\n      }\n    } else if (node.tag === HostPortal) {\n      // If the insertion itself is a portal, then we don't want to traverse\n      // down its children. Instead, we'll get insertions from each child in\n      // the portal directly.\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === finishedWork) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === finishedWork) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction unmountHostComponents(current) {\n  // We only have the top Fiber that was inserted but we need recurse down its\n  var node = current;\n\n  // Each iteration, currentParent is populated with node's host parent if not\n  // currentParentIsValid.\n  var currentParentIsValid = false;\n  var currentParent = void 0;\n  var currentParentIsContainer = void 0;\n\n  while (true) {\n    if (!currentParentIsValid) {\n      var parent = node.return;\n      findParent: while (true) {\n        invariant(\n          parent !== null,\n          \"Expected to find a host parent. This error is likely caused by \" +\n            \"a bug in React. Please file an issue.\"\n        );\n        switch (parent.tag) {\n          case HostComponent:\n            currentParent = parent.stateNode;\n            currentParentIsContainer = false;\n            break findParent;\n          case HostRoot:\n            currentParent = parent.stateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n          case HostPortal:\n            currentParent = parent.stateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n        }\n        parent = parent.return;\n      }\n      currentParentIsValid = true;\n    }\n\n    if (node.tag === HostComponent || node.tag === HostText) {\n      commitNestedUnmounts(node);\n      // After all the children have unmounted, it is now safe to remove the\n      // node from the tree.\n      if (currentParentIsContainer) {\n        removeChildFromContainer(currentParent, node.stateNode);\n      } else {\n        removeChild(currentParent, node.stateNode);\n      }\n      // Don't visit children because we already visited them.\n    } else if (node.tag === HostPortal) {\n      // When we go into a portal, it becomes the parent to remove from.\n      // We will reassign it back when we pop the portal on the way up.\n      currentParent = node.stateNode.containerInfo;\n      // Visit children because portals might contain host components.\n      if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    } else {\n      commitUnmount(node);\n      // Visit children because we may find more host components below.\n      if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    }\n    if (node === current) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === current) {\n        return;\n      }\n      node = node.return;\n      if (node.tag === HostPortal) {\n        // When we go out of the portal, we need to restore the parent.\n        // Since we don't keep a stack of them, we will search for it.\n        currentParentIsValid = false;\n      }\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction commitDeletion(current) {\n  if (supportsMutation) {\n    // Recursively delete all host nodes from the parent.\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(current);\n  } else {\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    commitNestedUnmounts(current);\n  }\n  detachFiber(current);\n}\n\nfunction commitWork(current, finishedWork) {\n  if (!supportsMutation) {\n    commitContainer(finishedWork);\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case ClassComponent: {\n      return;\n    }\n    case HostComponent: {\n      var instance = finishedWork.stateNode;\n      if (instance != null) {\n        // Commit the work prepared earlier.\n        var newProps = finishedWork.memoizedProps;\n        // For hydration we reuse the update path but we treat the oldProps\n        // as the newProps. The updatePayload will contain the real change in\n        // this case.\n        var oldProps = current !== null ? current.memoizedProps : newProps;\n        var type = finishedWork.type;\n        // TODO: Type the updateQueue to be specific to host components.\n        var updatePayload = finishedWork.updateQueue;\n        finishedWork.updateQueue = null;\n        if (updatePayload !== null) {\n          commitUpdate(\n            instance,\n            updatePayload,\n            type,\n            oldProps,\n            newProps,\n            finishedWork\n          );\n        }\n      }\n      return;\n    }\n    case HostText: {\n      invariant(\n        finishedWork.stateNode !== null,\n        \"This should have a text node initialized. This error is likely \" +\n          \"caused by a bug in React. Please file an issue.\"\n      );\n      var textInstance = finishedWork.stateNode;\n      var newText = finishedWork.memoizedProps;\n      // For hydration we reuse the update path but we treat the oldProps\n      // as the newProps. The updatePayload will contain the real change in\n      // this case.\n      var oldText = current !== null ? current.memoizedProps : newText;\n      commitTextUpdate(textInstance, oldText, newText);\n      return;\n    }\n    case HostRoot: {\n      return;\n    }\n    case Profiler: {\n      if (enableProfilerTimer) {\n        var onRender = finishedWork.memoizedProps.onRender;\n        onRender(\n          finishedWork.memoizedProps.id,\n          current === null ? \"mount\" : \"update\",\n          finishedWork.actualDuration,\n          finishedWork.treeBaseTime,\n          finishedWork.actualStartTime,\n          getCommitTime()\n        );\n      }\n      return;\n    }\n    case TimeoutComponent: {\n      return;\n    }\n    default: {\n      invariant(\n        false,\n        \"This unit of work tag should not have side-effects. This error is \" +\n          \"likely caused by a bug in React. Please file an issue.\"\n      );\n    }\n  }\n}\n\nfunction commitResetTextContent(current) {\n  if (!supportsMutation) {\n    return;\n  }\n  resetTextContent(current.stateNode);\n}\n\nfunction createRootErrorUpdate(fiber, errorInfo, expirationTime) {\n  var update = createUpdate(expirationTime);\n  // Unmount the root by rendering null.\n  update.tag = CaptureUpdate;\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = { element: null };\n  var error = errorInfo.value;\n  update.callback = function() {\n    onUncaughtError(error);\n    logError(fiber, errorInfo);\n  };\n  return update;\n}\n\nfunction createClassErrorUpdate(fiber, errorInfo, expirationTime) {\n  var update = createUpdate(expirationTime);\n  update.tag = CaptureUpdate;\n  var getDerivedStateFromCatch = fiber.type.getDerivedStateFromCatch;\n  if (\n    enableGetDerivedStateFromCatch &&\n    typeof getDerivedStateFromCatch === \"function\"\n  ) {\n    var error = errorInfo.value;\n    update.payload = function() {\n      return getDerivedStateFromCatch(error);\n    };\n  }\n\n  var inst = fiber.stateNode;\n  if (inst !== null && typeof inst.componentDidCatch === \"function\") {\n    update.callback = function callback() {\n      if (\n        !enableGetDerivedStateFromCatch ||\n        getDerivedStateFromCatch !== \"function\"\n      ) {\n        // To preserve the preexisting retry behavior of error boundaries,\n        // we keep track of which ones already failed during this batch.\n        // This gets reset before we yield back to the browser.\n        // TODO: Warn in strict mode if getDerivedStateFromCatch is\n        // not defined.\n        markLegacyErrorBoundaryAsFailed(this);\n      }\n      var error = errorInfo.value;\n      var stack = errorInfo.stack;\n      logError(fiber, errorInfo);\n      this.componentDidCatch(error, {\n        componentStack: stack !== null ? stack : \"\"\n      });\n    };\n  }\n  return update;\n}\n\nfunction schedulePing(finishedWork) {\n  // Once the promise resolves, we should try rendering the non-\n  // placeholder state again.\n  var currentTime = recalculateCurrentTime();\n  var expirationTime = computeExpirationForFiber(currentTime, finishedWork);\n  var recoveryUpdate = createUpdate(expirationTime);\n  enqueueUpdate(finishedWork, recoveryUpdate, expirationTime);\n  scheduleWork(finishedWork, expirationTime);\n}\n\nfunction throwException(\n  root,\n  returnFiber,\n  sourceFiber,\n  value,\n  renderExpirationTime,\n  currentTimeMs\n) {\n  // The source fiber did not complete.\n  sourceFiber.effectTag |= Incomplete;\n  // Its effect list is no longer valid.\n  sourceFiber.firstEffect = sourceFiber.lastEffect = null;\n\n  if (\n    enableSuspense &&\n    value !== null &&\n    typeof value === \"object\" &&\n    typeof value.then === \"function\"\n  ) {\n    // This is a thenable.\n    var thenable = value;\n\n    // TODO: Should use the earliest known expiration time\n    var expirationTimeMs = expirationTimeToMs(renderExpirationTime);\n    var startTimeMs = expirationTimeMs - 5000;\n    var elapsedMs = currentTimeMs - startTimeMs;\n    if (elapsedMs < 0) {\n      elapsedMs = 0;\n    }\n    var remainingTimeMs = expirationTimeMs - currentTimeMs;\n\n    // Find the earliest timeout of all the timeouts in the ancestor path.\n    // TODO: Alternatively, we could store the earliest timeout on the context\n    // stack, rather than searching on every suspend.\n    var _workInProgress = returnFiber;\n    var earliestTimeoutMs = -1;\n    searchForEarliestTimeout: do {\n      if (_workInProgress.tag === TimeoutComponent) {\n        var current = _workInProgress.alternate;\n        if (current !== null && current.memoizedState === true) {\n          // A parent Timeout already committed in a placeholder state. We\n          // need to handle this promise immediately. In other words, we\n          // should never suspend inside a tree that already expired.\n          earliestTimeoutMs = 0;\n          break searchForEarliestTimeout;\n        }\n        var timeoutPropMs = _workInProgress.pendingProps.ms;\n        if (typeof timeoutPropMs === \"number\") {\n          if (timeoutPropMs <= 0) {\n            earliestTimeoutMs = 0;\n            break searchForEarliestTimeout;\n          } else if (\n            earliestTimeoutMs === -1 ||\n            timeoutPropMs < earliestTimeoutMs\n          ) {\n            earliestTimeoutMs = timeoutPropMs;\n          }\n        } else if (earliestTimeoutMs === -1) {\n          earliestTimeoutMs = remainingTimeMs;\n        }\n      }\n      _workInProgress = _workInProgress.return;\n    } while (_workInProgress !== null);\n\n    // Compute the remaining time until the timeout.\n    var msUntilTimeout = earliestTimeoutMs - elapsedMs;\n\n    if (renderExpirationTime === Never || msUntilTimeout > 0) {\n      // There's still time remaining.\n      markTimeout(root, thenable, msUntilTimeout, renderExpirationTime);\n      var onResolveOrReject = function() {\n        retrySuspendedRoot(root, renderExpirationTime);\n      };\n      thenable.then(onResolveOrReject, onResolveOrReject);\n      return;\n    } else {\n      // No time remaining. Need to fallback to placeholder.\n      // Find the nearest timeout that can be retried.\n      _workInProgress = returnFiber;\n      do {\n        switch (_workInProgress.tag) {\n          case HostRoot: {\n            // The root expired, but no fallback was provided. Throw a\n            // helpful error.\n            var message =\n              renderExpirationTime === Sync\n                ? \"A synchronous update was suspended, but no fallback UI \" +\n                  \"was provided.\"\n                : \"An update was suspended for longer than the timeout, \" +\n                  \"but no fallback UI was provided.\";\n            value = new Error(message);\n            break;\n          }\n          case TimeoutComponent: {\n            if ((_workInProgress.effectTag & DidCapture) === NoEffect) {\n              _workInProgress.effectTag |= ShouldCapture;\n              var _onResolveOrReject = schedulePing.bind(null, _workInProgress);\n              thenable.then(_onResolveOrReject, _onResolveOrReject);\n              return;\n            }\n            // Already captured during this render. Continue to the next\n            // Timeout ancestor.\n            break;\n          }\n        }\n        _workInProgress = _workInProgress.return;\n      } while (_workInProgress !== null);\n    }\n  } else {\n    // This is an error.\n    markError(root);\n    if (\n      // Retry (at the same priority) one more time before handling the error.\n      // The retry will flush synchronously. (Unless we're already rendering\n      // synchronously, in which case move to the next check.)\n      (!root.didError && renderExpirationTime !== Sync) ||\n      // There's lower priority work. If so, it may have the effect of fixing\n      // the exception that was just thrown.\n      hasLowerPriorityWork(root, renderExpirationTime)\n    ) {\n      return;\n    }\n  }\n\n  // We didn't find a boundary that could handle this type of exception. Start\n  // over and traverse parent path again, this time treating the exception\n  // as an error.\n  value = createCapturedValue(value, sourceFiber);\n  var workInProgress = returnFiber;\n  do {\n    switch (workInProgress.tag) {\n      case HostRoot: {\n        var _errorInfo = value;\n        workInProgress.effectTag |= ShouldCapture;\n        var update = createRootErrorUpdate(\n          workInProgress,\n          _errorInfo,\n          renderExpirationTime\n        );\n        enqueueCapturedUpdate(workInProgress, update, renderExpirationTime);\n        return;\n      }\n      case ClassComponent:\n        // Capture and retry\n        var errorInfo = value;\n        var ctor = workInProgress.type;\n        var instance = workInProgress.stateNode;\n        if (\n          (workInProgress.effectTag & DidCapture) === NoEffect &&\n          ((typeof ctor.getDerivedStateFromCatch === \"function\" &&\n            enableGetDerivedStateFromCatch) ||\n            (instance !== null &&\n              typeof instance.componentDidCatch === \"function\" &&\n              !isAlreadyFailedLegacyErrorBoundary(instance)))\n        ) {\n          workInProgress.effectTag |= ShouldCapture;\n          // Schedule the error boundary to re-render using updated state\n          var _update = createClassErrorUpdate(\n            workInProgress,\n            errorInfo,\n            renderExpirationTime\n          );\n          enqueueCapturedUpdate(workInProgress, _update, renderExpirationTime);\n          return;\n        }\n        break;\n      default:\n        break;\n    }\n    workInProgress = workInProgress.return;\n  } while (workInProgress !== null);\n}\n\nfunction unwindWork(workInProgress, renderExpirationTime) {\n  if (enableProfilerTimer) {\n    if (workInProgress.mode & ProfileMode) {\n      recordElapsedActualRenderTime(workInProgress);\n    }\n  }\n\n  switch (workInProgress.tag) {\n    case ClassComponent: {\n      popContextProvider(workInProgress);\n      var effectTag = workInProgress.effectTag;\n      if (effectTag & ShouldCapture) {\n        workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;\n        return workInProgress;\n      }\n      return null;\n    }\n    case HostRoot: {\n      popHostContainer(workInProgress);\n      popTopLevelContextObject(workInProgress);\n      var _effectTag = workInProgress.effectTag;\n      if (_effectTag & ShouldCapture) {\n        workInProgress.effectTag = (_effectTag & ~ShouldCapture) | DidCapture;\n        return workInProgress;\n      }\n      return null;\n    }\n    case HostComponent: {\n      popHostContext(workInProgress);\n      return null;\n    }\n    case TimeoutComponent: {\n      var _effectTag2 = workInProgress.effectTag;\n      if (_effectTag2 & ShouldCapture) {\n        workInProgress.effectTag = (_effectTag2 & ~ShouldCapture) | DidCapture;\n        return workInProgress;\n      }\n      return null;\n    }\n    case HostPortal:\n      popHostContainer(workInProgress);\n      return null;\n    case ContextProvider:\n      popProvider(workInProgress);\n      return null;\n    default:\n      return null;\n  }\n}\n\nfunction unwindInterruptedWork(interruptedWork) {\n  if (enableProfilerTimer) {\n    if (interruptedWork.mode & ProfileMode) {\n      // Resume in case we're picking up on work that was paused.\n      resumeActualRenderTimerIfPaused();\n      recordElapsedActualRenderTime(interruptedWork);\n    }\n  }\n\n  switch (interruptedWork.tag) {\n    case ClassComponent: {\n      popContextProvider(interruptedWork);\n      break;\n    }\n    case HostRoot: {\n      popHostContainer(interruptedWork);\n      popTopLevelContextObject(interruptedWork);\n      break;\n    }\n    case HostComponent: {\n      popHostContext(interruptedWork);\n      break;\n    }\n    case HostPortal:\n      popHostContainer(interruptedWork);\n      break;\n    case ContextProvider:\n      popProvider(interruptedWork);\n      break;\n    default:\n      break;\n  }\n}\n\nvar invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;\nvar hasCaughtError = ReactErrorUtils.hasCaughtError;\nvar clearCaughtError = ReactErrorUtils.clearCaughtError;\n\nvar didWarnAboutStateTransition = void 0;\nvar didWarnSetStateChildContext = void 0;\nvar warnAboutUpdateOnUnmounted = void 0;\nvar warnAboutInvalidUpdates = void 0;\n\n{\n  didWarnAboutStateTransition = false;\n  didWarnSetStateChildContext = false;\n  var didWarnStateUpdateForUnmountedComponent = {};\n\n  warnAboutUpdateOnUnmounted = function(fiber) {\n    // We show the whole stack but dedupe on the top component's name because\n    // the problematic code almost always lies inside that component.\n    var componentName = getComponentName(fiber) || \"ReactClass\";\n    if (didWarnStateUpdateForUnmountedComponent[componentName]) {\n      return;\n    }\n    warning(\n      false,\n      \"Can't call setState (or forceUpdate) on an unmounted component. This \" +\n        \"is a no-op, but it indicates a memory leak in your application. To \" +\n        \"fix, cancel all subscriptions and asynchronous tasks in the \" +\n        \"componentWillUnmount method.%s\",\n      getStackAddendumByWorkInProgressFiber(fiber)\n    );\n    didWarnStateUpdateForUnmountedComponent[componentName] = true;\n  };\n\n  warnAboutInvalidUpdates = function(instance) {\n    switch (ReactDebugCurrentFiber.phase) {\n      case \"getChildContext\":\n        if (didWarnSetStateChildContext) {\n          return;\n        }\n        warning(\n          false,\n          \"setState(...): Cannot call setState() inside getChildContext()\"\n        );\n        didWarnSetStateChildContext = true;\n        break;\n      case \"render\":\n        if (didWarnAboutStateTransition) {\n          return;\n        }\n        warning(\n          false,\n          \"Cannot update during an existing state transition (such as within \" +\n            \"`render` or another component's constructor). Render methods should \" +\n            \"be a pure function of props and state; constructor side-effects are \" +\n            \"an anti-pattern, but can be moved to `componentWillMount`.\"\n        );\n        didWarnAboutStateTransition = true;\n        break;\n    }\n  };\n}\n\n// Represents the current time in ms.\nvar originalStartTimeMs = now();\nvar mostRecentCurrentTime = msToExpirationTime(0);\nvar mostRecentCurrentTimeMs = originalStartTimeMs;\n\n// Used to ensure computeUniqueAsyncExpiration is monotonically increases.\nvar lastUniqueAsyncExpiration = 0;\n\n// Represents the expiration time that incoming updates should use. (If this\n// is NoWork, use the default strategy: async updates in async mode, sync\n// updates in sync mode.)\nvar expirationContext = NoWork;\n\nvar isWorking = false;\n\n// The next work in progress fiber that we're currently working on.\nvar nextUnitOfWork = null;\nvar nextRoot = null;\n// The time at which we're currently rendering work.\nvar nextRenderExpirationTime = NoWork;\nvar nextLatestTimeoutMs = -1;\nvar nextRenderDidError = false;\n\n// The next fiber with an effect that we're currently committing.\nvar nextEffect = null;\n\nvar isCommitting$1 = false;\n\nvar legacyErrorBoundariesThatAlreadyFailed = null;\n\n// Used for performance tracking.\nvar interruptedBy = null;\n\nvar stashedWorkInProgressProperties = void 0;\nvar replayUnitOfWork = void 0;\nvar isReplayingFailedUnitOfWork = void 0;\nvar originalReplayError = void 0;\nvar rethrowOriginalError = void 0;\nif (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n  stashedWorkInProgressProperties = null;\n  isReplayingFailedUnitOfWork = false;\n  originalReplayError = null;\n  replayUnitOfWork = function(failedUnitOfWork, thrownValue, isYieldy) {\n    if (\n      thrownValue !== null &&\n      typeof thrownValue === \"object\" &&\n      typeof thrownValue.then === \"function\"\n    ) {\n      // Don't replay promises. Treat everything else like an error.\n      // TODO: Need to figure out a different strategy if/when we add\n      // support for catching other types.\n      return;\n    }\n\n    // Restore the original state of the work-in-progress\n    if (stashedWorkInProgressProperties === null) {\n      // This should never happen. Don't throw because this code is DEV-only.\n      warning(\n        false,\n        \"Could not replay rendering after an error. This is likely a bug in React. \" +\n          \"Please file an issue.\"\n      );\n      return;\n    }\n    assignFiberPropertiesInDEV(\n      failedUnitOfWork,\n      stashedWorkInProgressProperties\n    );\n\n    switch (failedUnitOfWork.tag) {\n      case HostRoot:\n        popHostContainer(failedUnitOfWork);\n        popTopLevelContextObject(failedUnitOfWork);\n        break;\n      case HostComponent:\n        popHostContext(failedUnitOfWork);\n        break;\n      case ClassComponent:\n        popContextProvider(failedUnitOfWork);\n        break;\n      case HostPortal:\n        popHostContainer(failedUnitOfWork);\n        break;\n      case ContextProvider:\n        popProvider(failedUnitOfWork);\n        break;\n    }\n    // Replay the begin phase.\n    isReplayingFailedUnitOfWork = true;\n    originalReplayError = thrownValue;\n    invokeGuardedCallback$2(null, workLoop, null, isYieldy);\n    isReplayingFailedUnitOfWork = false;\n    originalReplayError = null;\n    if (hasCaughtError()) {\n      clearCaughtError();\n\n      if (enableProfilerTimer) {\n        if (failedUnitOfWork.mode & ProfileMode) {\n          recordElapsedActualRenderTime(failedUnitOfWork);\n        }\n\n        // Stop \"base\" render timer again (after the re-thrown error).\n        stopBaseRenderTimerIfRunning();\n      }\n    } else {\n      // If the begin phase did not fail the second time, set this pointer\n      // back to the original value.\n      nextUnitOfWork = failedUnitOfWork;\n    }\n  };\n  rethrowOriginalError = function() {\n    throw originalReplayError;\n  };\n}\n\nfunction resetStack() {\n  if (nextUnitOfWork !== null) {\n    var interruptedWork = nextUnitOfWork.return;\n    while (interruptedWork !== null) {\n      unwindInterruptedWork(interruptedWork);\n      interruptedWork = interruptedWork.return;\n    }\n  }\n\n  {\n    ReactStrictModeWarnings.discardPendingWarnings();\n    checkThatStackIsEmpty();\n  }\n\n  nextRoot = null;\n  nextRenderExpirationTime = NoWork;\n  nextLatestTimeoutMs = -1;\n  nextRenderDidError = false;\n  nextUnitOfWork = null;\n}\n\nfunction commitAllHostEffects() {\n  while (nextEffect !== null) {\n    {\n      ReactDebugCurrentFiber.setCurrentFiber(nextEffect);\n    }\n    recordEffect();\n\n    var effectTag = nextEffect.effectTag;\n\n    if (effectTag & ContentReset) {\n      commitResetTextContent(nextEffect);\n    }\n\n    if (effectTag & Ref) {\n      var current = nextEffect.alternate;\n      if (current !== null) {\n        commitDetachRef(current);\n      }\n    }\n\n    // The following switch statement is only concerned about placement,\n    // updates, and deletions. To avoid needing to add a case for every\n    // possible bitmap value, we remove the secondary effects from the\n    // effect tag and switch on that value.\n    var primaryEffectTag = effectTag & (Placement | Update | Deletion);\n    switch (primaryEffectTag) {\n      case Placement: {\n        commitPlacement(nextEffect);\n        // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n        // any life-cycles like componentDidMount gets called.\n        // TODO: findDOMNode doesn't rely on this any more but isMounted\n        // does and isMounted is deprecated anyway so we should be able\n        // to kill this.\n        nextEffect.effectTag &= ~Placement;\n        break;\n      }\n      case PlacementAndUpdate: {\n        // Placement\n        commitPlacement(nextEffect);\n        // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n        // any life-cycles like componentDidMount gets called.\n        nextEffect.effectTag &= ~Placement;\n\n        // Update\n        var _current = nextEffect.alternate;\n        commitWork(_current, nextEffect);\n        break;\n      }\n      case Update: {\n        var _current2 = nextEffect.alternate;\n        commitWork(_current2, nextEffect);\n        break;\n      }\n      case Deletion: {\n        commitDeletion(nextEffect);\n        break;\n      }\n    }\n    nextEffect = nextEffect.nextEffect;\n  }\n\n  {\n    ReactDebugCurrentFiber.resetCurrentFiber();\n  }\n}\n\nfunction commitBeforeMutationLifecycles() {\n  while (nextEffect !== null) {\n    var effectTag = nextEffect.effectTag;\n\n    if (effectTag & Snapshot) {\n      recordEffect();\n      var current = nextEffect.alternate;\n      commitBeforeMutationLifeCycles(current, nextEffect);\n    }\n\n    // Don't cleanup effects yet;\n    // This will be done by commitAllLifeCycles()\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n\nfunction commitAllLifeCycles(\n  finishedRoot,\n  currentTime,\n  committedExpirationTime\n) {\n  {\n    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.flushPendingDeprecationWarnings();\n    }\n\n    if (warnAboutLegacyContextAPI) {\n      ReactStrictModeWarnings.flushLegacyContextWarning();\n    }\n  }\n  while (nextEffect !== null) {\n    var effectTag = nextEffect.effectTag;\n\n    if (effectTag & (Update | Callback)) {\n      recordEffect();\n      var current = nextEffect.alternate;\n      commitLifeCycles(\n        finishedRoot,\n        current,\n        nextEffect,\n        currentTime,\n        committedExpirationTime\n      );\n    }\n\n    if (effectTag & Ref) {\n      recordEffect();\n      commitAttachRef(nextEffect);\n    }\n\n    var next = nextEffect.nextEffect;\n    // Ensure that we clean these up so that we don't accidentally keep them.\n    // I'm not actually sure this matters because we can't reset firstEffect\n    // and lastEffect since they're on every node, not just the effectful\n    // ones. So we have to clean everything as we reuse nodes anyway.\n    nextEffect.nextEffect = null;\n    // Ensure that we reset the effectTag here so that we can rely on effect\n    // tags to reason about the current life-cycle.\n    nextEffect = next;\n  }\n}\n\nfunction isAlreadyFailedLegacyErrorBoundary(instance) {\n  return (\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\n  );\n}\n\nfunction markLegacyErrorBoundaryAsFailed(instance) {\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n  } else {\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\n  }\n}\n\nfunction commitRoot(root, finishedWork) {\n  isWorking = true;\n  isCommitting$1 = true;\n  startCommitTimer();\n\n  invariant(\n    root.current !== finishedWork,\n    \"Cannot commit the same tree as before. This is probably a bug \" +\n      \"related to the return field. This error is likely caused by a bug \" +\n      \"in React. Please file an issue.\"\n  );\n  var committedExpirationTime = root.pendingCommitExpirationTime;\n  invariant(\n    committedExpirationTime !== NoWork,\n    \"Cannot commit an incomplete root. This error is likely caused by a \" +\n      \"bug in React. Please file an issue.\"\n  );\n  root.pendingCommitExpirationTime = NoWork;\n\n  // Update the pending priority levels to account for the work that we are\n  // about to commit. This needs to happen before calling the lifecycles, since\n  // they may schedule additional updates.\n  var earliestRemainingTime = finishedWork.expirationTime;\n  var currentTime = recalculateCurrentTime();\n  markCommittedPriorityLevels(root, currentTime, earliestRemainingTime);\n\n  // Reset this to null before calling lifecycles\n  ReactCurrentOwner.current = null;\n\n  var firstEffect = void 0;\n  if (finishedWork.effectTag > PerformedWork) {\n    // A fiber's effect list consists only of its children, not itself. So if\n    // the root has an effect, we need to add it to the end of the list. The\n    // resulting list is the set that would belong to the root's parent, if\n    // it had one; that is, all the effects in the tree including the root.\n    if (finishedWork.lastEffect !== null) {\n      finishedWork.lastEffect.nextEffect = finishedWork;\n      firstEffect = finishedWork.firstEffect;\n    } else {\n      firstEffect = finishedWork;\n    }\n  } else {\n    // There is no effect on the root.\n    firstEffect = finishedWork.firstEffect;\n  }\n\n  prepareForCommit(root.containerInfo);\n\n  // Invoke instances of getSnapshotBeforeUpdate before mutation.\n  nextEffect = firstEffect;\n  startCommitSnapshotEffectsTimer();\n  while (nextEffect !== null) {\n    var didError = false;\n    var error = void 0;\n    {\n      invokeGuardedCallback$2(null, commitBeforeMutationLifecycles, null);\n      if (hasCaughtError()) {\n        didError = true;\n        error = clearCaughtError();\n      }\n    }\n    if (didError) {\n      invariant(\n        nextEffect !== null,\n        \"Should have next effect. This error is likely caused by a bug \" +\n          \"in React. Please file an issue.\"\n      );\n      captureCommitPhaseError(nextEffect, error);\n      // Clean-up\n      if (nextEffect !== null) {\n        nextEffect = nextEffect.nextEffect;\n      }\n    }\n  }\n  stopCommitSnapshotEffectsTimer();\n\n  if (enableProfilerTimer) {\n    // Mark the current commit time to be shared by all Profilers in this batch.\n    // This enables them to be grouped later.\n    recordCommitTime();\n  }\n\n  // Commit all the side-effects within a tree. We'll do this in two passes.\n  // The first pass performs all the host insertions, updates, deletions and\n  // ref unmounts.\n  nextEffect = firstEffect;\n  startCommitHostEffectsTimer();\n  while (nextEffect !== null) {\n    var _didError = false;\n    var _error = void 0;\n    {\n      invokeGuardedCallback$2(null, commitAllHostEffects, null);\n      if (hasCaughtError()) {\n        _didError = true;\n        _error = clearCaughtError();\n      }\n    }\n    if (_didError) {\n      invariant(\n        nextEffect !== null,\n        \"Should have next effect. This error is likely caused by a bug \" +\n          \"in React. Please file an issue.\"\n      );\n      captureCommitPhaseError(nextEffect, _error);\n      // Clean-up\n      if (nextEffect !== null) {\n        nextEffect = nextEffect.nextEffect;\n      }\n    }\n  }\n  stopCommitHostEffectsTimer();\n\n  resetAfterCommit(root.containerInfo);\n\n  // The work-in-progress tree is now the current tree. This must come after\n  // the first pass of the commit phase, so that the previous tree is still\n  // current during componentWillUnmount, but before the second pass, so that\n  // the finished work is current during componentDidMount/Update.\n  root.current = finishedWork;\n\n  // In the second pass we'll perform all life-cycles and ref callbacks.\n  // Life-cycles happen as a separate pass so that all placements, updates,\n  // and deletions in the entire tree have already been invoked.\n  // This pass also triggers any renderer-specific initial effects.\n  nextEffect = firstEffect;\n  startCommitLifeCyclesTimer();\n  while (nextEffect !== null) {\n    var _didError2 = false;\n    var _error2 = void 0;\n    {\n      invokeGuardedCallback$2(\n        null,\n        commitAllLifeCycles,\n        null,\n        root,\n        currentTime,\n        committedExpirationTime\n      );\n      if (hasCaughtError()) {\n        _didError2 = true;\n        _error2 = clearCaughtError();\n      }\n    }\n    if (_didError2) {\n      invariant(\n        nextEffect !== null,\n        \"Should have next effect. This error is likely caused by a bug \" +\n          \"in React. Please file an issue.\"\n      );\n      captureCommitPhaseError(nextEffect, _error2);\n      if (nextEffect !== null) {\n        nextEffect = nextEffect.nextEffect;\n      }\n    }\n  }\n\n  if (enableProfilerTimer) {\n    {\n      checkActualRenderTimeStackEmpty();\n    }\n    resetActualRenderTimer();\n  }\n\n  isCommitting$1 = false;\n  isWorking = false;\n  stopCommitLifeCyclesTimer();\n  stopCommitTimer();\n  if (typeof onCommitRoot === \"function\") {\n    onCommitRoot(finishedWork.stateNode);\n  }\n  if (true && ReactFiberInstrumentation_1.debugTool) {\n    ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);\n  }\n\n  var expirationTime = root.expirationTime;\n  if (expirationTime === NoWork) {\n    // If there's no remaining work, we can clear the set of already failed\n    // error boundaries.\n    legacyErrorBoundariesThatAlreadyFailed = null;\n  }\n  onCommit(root, expirationTime);\n}\n\nfunction resetExpirationTime(workInProgress, renderTime) {\n  if (renderTime !== Never && workInProgress.expirationTime === Never) {\n    // The children of this component are hidden. Don't bubble their\n    // expiration times.\n    return;\n  }\n\n  // Check for pending updates.\n  var newExpirationTime = NoWork;\n  switch (workInProgress.tag) {\n    case HostRoot:\n    case ClassComponent: {\n      var updateQueue = workInProgress.updateQueue;\n      if (updateQueue !== null) {\n        newExpirationTime = updateQueue.expirationTime;\n      }\n    }\n  }\n\n  // TODO: Calls need to visit stateNode\n\n  // Bubble up the earliest expiration time.\n  // (And \"base\" render timers if that feature flag is enabled)\n  if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n    var treeBaseTime = workInProgress.selfBaseTime;\n    var child = workInProgress.child;\n    while (child !== null) {\n      treeBaseTime += child.treeBaseTime;\n      if (\n        child.expirationTime !== NoWork &&\n        (newExpirationTime === NoWork ||\n          newExpirationTime > child.expirationTime)\n      ) {\n        newExpirationTime = child.expirationTime;\n      }\n      child = child.sibling;\n    }\n    workInProgress.treeBaseTime = treeBaseTime;\n  } else {\n    var _child = workInProgress.child;\n    while (_child !== null) {\n      if (\n        _child.expirationTime !== NoWork &&\n        (newExpirationTime === NoWork ||\n          newExpirationTime > _child.expirationTime)\n      ) {\n        newExpirationTime = _child.expirationTime;\n      }\n      _child = _child.sibling;\n    }\n  }\n\n  workInProgress.expirationTime = newExpirationTime;\n}\n\nfunction completeUnitOfWork(workInProgress) {\n  // Attempt to complete the current unit of work, then move to the\n  // next sibling. If there are no more siblings, return to the\n  // parent fiber.\n  while (true) {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    var current = workInProgress.alternate;\n    {\n      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n    }\n\n    var returnFiber = workInProgress.return;\n    var siblingFiber = workInProgress.sibling;\n\n    if ((workInProgress.effectTag & Incomplete) === NoEffect) {\n      // This fiber completed.\n      var next = completeWork(\n        current,\n        workInProgress,\n        nextRenderExpirationTime\n      );\n      stopWorkTimer(workInProgress);\n      resetExpirationTime(workInProgress, nextRenderExpirationTime);\n      {\n        ReactDebugCurrentFiber.resetCurrentFiber();\n      }\n\n      if (next !== null) {\n        stopWorkTimer(workInProgress);\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        return next;\n      }\n\n      if (\n        returnFiber !== null &&\n        // Do not append effects to parents if a sibling failed to complete\n        (returnFiber.effectTag & Incomplete) === NoEffect\n      ) {\n        // Append all the effects of the subtree and this fiber onto the effect\n        // list of the parent. The completion order of the children affects the\n        // side-effect order.\n        if (returnFiber.firstEffect === null) {\n          returnFiber.firstEffect = workInProgress.firstEffect;\n        }\n        if (workInProgress.lastEffect !== null) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n          }\n          returnFiber.lastEffect = workInProgress.lastEffect;\n        }\n\n        // If this fiber had side-effects, we append it AFTER the children's\n        // side-effects. We can perform certain side-effects earlier if\n        // needed, by doing multiple passes over the effect list. We don't want\n        // to schedule our own side-effect on our own list because if end up\n        // reusing children we'll schedule this effect onto itself since we're\n        // at the end.\n        var effectTag = workInProgress.effectTag;\n        // Skip both NoWork and PerformedWork tags when creating the effect list.\n        // PerformedWork effect is read by React DevTools but shouldn't be committed.\n        if (effectTag > PerformedWork) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress;\n          } else {\n            returnFiber.firstEffect = workInProgress;\n          }\n          returnFiber.lastEffect = workInProgress;\n        }\n      }\n\n      if (true && ReactFiberInstrumentation_1.debugTool) {\n        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n      }\n\n      if (siblingFiber !== null) {\n        // If there is more work to do in this returnFiber, do that next.\n        return siblingFiber;\n      } else if (returnFiber !== null) {\n        // If there's no more work in this returnFiber. Complete the returnFiber.\n        workInProgress = returnFiber;\n        continue;\n      } else {\n        // We've reached the root.\n        return null;\n      }\n    } else {\n      // This fiber did not complete because something threw. Pop values off\n      // the stack without entering the complete phase. If this is a boundary,\n      // capture values if possible.\n      var _next = unwindWork(workInProgress, nextRenderExpirationTime);\n      // Because this fiber did not complete, don't reset its expiration time.\n      if (workInProgress.effectTag & DidCapture) {\n        // Restarting an error boundary\n        stopFailedWorkTimer(workInProgress);\n      } else {\n        stopWorkTimer(workInProgress);\n      }\n\n      {\n        ReactDebugCurrentFiber.resetCurrentFiber();\n      }\n\n      if (_next !== null) {\n        stopWorkTimer(workInProgress);\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        // Since we're restarting, remove anything that is not a host effect\n        // from the effect tag.\n        _next.effectTag &= HostEffectMask;\n        return _next;\n      }\n\n      if (returnFiber !== null) {\n        // Mark the parent fiber as incomplete and clear its effect list.\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\n        returnFiber.effectTag |= Incomplete;\n      }\n\n      if (true && ReactFiberInstrumentation_1.debugTool) {\n        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n      }\n\n      if (siblingFiber !== null) {\n        // If there is more work to do in this returnFiber, do that next.\n        return siblingFiber;\n      } else if (returnFiber !== null) {\n        // If there's no more work in this returnFiber. Complete the returnFiber.\n        workInProgress = returnFiber;\n        continue;\n      } else {\n        return null;\n      }\n    }\n  }\n\n  // Without this explicit null return Flow complains of invalid return type\n  // TODO Remove the above while(true) loop\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nfunction performUnitOfWork(workInProgress) {\n  // The current, flushed, state of this fiber is the alternate.\n  // Ideally nothing should rely on this, but relying on it here\n  // means that we don't need an additional field on the work in\n  // progress.\n  var current = workInProgress.alternate;\n\n  // See if beginning this work spawns more work.\n  startWorkTimer(workInProgress);\n  {\n    ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n  }\n\n  if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n    stashedWorkInProgressProperties = assignFiberPropertiesInDEV(\n      stashedWorkInProgressProperties,\n      workInProgress\n    );\n  }\n\n  var next = void 0;\n  if (enableProfilerTimer) {\n    if (workInProgress.mode & ProfileMode) {\n      startBaseRenderTimer();\n    }\n\n    next = beginWork(current, workInProgress, nextRenderExpirationTime);\n\n    if (workInProgress.mode & ProfileMode) {\n      // Update \"base\" time if the render wasn't bailed out on.\n      recordElapsedBaseRenderTimeIfRunning(workInProgress);\n      stopBaseRenderTimerIfRunning();\n    }\n  } else {\n    next = beginWork(current, workInProgress, nextRenderExpirationTime);\n  }\n\n  {\n    ReactDebugCurrentFiber.resetCurrentFiber();\n    if (isReplayingFailedUnitOfWork) {\n      // Currently replaying a failed unit of work. This should be unreachable,\n      // because the render phase is meant to be idempotent, and it should\n      // have thrown again. Since it didn't, rethrow the original error, so\n      // React's internal stack is not misaligned.\n      rethrowOriginalError();\n    }\n  }\n  if (true && ReactFiberInstrumentation_1.debugTool) {\n    ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n  }\n\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    next = completeUnitOfWork(workInProgress);\n  }\n\n  ReactCurrentOwner.current = null;\n\n  return next;\n}\n\nfunction workLoop(isYieldy) {\n  if (!isYieldy) {\n    // Flush work without yielding\n    while (nextUnitOfWork !== null) {\n      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    }\n  } else {\n    // Flush asynchronous work until the deadline runs out of time.\n    while (nextUnitOfWork !== null && !shouldYield()) {\n      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    }\n\n    if (enableProfilerTimer) {\n      // If we didn't finish, pause the \"actual\" render timer.\n      // We'll restart it when we resume work.\n      pauseActualRenderTimerIfRunning();\n    }\n  }\n}\n\nfunction renderRoot(root, isYieldy) {\n  invariant(\n    !isWorking,\n    \"renderRoot was called recursively. This error is likely caused \" +\n      \"by a bug in React. Please file an issue.\"\n  );\n  isWorking = true;\n\n  var expirationTime = root.nextExpirationTimeToWorkOn;\n\n  // Check if we're starting from a fresh stack, or if we're resuming from\n  // previously yielded work.\n  if (\n    expirationTime !== nextRenderExpirationTime ||\n    root !== nextRoot ||\n    nextUnitOfWork === null\n  ) {\n    // Reset the stack and start working from the root.\n    resetStack();\n    nextRoot = root;\n    nextRenderExpirationTime = expirationTime;\n    nextLatestTimeoutMs = -1;\n    nextRenderDidError = false;\n    nextUnitOfWork = createWorkInProgress(\n      nextRoot.current,\n      null,\n      nextRenderExpirationTime\n    );\n    root.pendingCommitExpirationTime = NoWork;\n  }\n\n  var didFatal = false;\n\n  startWorkLoopTimer(nextUnitOfWork);\n\n  do {\n    try {\n      workLoop(isYieldy);\n    } catch (thrownValue) {\n      if (enableProfilerTimer) {\n        // Stop \"base\" render timer in the event of an error.\n        stopBaseRenderTimerIfRunning();\n      }\n\n      if (nextUnitOfWork === null) {\n        // This is a fatal error.\n        didFatal = true;\n        onUncaughtError(thrownValue);\n      } else {\n        {\n          // Reset global debug state\n          // We assume this is defined in DEV\n          resetCurrentlyProcessingQueue();\n        }\n\n        var failedUnitOfWork = nextUnitOfWork;\n        if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n          replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy);\n        }\n\n        // TODO: we already know this isn't true in some cases.\n        // At least this shows a nicer error message until we figure out the cause.\n        // https://github.com/facebook/react/issues/12449#issuecomment-386727431\n        invariant(\n          nextUnitOfWork !== null,\n          \"Failed to replay rendering after an error. This \" +\n            \"is likely caused by a bug in React. Please file an issue \" +\n            \"with a reproducing case to help us find it.\"\n        );\n\n        var sourceFiber = nextUnitOfWork;\n        var returnFiber = sourceFiber.return;\n        if (returnFiber === null) {\n          // This is the root. The root could capture its own errors. However,\n          // we don't know if it errors before or after we pushed the host\n          // context. This information is needed to avoid a stack mismatch.\n          // Because we're not sure, treat this as a fatal error. We could track\n          // which phase it fails in, but doesn't seem worth it. At least\n          // for now.\n          didFatal = true;\n          onUncaughtError(thrownValue);\n          break;\n        }\n        throwException(\n          root,\n          returnFiber,\n          sourceFiber,\n          thrownValue,\n          nextRenderExpirationTime,\n          mostRecentCurrentTimeMs\n        );\n        nextUnitOfWork = completeUnitOfWork(sourceFiber);\n      }\n    }\n    break;\n  } while (true);\n\n  // We're done performing work. Time to clean up.\n  isWorking = false;\n\n  // Yield back to main thread.\n  if (didFatal) {\n    var didCompleteRoot = false;\n    stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n    interruptedBy = null;\n    // There was a fatal error.\n    {\n      resetStackAfterFatalErrorInDev();\n    }\n    onFatal(root);\n  } else if (nextUnitOfWork === null) {\n    // We reached the root.\n    var rootWorkInProgress = root.current.alternate;\n    invariant(\n      rootWorkInProgress !== null,\n      \"Finished root should have a work-in-progress. This error is likely \" +\n        \"caused by a bug in React. Please file an issue.\"\n    );\n    if ((rootWorkInProgress.effectTag & Incomplete) === NoEffect) {\n      var _didCompleteRoot = true;\n      stopWorkLoopTimer(interruptedBy, _didCompleteRoot);\n      interruptedBy = null;\n      // The root successfully completed.\n      onComplete(root, rootWorkInProgress, expirationTime);\n    } else {\n      // The root did not complete.\n      var _didCompleteRoot2 = false;\n      stopWorkLoopTimer(interruptedBy, _didCompleteRoot2);\n      interruptedBy = null;\n      markSuspendedPriorityLevel(root, expirationTime, nextRenderDidError);\n      var suspendedExpirationTime = expirationTime;\n      var newExpirationTime = root.expirationTime;\n      onSuspend(\n        root,\n        suspendedExpirationTime,\n        newExpirationTime,\n        nextLatestTimeoutMs\n      );\n    }\n  } else {\n    var _didCompleteRoot3 = false;\n    stopWorkLoopTimer(interruptedBy, _didCompleteRoot3);\n    interruptedBy = null;\n    onYield(root);\n  }\n}\n\nfunction dispatch(sourceFiber, value, expirationTime) {\n  invariant(\n    !isWorking || isCommitting$1,\n    \"dispatch: Cannot dispatch during the render phase.\"\n  );\n\n  var fiber = sourceFiber.return;\n  while (fiber !== null) {\n    switch (fiber.tag) {\n      case ClassComponent:\n        var ctor = fiber.type;\n        var instance = fiber.stateNode;\n        if (\n          typeof ctor.getDerivedStateFromCatch === \"function\" ||\n          (typeof instance.componentDidCatch === \"function\" &&\n            !isAlreadyFailedLegacyErrorBoundary(instance))\n        ) {\n          var errorInfo = createCapturedValue(value, sourceFiber);\n          var update = createClassErrorUpdate(fiber, errorInfo, expirationTime);\n          enqueueUpdate(fiber, update, expirationTime);\n          scheduleWork(fiber, expirationTime);\n          return;\n        }\n        break;\n      case HostRoot: {\n        var _errorInfo = createCapturedValue(value, sourceFiber);\n        var _update = createRootErrorUpdate(fiber, _errorInfo, expirationTime);\n        enqueueUpdate(fiber, _update, expirationTime);\n        scheduleWork(fiber, expirationTime);\n        return;\n      }\n    }\n    fiber = fiber.return;\n  }\n\n  if (sourceFiber.tag === HostRoot) {\n    // Error was thrown at the root. There is no parent, so the root\n    // itself should capture it.\n    var rootFiber = sourceFiber;\n    var _errorInfo2 = createCapturedValue(value, rootFiber);\n    var _update2 = createRootErrorUpdate(\n      rootFiber,\n      _errorInfo2,\n      expirationTime\n    );\n    enqueueUpdate(rootFiber, _update2, expirationTime);\n    scheduleWork(rootFiber, expirationTime);\n  }\n}\n\nfunction captureCommitPhaseError(fiber, error) {\n  return dispatch(fiber, error, Sync);\n}\n\nfunction computeAsyncExpiration(currentTime) {\n  // Given the current clock time, returns an expiration time. We use rounding\n  // to batch like updates together.\n  // Should complete within ~5000ms. 5250ms max.\n  var expirationMs = 5000;\n  var bucketSizeMs = 250;\n  return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);\n}\n\nfunction computeInteractiveExpiration(currentTime) {\n  var expirationMs = void 0;\n  // We intentionally set a higher expiration time for interactive updates in\n  // dev than in production.\n  // If the main thread is being blocked so long that you hit the expiration,\n  // it's a problem that could be solved with better scheduling.\n  // People will be more likely to notice this and fix it with the long\n  // expiration time in development.\n  // In production we opt for better UX at the risk of masking scheduling\n  // problems, by expiring fast.\n  {\n    // Should complete within ~500ms. 600ms max.\n    expirationMs = 500;\n  }\n  var bucketSizeMs = 100;\n  return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);\n}\n\n// Creates a unique async expiration time.\nfunction computeUniqueAsyncExpiration() {\n  var currentTime = recalculateCurrentTime();\n  var result = computeAsyncExpiration(currentTime);\n  if (result <= lastUniqueAsyncExpiration) {\n    // Since we assume the current time monotonically increases, we only hit\n    // this branch when computeUniqueAsyncExpiration is fired multiple times\n    // within a 200ms window (or whatever the async bucket size is).\n    result = lastUniqueAsyncExpiration + 1;\n  }\n  lastUniqueAsyncExpiration = result;\n  return lastUniqueAsyncExpiration;\n}\n\nfunction computeExpirationForFiber(currentTime, fiber) {\n  var expirationTime = void 0;\n  if (expirationContext !== NoWork) {\n    // An explicit expiration context was set;\n    expirationTime = expirationContext;\n  } else if (isWorking) {\n    if (isCommitting$1) {\n      // Updates that occur during the commit phase should have sync priority\n      // by default.\n      expirationTime = Sync;\n    } else {\n      // Updates during the render phase should expire at the same time as\n      // the work that is being rendered.\n      expirationTime = nextRenderExpirationTime;\n    }\n  } else {\n    // No explicit expiration context was set, and we're not currently\n    // performing work. Calculate a new expiration time.\n    if (fiber.mode & AsyncMode) {\n      if (isBatchingInteractiveUpdates) {\n        // This is an interactive update\n        expirationTime = computeInteractiveExpiration(currentTime);\n      } else {\n        // This is an async update\n        expirationTime = computeAsyncExpiration(currentTime);\n      }\n    } else {\n      // This is a sync update\n      expirationTime = Sync;\n    }\n  }\n  if (isBatchingInteractiveUpdates) {\n    // This is an interactive update. Keep track of the lowest pending\n    // interactive expiration time. This allows us to synchronously flush\n    // all interactive updates when needed.\n    if (\n      lowestPendingInteractiveExpirationTime === NoWork ||\n      expirationTime > lowestPendingInteractiveExpirationTime\n    ) {\n      lowestPendingInteractiveExpirationTime = expirationTime;\n    }\n  }\n  return expirationTime;\n}\n\nfunction markTimeout(root, thenable, timeoutMs, suspendedTime) {\n  // Schedule the timeout.\n  if (timeoutMs >= 0 && nextLatestTimeoutMs < timeoutMs) {\n    nextLatestTimeoutMs = timeoutMs;\n  }\n}\n\nfunction markError(root) {\n  nextRenderDidError = true;\n}\n\nfunction retrySuspendedRoot(root, suspendedTime) {\n  markPingedPriorityLevel(root, suspendedTime);\n  var retryTime = root.expirationTime;\n  if (retryTime !== NoWork) {\n    requestWork(root, retryTime);\n  }\n}\n\nfunction scheduleWork(fiber, expirationTime) {\n  recordScheduleUpdate();\n\n  {\n    if (fiber.tag === ClassComponent) {\n      var instance = fiber.stateNode;\n      warnAboutInvalidUpdates(instance);\n    }\n  }\n\n  var node = fiber;\n  while (node !== null) {\n    // Walk the parent path to the root and update each node's\n    // expiration time.\n    if (\n      node.expirationTime === NoWork ||\n      node.expirationTime > expirationTime\n    ) {\n      node.expirationTime = expirationTime;\n    }\n    if (node.alternate !== null) {\n      if (\n        node.alternate.expirationTime === NoWork ||\n        node.alternate.expirationTime > expirationTime\n      ) {\n        node.alternate.expirationTime = expirationTime;\n      }\n    }\n    if (node.return === null) {\n      if (node.tag === HostRoot) {\n        var root = node.stateNode;\n        if (\n          !isWorking &&\n          nextRenderExpirationTime !== NoWork &&\n          expirationTime < nextRenderExpirationTime\n        ) {\n          // This is an interruption. (Used for performance tracking.)\n          interruptedBy = fiber;\n          resetStack();\n        }\n        markPendingPriorityLevel(root, expirationTime);\n        if (\n          // If we're in the render phase, we don't need to schedule this root\n          // for an update, because we'll do it before we exit...\n          !isWorking ||\n          isCommitting$1 ||\n          // ...unless this is a different root than the one we're rendering.\n          nextRoot !== root\n        ) {\n          var rootExpirationTime = root.expirationTime;\n          requestWork(root, rootExpirationTime);\n        }\n        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n          invariant(\n            false,\n            \"Maximum update depth exceeded. This can happen when a \" +\n              \"component repeatedly calls setState inside \" +\n              \"componentWillUpdate or componentDidUpdate. React limits \" +\n              \"the number of nested updates to prevent infinite loops.\"\n          );\n        }\n      } else {\n        {\n          if (fiber.tag === ClassComponent) {\n            warnAboutUpdateOnUnmounted(fiber);\n          }\n        }\n        return;\n      }\n    }\n    node = node.return;\n  }\n}\n\nfunction recalculateCurrentTime() {\n  // Subtract initial time so it fits inside 32bits\n  mostRecentCurrentTimeMs = now() - originalStartTimeMs;\n  mostRecentCurrentTime = msToExpirationTime(mostRecentCurrentTimeMs);\n  return mostRecentCurrentTime;\n}\n\nfunction deferredUpdates(fn) {\n  var previousExpirationContext = expirationContext;\n  var currentTime = recalculateCurrentTime();\n  expirationContext = computeAsyncExpiration(currentTime);\n  try {\n    return fn();\n  } finally {\n    expirationContext = previousExpirationContext;\n  }\n}\nfunction syncUpdates(fn, a, b, c, d) {\n  var previousExpirationContext = expirationContext;\n  expirationContext = Sync;\n  try {\n    return fn(a, b, c, d);\n  } finally {\n    expirationContext = previousExpirationContext;\n  }\n}\n\n// TODO: Everything below this is written as if it has been lifted to the\n// renderers. I'll do this in a follow-up.\n\n// Linked-list of roots\nvar firstScheduledRoot = null;\nvar lastScheduledRoot = null;\n\nvar callbackExpirationTime = NoWork;\nvar callbackID = void 0;\nvar isRendering = false;\nvar nextFlushedRoot = null;\nvar nextFlushedExpirationTime = NoWork;\nvar lowestPendingInteractiveExpirationTime = NoWork;\nvar deadlineDidExpire = false;\nvar hasUnhandledError = false;\nvar unhandledError = null;\nvar deadline = null;\n\nvar isBatchingUpdates = false;\nvar isUnbatchingUpdates = false;\nvar isBatchingInteractiveUpdates = false;\n\nvar completedBatches = null;\n\n// Use these to prevent an infinite loop of nested updates\nvar NESTED_UPDATE_LIMIT = 1000;\nvar nestedUpdateCount = 0;\n\nvar timeHeuristicForUnitOfWork = 1;\n\nfunction scheduleCallbackWithExpirationTime(expirationTime) {\n  if (callbackExpirationTime !== NoWork) {\n    // A callback is already scheduled. Check its expiration time (timeout).\n    if (expirationTime > callbackExpirationTime) {\n      // Existing callback has sufficient timeout. Exit.\n      return;\n    } else {\n      if (callbackID !== null) {\n        // Existing callback has insufficient timeout. Cancel and schedule a\n        // new one.\n        cancelDeferredCallback(callbackID);\n      }\n    }\n    // The request callback timer is already running. Don't start a new one.\n  } else {\n    startRequestCallbackTimer();\n  }\n\n  callbackExpirationTime = expirationTime;\n  var currentMs = now() - originalStartTimeMs;\n  var expirationTimeMs = expirationTimeToMs(expirationTime);\n  var timeout = expirationTimeMs - currentMs;\n  callbackID = scheduleDeferredCallback(performAsyncWork, { timeout: timeout });\n}\n\n// For every call to renderRoot, one of onFatal, onComplete, onSuspend, and\n// onYield is called upon exiting. We use these in lieu of returning a tuple.\n// I've also chosen not to inline them into renderRoot because these will\n// eventually be lifted into the renderer.\nfunction onFatal(root) {\n  root.finishedWork = null;\n}\n\nfunction onComplete(root, finishedWork, expirationTime) {\n  root.pendingCommitExpirationTime = expirationTime;\n  root.finishedWork = finishedWork;\n}\n\nfunction onSuspend(root, suspendedExpirationTime, expirationTime, timeoutMs) {\n  if (timeoutMs >= 0) {\n    var suspendedRoot = root;\n    setTimeout(function() {\n      retrySuspendedRoot(suspendedRoot, suspendedExpirationTime);\n    }, timeoutMs);\n  }\n  root.expirationTime = expirationTime;\n}\n\nfunction onYield(root) {\n  root.finishedWork = null;\n}\n\nfunction onCommit(root, expirationTime) {\n  root.expirationTime = expirationTime;\n  root.finishedWork = null;\n}\n\n// requestWork is called by the scheduler whenever a root receives an update.\n// It's up to the renderer to call renderRoot at some point in the future.\nfunction requestWork(root, expirationTime) {\n  addRootToSchedule(root, expirationTime);\n\n  if (isRendering) {\n    // Prevent reentrancy. Remaining work will be scheduled at the end of\n    // the currently rendering batch.\n    return;\n  }\n\n  if (isBatchingUpdates) {\n    // Flush work at the end of the batch.\n    if (isUnbatchingUpdates) {\n      // ...unless we're inside unbatchedUpdates, in which case we should\n      // flush it now.\n      nextFlushedRoot = root;\n      nextFlushedExpirationTime = Sync;\n      performWorkOnRoot(root, Sync, false);\n    }\n    return;\n  }\n\n  // TODO: Get rid of Sync and use current time?\n  if (expirationTime === Sync) {\n    performSyncWork();\n  } else {\n    scheduleCallbackWithExpirationTime(expirationTime);\n  }\n}\n\nfunction addRootToSchedule(root, expirationTime) {\n  // Add the root to the schedule.\n  // Check if this root is already part of the schedule.\n  if (root.nextScheduledRoot === null) {\n    // This root is not already scheduled. Add it.\n    root.expirationTime = expirationTime;\n    if (lastScheduledRoot === null) {\n      firstScheduledRoot = lastScheduledRoot = root;\n      root.nextScheduledRoot = root;\n    } else {\n      lastScheduledRoot.nextScheduledRoot = root;\n      lastScheduledRoot = root;\n      lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n    }\n  } else {\n    // This root is already scheduled, but its priority may have increased.\n    var remainingExpirationTime = root.expirationTime;\n    if (\n      remainingExpirationTime === NoWork ||\n      expirationTime < remainingExpirationTime\n    ) {\n      // Update the priority.\n      root.expirationTime = expirationTime;\n    }\n  }\n}\n\nfunction findHighestPriorityRoot() {\n  var highestPriorityWork = NoWork;\n  var highestPriorityRoot = null;\n  if (lastScheduledRoot !== null) {\n    var previousScheduledRoot = lastScheduledRoot;\n    var root = firstScheduledRoot;\n    while (root !== null) {\n      var remainingExpirationTime = root.expirationTime;\n      if (remainingExpirationTime === NoWork) {\n        // This root no longer has work. Remove it from the scheduler.\n\n        // TODO: This check is redudant, but Flow is confused by the branch\n        // below where we set lastScheduledRoot to null, even though we break\n        // from the loop right after.\n        invariant(\n          previousScheduledRoot !== null && lastScheduledRoot !== null,\n          \"Should have a previous and last root. This error is likely \" +\n            \"caused by a bug in React. Please file an issue.\"\n        );\n        if (root === root.nextScheduledRoot) {\n          // This is the only root in the list.\n          root.nextScheduledRoot = null;\n          firstScheduledRoot = lastScheduledRoot = null;\n          break;\n        } else if (root === firstScheduledRoot) {\n          // This is the first root in the list.\n          var next = root.nextScheduledRoot;\n          firstScheduledRoot = next;\n          lastScheduledRoot.nextScheduledRoot = next;\n          root.nextScheduledRoot = null;\n        } else if (root === lastScheduledRoot) {\n          // This is the last root in the list.\n          lastScheduledRoot = previousScheduledRoot;\n          lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n          root.nextScheduledRoot = null;\n          break;\n        } else {\n          previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;\n          root.nextScheduledRoot = null;\n        }\n        root = previousScheduledRoot.nextScheduledRoot;\n      } else {\n        if (\n          highestPriorityWork === NoWork ||\n          remainingExpirationTime < highestPriorityWork\n        ) {\n          // Update the priority, if it's higher\n          highestPriorityWork = remainingExpirationTime;\n          highestPriorityRoot = root;\n        }\n        if (root === lastScheduledRoot) {\n          break;\n        }\n        previousScheduledRoot = root;\n        root = root.nextScheduledRoot;\n      }\n    }\n  }\n\n  // If the next root is the same as the previous root, this is a nested\n  // update. To prevent an infinite loop, increment the nested update count.\n  var previousFlushedRoot = nextFlushedRoot;\n  if (\n    previousFlushedRoot !== null &&\n    previousFlushedRoot === highestPriorityRoot &&\n    highestPriorityWork === Sync\n  ) {\n    nestedUpdateCount++;\n  } else {\n    // Reset whenever we switch roots.\n    nestedUpdateCount = 0;\n  }\n  nextFlushedRoot = highestPriorityRoot;\n  nextFlushedExpirationTime = highestPriorityWork;\n}\n\nfunction performAsyncWork(dl) {\n  performWork(NoWork, dl);\n}\n\nfunction performSyncWork() {\n  performWork(Sync, null);\n}\n\nfunction performWork(minExpirationTime, dl) {\n  deadline = dl;\n\n  // Keep working on roots until there's no more work, or until the we reach\n  // the deadline.\n  findHighestPriorityRoot();\n\n  if (enableProfilerTimer) {\n    resumeActualRenderTimerIfPaused();\n  }\n\n  if (enableUserTimingAPI && deadline !== null) {\n    var didExpire = nextFlushedExpirationTime < recalculateCurrentTime();\n    var timeout = expirationTimeToMs(nextFlushedExpirationTime);\n    stopRequestCallbackTimer(didExpire, timeout);\n  }\n\n  if (deadline !== null) {\n    while (\n      nextFlushedRoot !== null &&\n      nextFlushedExpirationTime !== NoWork &&\n      (minExpirationTime === NoWork ||\n        minExpirationTime >= nextFlushedExpirationTime) &&\n      (!deadlineDidExpire ||\n        recalculateCurrentTime() >= nextFlushedExpirationTime)\n    ) {\n      recalculateCurrentTime();\n      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, true);\n      findHighestPriorityRoot();\n    }\n  } else {\n    while (\n      nextFlushedRoot !== null &&\n      nextFlushedExpirationTime !== NoWork &&\n      (minExpirationTime === NoWork ||\n        minExpirationTime >= nextFlushedExpirationTime)\n    ) {\n      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, false);\n      findHighestPriorityRoot();\n    }\n  }\n\n  // We're done flushing work. Either we ran out of time in this callback,\n  // or there's no more work left with sufficient priority.\n\n  // If we're inside a callback, set this to false since we just completed it.\n  if (deadline !== null) {\n    callbackExpirationTime = NoWork;\n    callbackID = null;\n  }\n  // If there's work left over, schedule a new callback.\n  if (nextFlushedExpirationTime !== NoWork) {\n    scheduleCallbackWithExpirationTime(nextFlushedExpirationTime);\n  }\n\n  // Clean-up.\n  deadline = null;\n  deadlineDidExpire = false;\n\n  finishRendering();\n}\n\nfunction flushRoot(root, expirationTime) {\n  invariant(\n    !isRendering,\n    \"work.commit(): Cannot commit while already rendering. This likely \" +\n      \"means you attempted to commit from inside a lifecycle method.\"\n  );\n  // Perform work on root as if the given expiration time is the current time.\n  // This has the effect of synchronously flushing all work up to and\n  // including the given time.\n  nextFlushedRoot = root;\n  nextFlushedExpirationTime = expirationTime;\n  performWorkOnRoot(root, expirationTime, false);\n  // Flush any sync work that was scheduled by lifecycles\n  performSyncWork();\n  finishRendering();\n}\n\nfunction finishRendering() {\n  nestedUpdateCount = 0;\n\n  if (completedBatches !== null) {\n    var batches = completedBatches;\n    completedBatches = null;\n    for (var i = 0; i < batches.length; i++) {\n      var batch = batches[i];\n      try {\n        batch._onComplete();\n      } catch (error) {\n        if (!hasUnhandledError) {\n          hasUnhandledError = true;\n          unhandledError = error;\n        }\n      }\n    }\n  }\n\n  if (hasUnhandledError) {\n    var error = unhandledError;\n    unhandledError = null;\n    hasUnhandledError = false;\n    throw error;\n  }\n}\n\nfunction performWorkOnRoot(root, expirationTime, isYieldy) {\n  invariant(\n    !isRendering,\n    \"performWorkOnRoot was called recursively. This error is likely caused \" +\n      \"by a bug in React. Please file an issue.\"\n  );\n\n  isRendering = true;\n\n  // Check if this is async work or sync/expired work.\n  if (!isYieldy) {\n    // Flush work without yielding.\n    var finishedWork = root.finishedWork;\n    if (finishedWork !== null) {\n      // This root is already complete. We can commit it.\n      completeRoot(root, finishedWork, expirationTime);\n    } else {\n      root.finishedWork = null;\n      renderRoot(root, false);\n      finishedWork = root.finishedWork;\n      if (finishedWork !== null) {\n        // We've completed the root. Commit it.\n        completeRoot(root, finishedWork, expirationTime);\n      }\n    }\n  } else {\n    // Flush async work.\n    var _finishedWork = root.finishedWork;\n    if (_finishedWork !== null) {\n      // This root is already complete. We can commit it.\n      completeRoot(root, _finishedWork, expirationTime);\n    } else {\n      root.finishedWork = null;\n      renderRoot(root, true);\n      _finishedWork = root.finishedWork;\n      if (_finishedWork !== null) {\n        // We've completed the root. Check the deadline one more time\n        // before committing.\n        if (!shouldYield()) {\n          // Still time left. Commit the root.\n          completeRoot(root, _finishedWork, expirationTime);\n        } else {\n          // There's no time left. Mark this root as complete. We'll come\n          // back and commit it later.\n          root.finishedWork = _finishedWork;\n\n          if (enableProfilerTimer) {\n            // If we didn't finish, pause the \"actual\" render timer.\n            // We'll restart it when we resume work.\n            pauseActualRenderTimerIfRunning();\n          }\n        }\n      }\n    }\n  }\n\n  isRendering = false;\n}\n\nfunction completeRoot(root, finishedWork, expirationTime) {\n  // Check if there's a batch that matches this expiration time.\n  var firstBatch = root.firstBatch;\n  if (firstBatch !== null && firstBatch._expirationTime <= expirationTime) {\n    if (completedBatches === null) {\n      completedBatches = [firstBatch];\n    } else {\n      completedBatches.push(firstBatch);\n    }\n    if (firstBatch._defer) {\n      // This root is blocked from committing by a batch. Unschedule it until\n      // we receive another update.\n      root.finishedWork = finishedWork;\n      root.expirationTime = NoWork;\n      return;\n    }\n  }\n\n  // Commit the root.\n  root.finishedWork = null;\n  commitRoot(root, finishedWork);\n}\n\n// When working on async work, the reconciler asks the renderer if it should\n// yield execution. For DOM, we implement this with requestIdleCallback.\nfunction shouldYield() {\n  if (deadline === null || deadlineDidExpire) {\n    return false;\n  }\n  if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n    // Disregard deadline.didTimeout. Only expired work should be flushed\n    // during a timeout. This path is only hit for non-expired work.\n    return false;\n  }\n  deadlineDidExpire = true;\n  return true;\n}\n\nfunction onUncaughtError(error) {\n  invariant(\n    nextFlushedRoot !== null,\n    \"Should be working on a root. This error is likely caused by a bug in \" +\n      \"React. Please file an issue.\"\n  );\n  // Unschedule this root so we don't work on it again until there's\n  // another update.\n  nextFlushedRoot.expirationTime = NoWork;\n  if (!hasUnhandledError) {\n    hasUnhandledError = true;\n    unhandledError = error;\n  }\n}\n\n// TODO: Batching should be implemented at the renderer level, not inside\n// the reconciler.\nfunction batchedUpdates$1(fn, a) {\n  var previousIsBatchingUpdates = isBatchingUpdates;\n  isBatchingUpdates = true;\n  try {\n    return fn(a);\n  } finally {\n    isBatchingUpdates = previousIsBatchingUpdates;\n    if (!isBatchingUpdates && !isRendering) {\n      performSyncWork();\n    }\n  }\n}\n\n// TODO: Batching should be implemented at the renderer level, not inside\n// the reconciler.\nfunction unbatchedUpdates(fn, a) {\n  if (isBatchingUpdates && !isUnbatchingUpdates) {\n    isUnbatchingUpdates = true;\n    try {\n      return fn(a);\n    } finally {\n      isUnbatchingUpdates = false;\n    }\n  }\n  return fn(a);\n}\n\n// TODO: Batching should be implemented at the renderer level, not within\n// the reconciler.\nfunction flushSync(fn, a) {\n  invariant(\n    !isRendering,\n    \"flushSync was called from inside a lifecycle method. It cannot be \" +\n      \"called when React is already rendering.\"\n  );\n  var previousIsBatchingUpdates = isBatchingUpdates;\n  isBatchingUpdates = true;\n  try {\n    return syncUpdates(fn, a);\n  } finally {\n    isBatchingUpdates = previousIsBatchingUpdates;\n    performSyncWork();\n  }\n}\n\nfunction interactiveUpdates$1(fn, a, b) {\n  if (isBatchingInteractiveUpdates) {\n    return fn(a, b);\n  }\n  // If there are any pending interactive updates, synchronously flush them.\n  // This needs to happen before we read any handlers, because the effect of\n  // the previous event may influence which handlers are called during\n  // this event.\n  if (\n    !isBatchingUpdates &&\n    !isRendering &&\n    lowestPendingInteractiveExpirationTime !== NoWork\n  ) {\n    // Synchronously flush pending interactive updates.\n    performWork(lowestPendingInteractiveExpirationTime, null);\n    lowestPendingInteractiveExpirationTime = NoWork;\n  }\n  var previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;\n  var previousIsBatchingUpdates = isBatchingUpdates;\n  isBatchingInteractiveUpdates = true;\n  isBatchingUpdates = true;\n  try {\n    return fn(a, b);\n  } finally {\n    isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;\n    isBatchingUpdates = previousIsBatchingUpdates;\n    if (!isBatchingUpdates && !isRendering) {\n      performSyncWork();\n    }\n  }\n}\n\nfunction flushInteractiveUpdates$1() {\n  if (!isRendering && lowestPendingInteractiveExpirationTime !== NoWork) {\n    // Synchronously flush pending interactive updates.\n    performWork(lowestPendingInteractiveExpirationTime, null);\n    lowestPendingInteractiveExpirationTime = NoWork;\n  }\n}\n\nfunction flushControlled(fn) {\n  var previousIsBatchingUpdates = isBatchingUpdates;\n  isBatchingUpdates = true;\n  try {\n    syncUpdates(fn);\n  } finally {\n    isBatchingUpdates = previousIsBatchingUpdates;\n    if (!isBatchingUpdates && !isRendering) {\n      performWork(Sync, null);\n    }\n  }\n}\n\n// 0 is PROD, 1 is DEV.\n// Might add PROFILE later.\n\nvar didWarnAboutNestedUpdates = void 0;\n\n{\n  didWarnAboutNestedUpdates = false;\n}\n\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) {\n    return emptyObject;\n  }\n\n  var fiber = get$1(parentComponent);\n  var parentContext = findCurrentUnmaskedContext(fiber);\n  return isContextProvider(fiber)\n    ? processChildContext(fiber, parentContext)\n    : parentContext;\n}\n\nfunction scheduleRootUpdate(current, element, expirationTime, callback) {\n  {\n    if (\n      ReactDebugCurrentFiber.phase === \"render\" &&\n      ReactDebugCurrentFiber.current !== null &&\n      !didWarnAboutNestedUpdates\n    ) {\n      didWarnAboutNestedUpdates = true;\n      warning(\n        false,\n        \"Render methods should be a pure function of props and state; \" +\n          \"triggering nested component updates from render is not allowed. \" +\n          \"If necessary, trigger nested updates in componentDidUpdate.\\n\\n\" +\n          \"Check the render method of %s.\",\n        getComponentName(ReactDebugCurrentFiber.current) || \"Unknown\"\n      );\n    }\n  }\n\n  var update = createUpdate(expirationTime);\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = { element: element };\n\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    !(typeof callback === \"function\")\n      ? warning(\n          false,\n          \"render(...): Expected the last optional `callback` argument to be a \" +\n            \"function. Instead received: %s.\",\n          callback\n        )\n      : void 0;\n    update.callback = callback;\n  }\n  enqueueUpdate(current, update, expirationTime);\n\n  scheduleWork(current, expirationTime);\n  return expirationTime;\n}\n\nfunction updateContainerAtExpirationTime(\n  element,\n  container,\n  parentComponent,\n  expirationTime,\n  callback\n) {\n  // TODO: If this is a nested container, this won't be the root.\n  var current = container.current;\n\n  {\n    if (ReactFiberInstrumentation_1.debugTool) {\n      if (current.alternate === null) {\n        ReactFiberInstrumentation_1.debugTool.onMountContainer(container);\n      } else if (element === null) {\n        ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);\n      } else {\n        ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);\n      }\n    }\n  }\n\n  var context = getContextForSubtree(parentComponent);\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingContext = context;\n  }\n\n  return scheduleRootUpdate(current, element, expirationTime, callback);\n}\n\nfunction findHostInstance$1(component) {\n  var fiber = get$1(component);\n  if (fiber === undefined) {\n    if (typeof component.render === \"function\") {\n      invariant(false, \"Unable to find node on an unmounted component.\");\n    } else {\n      invariant(\n        false,\n        \"Argument appears to not be a ReactComponent. Keys: %s\",\n        Object.keys(component)\n      );\n    }\n  }\n  var hostFiber = findCurrentHostFiber(fiber);\n  if (hostFiber === null) {\n    return null;\n  }\n  return hostFiber.stateNode;\n}\n\nfunction createContainer(containerInfo, isAsync, hydrate) {\n  return createFiberRoot(containerInfo, isAsync, hydrate);\n}\n\nfunction updateContainer(element, container, parentComponent, callback) {\n  var current = container.current;\n  var currentTime = recalculateCurrentTime();\n  var expirationTime = computeExpirationForFiber(currentTime, current);\n  return updateContainerAtExpirationTime(\n    element,\n    container,\n    parentComponent,\n    expirationTime,\n    callback\n  );\n}\n\nfunction getPublicRootInstance(container) {\n  var containerFiber = container.current;\n  if (!containerFiber.child) {\n    return null;\n  }\n  switch (containerFiber.child.tag) {\n    case HostComponent:\n      return getPublicInstance(containerFiber.child.stateNode);\n    default:\n      return containerFiber.child.stateNode;\n  }\n}\n\nfunction findHostInstanceWithNoPortals(fiber) {\n  var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n  if (hostFiber === null) {\n    return null;\n  }\n  return hostFiber.stateNode;\n}\n\nfunction injectIntoDevTools(devToolsConfig) {\n  var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n\n  return injectInternals(\n    Object.assign({}, devToolsConfig, {\n      findHostInstanceByFiber: function(fiber) {\n        var hostFiber = findCurrentHostFiber(fiber);\n        if (hostFiber === null) {\n          return null;\n        }\n        return hostFiber.stateNode;\n      },\n      findFiberByHostInstance: function(instance) {\n        if (!findFiberByHostInstance) {\n          // Might not be implemented by the renderer.\n          return null;\n        }\n        return findFiberByHostInstance(instance);\n      }\n    })\n  );\n}\n\n// This file intentionally does *not* have the Flow annotation.\n// Don't add it. See `./inline-typed.js` for an explanation.\n\nvar ReactNativeFiberRenderer = Object.freeze({\n  updateContainerAtExpirationTime: updateContainerAtExpirationTime,\n  createContainer: createContainer,\n  updateContainer: updateContainer,\n  flushRoot: flushRoot,\n  requestWork: requestWork,\n  computeUniqueAsyncExpiration: computeUniqueAsyncExpiration,\n  batchedUpdates: batchedUpdates$1,\n  unbatchedUpdates: unbatchedUpdates,\n  deferredUpdates: deferredUpdates,\n  syncUpdates: syncUpdates,\n  interactiveUpdates: interactiveUpdates$1,\n  flushInteractiveUpdates: flushInteractiveUpdates$1,\n  flushControlled: flushControlled,\n  flushSync: flushSync,\n  getPublicRootInstance: getPublicRootInstance,\n  findHostInstance: findHostInstance$1,\n  findHostInstanceWithNoPortals: findHostInstanceWithNoPortals,\n  injectIntoDevTools: injectIntoDevTools\n});\n\nfunction createPortal(\n  children,\n  containerInfo,\n  // TODO: figure out the API for cross-renderer implementation.\n  implementation\n) {\n  var key =\n    arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  return {\n    // This tag allow us to uniquely identify this as a React Portal\n    $$typeof: REACT_PORTAL_TYPE,\n    key: key == null ? null : \"\" + key,\n    children: children,\n    containerInfo: containerInfo,\n    implementation: implementation\n  };\n}\n\n// TODO: this is special because it gets imported during build.\n\nvar ReactVersion = \"16.4.1\";\n\n// Modules provided by RN:\nvar NativeMethodsMixin = function(findNodeHandle, findHostInstance) {\n  /**\n   * `NativeMethodsMixin` provides methods to access the underlying native\n   * component directly. This can be useful in cases when you want to focus\n   * a view or measure its on-screen dimensions, for example.\n   *\n   * The methods described here are available on most of the default components\n   * provided by React Native. Note, however, that they are *not* available on\n   * composite components that aren't directly backed by a native view. This will\n   * generally include most components that you define in your own app. For more\n   * information, see [Direct\n   * Manipulation](docs/direct-manipulation.html).\n   *\n   * Note the Flow $Exact<> syntax is required to support mixins.\n   * React createClass mixins can only be used with exact types.\n   */\n  var NativeMethodsMixin = {\n    /**\n     * Determines the location on screen, width, and height of the given view and\n     * returns the values via an async callback. If successful, the callback will\n     * be called with the following arguments:\n     *\n     *  - x\n     *  - y\n     *  - width\n     *  - height\n     *  - pageX\n     *  - pageY\n     *\n     * Note that these measurements are not available until after the rendering\n     * has been completed in native. If you need the measurements as soon as\n     * possible, consider using the [`onLayout`\n     * prop](docs/view.html#onlayout) instead.\n     */\n    measure: function(callback) {\n      UIManager.measure(\n        findNodeHandle(this),\n        mountSafeCallback(this, callback)\n      );\n    },\n\n    /**\n     * Determines the location of the given view in the window and returns the\n     * values via an async callback. If the React root view is embedded in\n     * another native view, this will give you the absolute coordinates. If\n     * successful, the callback will be called with the following\n     * arguments:\n     *\n     *  - x\n     *  - y\n     *  - width\n     *  - height\n     *\n     * Note that these measurements are not available until after the rendering\n     * has been completed in native.\n     */\n    measureInWindow: function(callback) {\n      UIManager.measureInWindow(\n        findNodeHandle(this),\n        mountSafeCallback(this, callback)\n      );\n    },\n\n    /**\n     * Like [`measure()`](#measure), but measures the view relative an ancestor,\n     * specified as `relativeToNativeNode`. This means that the returned x, y\n     * are relative to the origin x, y of the ancestor view.\n     *\n     * As always, to obtain a native node handle for a component, you can use\n     * `findNodeHandle(component)`.\n     */\n    measureLayout: function(\n      relativeToNativeNode,\n      onSuccess,\n      onFail /* currently unused */\n    ) {\n      UIManager.measureLayout(\n        findNodeHandle(this),\n        relativeToNativeNode,\n        mountSafeCallback(this, onFail),\n        mountSafeCallback(this, onSuccess)\n      );\n    },\n\n    /**\n     * This function sends props straight to native. They will not participate in\n     * future diff process - this means that if you do not include them in the\n     * next render, they will remain active (see [Direct\n     * Manipulation](docs/direct-manipulation.html)).\n     */\n    setNativeProps: function(nativeProps) {\n      // Class components don't have viewConfig -> validateAttributes.\n      // Nor does it make sense to set native props on a non-native component.\n      // Instead, find the nearest host component and set props on it.\n      // Use findNodeHandle() rather than findNodeHandle() because\n      // We want the instance/wrapper (not the native tag).\n      var maybeInstance = void 0;\n\n      // Fiber errors if findNodeHandle is called for an umounted component.\n      // Tests using ReactTestRenderer will trigger this case indirectly.\n      // Mimicking stack behavior, we should silently ignore this case.\n      // TODO Fix ReactTestRenderer so we can remove this try/catch.\n      try {\n        maybeInstance = findHostInstance(this);\n      } catch (error) {}\n\n      // If there is no host component beneath this we should fail silently.\n      // This is not an error; it could mean a class component rendered null.\n      if (maybeInstance == null) {\n        return;\n      }\n\n      var viewConfig = maybeInstance.viewConfig;\n\n      {\n        warnForStyleProps(nativeProps, viewConfig.validAttributes);\n      }\n\n      var updatePayload = create(nativeProps, viewConfig.validAttributes);\n\n      // Avoid the overhead of bridge calls if there's no update.\n      // This is an expensive no-op for Android, and causes an unnecessary\n      // view invalidation for certain components (eg RCTTextInput) on iOS.\n      if (updatePayload != null) {\n        UIManager.updateView(\n          maybeInstance._nativeTag,\n          viewConfig.uiViewClassName,\n          updatePayload\n        );\n      }\n    },\n\n    /**\n     * Requests focus for the given input or view. The exact behavior triggered\n     * will depend on the platform and type of view.\n     */\n    focus: function() {\n      TextInputState.focusTextInput(findNodeHandle(this));\n    },\n\n    /**\n     * Removes focus from an input or view. This is the opposite of `focus()`.\n     */\n    blur: function() {\n      TextInputState.blurTextInput(findNodeHandle(this));\n    }\n  };\n\n  {\n    // hide this from Flow since we can't define these properties outside of\n    // true without actually implementing them (setting them to undefined\n    // isn't allowed by ReactClass)\n    var NativeMethodsMixin_DEV = NativeMethodsMixin;\n    invariant(\n      !NativeMethodsMixin_DEV.componentWillMount &&\n        !NativeMethodsMixin_DEV.componentWillReceiveProps &&\n        !NativeMethodsMixin_DEV.UNSAFE_componentWillMount &&\n        !NativeMethodsMixin_DEV.UNSAFE_componentWillReceiveProps,\n      \"Do not override existing functions.\"\n    );\n    // TODO (bvaughn) Remove cWM and cWRP in a future version of React Native,\n    // Once these lifecycles have been remove from the reconciler.\n    NativeMethodsMixin_DEV.componentWillMount = function() {\n      throwOnStylesProp(this, this.props);\n    };\n    NativeMethodsMixin_DEV.componentWillReceiveProps = function(newProps) {\n      throwOnStylesProp(this, newProps);\n    };\n    NativeMethodsMixin_DEV.UNSAFE_componentWillMount = function() {\n      throwOnStylesProp(this, this.props);\n    };\n    NativeMethodsMixin_DEV.UNSAFE_componentWillReceiveProps = function(\n      newProps\n    ) {\n      throwOnStylesProp(this, newProps);\n    };\n\n    // React may warn about cWM/cWRP/cWU methods being deprecated.\n    // Add a flag to suppress these warnings for this special case.\n    // TODO (bvaughn) Remove this flag once the above methods have been removed.\n    NativeMethodsMixin_DEV.componentWillMount.__suppressDeprecationWarning = true;\n    NativeMethodsMixin_DEV.componentWillReceiveProps.__suppressDeprecationWarning = true;\n  }\n\n  return NativeMethodsMixin;\n};\n\nfunction _classCallCheck$1(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\n      \"this hasn't been initialised - super() hasn't been called\"\n    );\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\")\n    ? call\n    : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\n      \"Super expression must either be null or a function, not \" +\n        typeof superClass\n    );\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass)\n    Object.setPrototypeOf\n      ? Object.setPrototypeOf(subClass, superClass)\n      : (subClass.__proto__ = superClass);\n}\n\n// Modules provided by RN:\nvar ReactNativeComponent = function(findNodeHandle, findHostInstance) {\n  /**\n   * Superclass that provides methods to access the underlying native component.\n   * This can be useful when you want to focus a view or measure its dimensions.\n   *\n   * Methods implemented by this class are available on most default components\n   * provided by React Native. However, they are *not* available on composite\n   * components that are not directly backed by a native view. For more\n   * information, see [Direct Manipulation](docs/direct-manipulation.html).\n   *\n   * @abstract\n   */\n  var ReactNativeComponent = (function(_React$Component) {\n    _inherits(ReactNativeComponent, _React$Component);\n\n    function ReactNativeComponent() {\n      _classCallCheck$1(this, ReactNativeComponent);\n\n      return _possibleConstructorReturn(\n        this,\n        _React$Component.apply(this, arguments)\n      );\n    }\n\n    /**\n     * Removes focus. This is the opposite of `focus()`.\n     */\n\n    /**\n     * Due to bugs in Flow's handling of React.createClass, some fields already\n     * declared in the base class need to be redeclared below.\n     */\n    ReactNativeComponent.prototype.blur = function blur() {\n      TextInputState.blurTextInput(findNodeHandle(this));\n    };\n\n    /**\n     * Requests focus. The exact behavior depends on the platform and view.\n     */\n\n    ReactNativeComponent.prototype.focus = function focus() {\n      TextInputState.focusTextInput(findNodeHandle(this));\n    };\n\n    /**\n     * Measures the on-screen location and dimensions. If successful, the callback\n     * will be called asynchronously with the following arguments:\n     *\n     *  - x\n     *  - y\n     *  - width\n     *  - height\n     *  - pageX\n     *  - pageY\n     *\n     * These values are not available until after natives rendering completes. If\n     * you need the measurements as soon as possible, consider using the\n     * [`onLayout` prop](docs/view.html#onlayout) instead.\n     */\n\n    ReactNativeComponent.prototype.measure = function measure(callback) {\n      UIManager.measure(\n        findNodeHandle(this),\n        mountSafeCallback(this, callback)\n      );\n    };\n\n    /**\n     * Measures the on-screen location and dimensions. Even if the React Native\n     * root view is embedded within another native view, this method will give you\n     * the absolute coordinates measured from the window. If successful, the\n     * callback will be called asynchronously with the following arguments:\n     *\n     *  - x\n     *  - y\n     *  - width\n     *  - height\n     *\n     * These values are not available until after natives rendering completes.\n     */\n\n    ReactNativeComponent.prototype.measureInWindow = function measureInWindow(\n      callback\n    ) {\n      UIManager.measureInWindow(\n        findNodeHandle(this),\n        mountSafeCallback(this, callback)\n      );\n    };\n\n    /**\n     * Similar to [`measure()`](#measure), but the resulting location will be\n     * relative to the supplied ancestor's location.\n     *\n     * Obtain a native node handle with `ReactNative.findNodeHandle(component)`.\n     */\n\n    ReactNativeComponent.prototype.measureLayout = function measureLayout(\n      relativeToNativeNode,\n      onSuccess,\n      onFail /* currently unused */\n    ) {\n      UIManager.measureLayout(\n        findNodeHandle(this),\n        relativeToNativeNode,\n        mountSafeCallback(this, onFail),\n        mountSafeCallback(this, onSuccess)\n      );\n    };\n\n    /**\n     * This function sends props straight to native. They will not participate in\n     * future diff process - this means that if you do not include them in the\n     * next render, they will remain active (see [Direct\n     * Manipulation](docs/direct-manipulation.html)).\n     */\n\n    ReactNativeComponent.prototype.setNativeProps = function setNativeProps(\n      nativeProps\n    ) {\n      // Class components don't have viewConfig -> validateAttributes.\n      // Nor does it make sense to set native props on a non-native component.\n      // Instead, find the nearest host component and set props on it.\n      // Use findNodeHandle() rather than ReactNative.findNodeHandle() because\n      // We want the instance/wrapper (not the native tag).\n      var maybeInstance = void 0;\n\n      // Fiber errors if findNodeHandle is called for an umounted component.\n      // Tests using ReactTestRenderer will trigger this case indirectly.\n      // Mimicking stack behavior, we should silently ignore this case.\n      // TODO Fix ReactTestRenderer so we can remove this try/catch.\n      try {\n        maybeInstance = findHostInstance(this);\n      } catch (error) {}\n\n      // If there is no host component beneath this we should fail silently.\n      // This is not an error; it could mean a class component rendered null.\n      if (maybeInstance == null) {\n        return;\n      }\n\n      var viewConfig =\n        maybeInstance.viewConfig || maybeInstance.canonical.viewConfig;\n\n      var updatePayload = create(nativeProps, viewConfig.validAttributes);\n\n      // Avoid the overhead of bridge calls if there's no update.\n      // This is an expensive no-op for Android, and causes an unnecessary\n      // view invalidation for certain components (eg RCTTextInput) on iOS.\n      if (updatePayload != null) {\n        UIManager.updateView(\n          maybeInstance._nativeTag,\n          viewConfig.uiViewClassName,\n          updatePayload\n        );\n      }\n    };\n\n    return ReactNativeComponent;\n  })(React.Component);\n\n  // eslint-disable-next-line no-unused-expressions\n\n  return ReactNativeComponent;\n};\n\n// Module provided by RN:\nvar getInspectorDataForViewTag = void 0;\n\n{\n  var traverseOwnerTreeUp = function(hierarchy, instance) {\n    if (instance) {\n      hierarchy.unshift(instance);\n      traverseOwnerTreeUp(hierarchy, instance._debugOwner);\n    }\n  };\n\n  var getOwnerHierarchy = function(instance) {\n    var hierarchy = [];\n    traverseOwnerTreeUp(hierarchy, instance);\n    return hierarchy;\n  };\n\n  var lastNonHostInstance = function(hierarchy) {\n    for (var i = hierarchy.length - 1; i > 1; i--) {\n      var instance = hierarchy[i];\n\n      if (instance.tag !== HostComponent) {\n        return instance;\n      }\n    }\n    return hierarchy[0];\n  };\n\n  var getHostProps = function(fiber) {\n    var host = findCurrentHostFiber(fiber);\n    if (host) {\n      return host.memoizedProps || emptyObject;\n    }\n    return emptyObject;\n  };\n\n  var getHostNode = function(fiber, findNodeHandle) {\n    var hostNode = void 0;\n    // look for children first for the hostNode\n    // as composite fibers do not have a hostNode\n    while (fiber) {\n      if (fiber.stateNode !== null && fiber.tag === HostComponent) {\n        hostNode = findNodeHandle(fiber.stateNode);\n      }\n      if (hostNode) {\n        return hostNode;\n      }\n      fiber = fiber.child;\n    }\n    return null;\n  };\n\n  var createHierarchy = function(fiberHierarchy) {\n    return fiberHierarchy.map(function(fiber) {\n      return {\n        name: getComponentName(fiber),\n        getInspectorData: function(findNodeHandle) {\n          return {\n            measure: function(callback) {\n              return UIManager.measure(\n                getHostNode(fiber, findNodeHandle),\n                callback\n              );\n            },\n            props: getHostProps(fiber),\n            source: fiber._debugSource\n          };\n        }\n      };\n    });\n  };\n\n  getInspectorDataForViewTag = function(viewTag) {\n    var closestInstance = getInstanceFromTag(viewTag);\n\n    // Handle case where user clicks outside of ReactNative\n    if (!closestInstance) {\n      return {\n        hierarchy: [],\n        props: emptyObject,\n        selection: null,\n        source: null\n      };\n    }\n\n    var fiber = findCurrentFiberUsingSlowPath(closestInstance);\n    var fiberHierarchy = getOwnerHierarchy(fiber);\n    var instance = lastNonHostInstance(fiberHierarchy);\n    var hierarchy = createHierarchy(fiberHierarchy);\n    var props = getHostProps(instance);\n    var source = instance._debugSource;\n    var selection = fiberHierarchy.indexOf(instance);\n\n    return {\n      hierarchy: hierarchy,\n      props: props,\n      selection: selection,\n      source: source\n    };\n  };\n}\n\n// Module provided by RN:\nvar findHostInstance = findHostInstance$1;\n\nfunction findNodeHandle(componentOrHandle) {\n  {\n    var owner = ReactCurrentOwner.current;\n    if (owner !== null && owner.stateNode !== null) {\n      !owner.stateNode._warnedAboutRefsInRender\n        ? warning(\n            false,\n            \"%s is accessing findNodeHandle inside its render(). \" +\n              \"render() should be a pure function of props and state. It should \" +\n              \"never access something that requires stale data from the previous \" +\n              \"render, such as refs. Move this logic to componentDidMount and \" +\n              \"componentDidUpdate instead.\",\n            getComponentName(owner) || \"A component\"\n          )\n        : void 0;\n\n      owner.stateNode._warnedAboutRefsInRender = true;\n    }\n  }\n  if (componentOrHandle == null) {\n    return null;\n  }\n  if (typeof componentOrHandle === \"number\") {\n    // Already a node handle\n    return componentOrHandle;\n  }\n  if (componentOrHandle._nativeTag) {\n    return componentOrHandle._nativeTag;\n  }\n  if (componentOrHandle.canonical && componentOrHandle.canonical._nativeTag) {\n    return componentOrHandle.canonical._nativeTag;\n  }\n  var hostInstance = findHostInstance(componentOrHandle);\n  if (hostInstance == null) {\n    return hostInstance;\n  }\n  if (hostInstance.canonical) {\n    // Fabric\n    return hostInstance.canonical._nativeTag;\n  }\n  return hostInstance._nativeTag;\n}\n\ninjection$2.injectRenderer(ReactNativeFiberRenderer);\n\nfunction computeComponentStackForErrorReporting(reactTag) {\n  var fiber = getInstanceFromTag(reactTag);\n  if (!fiber) {\n    return \"\";\n  }\n  return getStackAddendumByWorkInProgressFiber(fiber);\n}\n\nvar roots = new Map();\n\nvar ReactNativeRenderer = {\n  NativeComponent: ReactNativeComponent(findNodeHandle, findHostInstance),\n\n  findNodeHandle: findNodeHandle,\n\n  render: function(element, containerTag, callback) {\n    var root = roots.get(containerTag);\n\n    if (!root) {\n      // TODO (bvaughn): If we decide to keep the wrapper component,\n      // We could create a wrapper for containerTag as well to reduce special casing.\n      root = createContainer(containerTag, false, false);\n      roots.set(containerTag, root);\n    }\n    updateContainer(element, root, null, callback);\n\n    return getPublicRootInstance(root);\n  },\n  unmountComponentAtNode: function(containerTag) {\n    var root = roots.get(containerTag);\n    if (root) {\n      // TODO: Is it safe to reset this now or should I wait since this unmount could be deferred?\n      updateContainer(null, root, null, function() {\n        roots.delete(containerTag);\n      });\n    }\n  },\n  unmountComponentAtNodeAndRemoveContainer: function(containerTag) {\n    ReactNativeRenderer.unmountComponentAtNode(containerTag);\n\n    // Call back into native to remove all of the subviews from this container\n    UIManager.removeRootView(containerTag);\n  },\n  createPortal: function(children, containerTag) {\n    var key =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    return createPortal(children, containerTag, null, key);\n  },\n\n  unstable_batchedUpdates: batchedUpdates,\n\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n    // Used as a mixin in many createClass-based components\n    NativeMethodsMixin: NativeMethodsMixin(findNodeHandle, findHostInstance),\n    computeComponentStackForErrorReporting: computeComponentStackForErrorReporting\n  }\n};\n\ninjectIntoDevTools({\n  findFiberByHostInstance: getInstanceFromTag,\n  getInspectorDataForViewTag: getInspectorDataForViewTag,\n  bundleType: 1,\n  version: ReactVersion,\n  rendererPackageName: \"react-native-renderer\"\n});\n\nvar ReactNativeRenderer$2 = Object.freeze({\n  default: ReactNativeRenderer\n});\n\nvar ReactNativeRenderer$3 =\n  (ReactNativeRenderer$2 && ReactNativeRenderer) || ReactNativeRenderer$2;\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar reactNativeRenderer = ReactNativeRenderer$3.default\n  ? ReactNativeRenderer$3.default\n  : ReactNativeRenderer$3;\n\nmodule.exports = reactNativeRenderer;\n\n  })();\n}\n"]}